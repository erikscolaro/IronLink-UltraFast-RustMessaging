<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
<<<<<<< HEAD
        var data = {"files":[{"path":["/","home","runner","work","G43","G43","server","src","config.rs"],"content":"use dotenv::dotenv;\nuse std::env;\n\npub fn init() {\n\tdotenv().ok();\n\tprintln!(\"Config loaded: {:?}\", env::var(\"APP_ENV\").unwrap_or(\"dev\".into()));\n}\n\n","traces":[{"line":4,"address":[6638554,6638160,6638548],"length":1,"stats":{"Line":0}},{"line":5,"address":[6638167],"length":1,"stats":{"Line":0}},{"line":6,"address":[6638307,6638232,6638567],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","G43","G43","server","src","handlers.rs"],"content":"use axum::response::Json;\nuse serde_json::json;\n\npub async fn root() -\u003e Json\u003cserde_json::Value\u003e {\n\tJson(json!({\"message\": \"Hello, Axum!\"}))\n}\n\n","traces":[{"line":4,"address":[6404608],"length":1,"stats":{"Line":3}},{"line":5,"address":[6518654,6519021,6518589,6518551,6518466],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","G43","G43","server","src","main.rs"],"content":"use axum::Router;\nuse std::net::SocketAddr;\nuse tokio::net::TcpListener;\n\nmod routes;\nmod handlers;\nmod config;\nmod models;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Inizializza la configurazione\n    config::init();\n\n    // Crea il router\n    let app = Router::new().merge(routes::router());\n\n    // Definisci l'indirizzo\n    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));\n    println!(\"Server listening on http://{}\", addr);\n\n    // Crea il listener TCP\n    let listener = TcpListener::bind(addr).await?;\n\n    // Avvia il server\n    axum::serve(listener, app)\n        .await?;\n\n    Ok(())\n}\n\n// --- TEST MINIMALE ---\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use axum::body::Body;\n    use axum::http::{Request, StatusCode};\n    use tower::ServiceExt;\n    // for `oneshot` \n\n    #[tokio::test]\n    async fn test_root() {\n        let app = Router::new().merge(routes::router());\n        let response = app\n            .oneshot(Request::builder().uri(\"/\").body(Body::empty()).unwrap())\n            .await\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n}\n","traces":[{"line":11,"address":[6807148,6807154,6806640],"length":1,"stats":{"Line":0}},{"line":13,"address":[6573813],"length":1,"stats":{"Line":0}},{"line":16,"address":[6573959,6573947,6574027,6574586],"length":1,"stats":{"Line":0}},{"line":19,"address":[6574155],"length":1,"stats":{"Line":0}},{"line":20,"address":[6574332],"length":1,"stats":{"Line":0}},{"line":23,"address":[6573866,6574653,6574517,6575270,6574416],"length":1,"stats":{"Line":0}},{"line":26,"address":[6575228,6575726,6575523,6575599,6575057,6575482],"length":1,"stats":{"Line":0}},{"line":27,"address":[6575583,6575503,6575321,6573887,6575193,6575244],"length":1,"stats":{"Line":0}},{"line":29,"address":[6575630],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","runner","work","G43","G43","server","src","models.rs"],"content":"use sqlx::{SqlitePool, Row};\nuse tokio;\nuse dotenv::dotenv;\nuse std::env;\n\n#[derive(Debug, Clone)]\npub struct User {\n\tpub id: i64,\n\tpub name: String,\n}\n\npub struct UserRepo {\n\tpool: SqlitePool,\n}\n\nimpl UserRepo {\n\t// crea e connette direttamente al DB dal DATABASE_URL\n\tpub async fn new() -\u003e Result\u003cSelf, sqlx::Error\u003e {\n\t\tdotenv().ok();\n\t\tlet database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n\t\tlet pool = SqlitePool::connect(\u0026database_url).await?;\n\t\tOk(Self { pool })\n\t}\n\n\tpub async fn get_by_id(\u0026self, id: i64) -\u003e Result\u003cOption\u003cUser\u003e, sqlx::Error\u003e {\n\t\tlet row = sqlx::query(\"SELECT id, name FROM users WHERE id = ?\")\n\t\t\t.bind(id)\n\t\t\t.fetch_optional(\u0026self.pool)\n\t\t\t.await?;\n\t\tOk(row.map(|r| User { id: r.get(0), name: r.get(1) }))\n\t}\n\n\tpub async fn create(\u0026self, user: User) -\u003e Result\u003c(), sqlx::Error\u003e {\n\t\tsqlx::query(\"INSERT INTO users (id, name) VALUES (?, ?)\")\n\t\t\t.bind(user.id)\n\t\t\t.bind(user.name)\n\t\t\t.execute(\u0026self.pool)\n\t\t\t.await?;\n\t\tOk(())\n\t}\n}","traces":[{"line":18,"address":[7009651,7009648],"length":1,"stats":{"Line":0}},{"line":19,"address":[6860433,6860330],"length":1,"stats":{"Line":0}},{"line":20,"address":[6860470],"length":1,"stats":{"Line":0}},{"line":21,"address":[6860621,6860373,6860545,6860730],"length":1,"stats":{"Line":0}},{"line":22,"address":[6861097],"length":1,"stats":{"Line":0}},{"line":25,"address":[6862224,6862389,6863291,6862442,6862267,6862611],"length":1,"stats":{"Line":0}},{"line":26,"address":[6862846,6862787,6862569,6862358,6862946],"length":1,"stats":{"Line":0}},{"line":27,"address":[6862486],"length":1,"stats":{"Line":0}},{"line":28,"address":[6862534],"length":1,"stats":{"Line":0}},{"line":29,"address":[6862835,6862904,6862557,6862642,6862596,6862416],"length":1,"stats":{"Line":0}},{"line":30,"address":[6863137,6863039,6863312,6863339],"length":1,"stats":{"Line":0}},{"line":33,"address":[6861259,6861389,6861669,6862156,6862174,6861216],"length":1,"stats":{"Line":0}},{"line":34,"address":[6861358,6861630,6861848,6862004,6861907],"length":1,"stats":{"Line":0}},{"line":35,"address":[6861479],"length":1,"stats":{"Line":0}},{"line":36,"address":[6861515],"length":1,"stats":{"Line":0}},{"line":37,"address":[6861598],"length":1,"stats":{"Line":0}},{"line":38,"address":[6861618,6861896,6861654,6861416,6861965,6861700],"length":1,"stats":{"Line":0}},{"line":39,"address":[6862069],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","runner","work","G43","G43","server","src","routes.rs"],"content":"use axum::Router;\nuse crate::handlers;\n\npub fn router() -\u003e Router {\n\tRouter::new()\n\t\t.route(\"/\", axum::routing::get(handlers::root))\n}\n","traces":[{"line":4,"address":[6763728,6763877,6763902],"length":1,"stats":{"Line":1}},{"line":5,"address":[6763735,6763807],"length":1,"stats":{"Line":2}},{"line":6,"address":[6763820,6763766,6763773,6763895],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3}]};
        var previousData = null;
=======
        var data = {"files":[{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","auth.rs"],"content":"use crate::core::{AppError, AppState};\r\nuse crate::entities::{User, UserChatMetadata, UserRole};\r\nuse crate::repositories::Read;\r\nuse axum::extract::State;\r\nuse axum::{Error, body::Body, extract::Request, http, http::Response, middleware::Next};\r\nuse chrono::{Duration, Utc};\r\nuse jsonwebtoken::{DecodingKey, EncodingKey, Header, TokenData, Validation, decode, encode};\r\nuse serde::{Deserialize, Serialize};\r\nuse std::sync::Arc;\r\nuse tracing::{debug, error, info, instrument, warn};\r\n\r\n// struct che codifica il contenuto del token jwt\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct Claims {\r\n    pub exp: usize, // Expiry time of the token\r\n    pub iat: usize, // Issued at time of the token\r\n    pub id: i32,\r\n    pub username: String,\r\n}\r\n\r\n#[instrument(skip(secret), fields(username = %username, id = %id))]\r\npub fn encode_jwt(username: String, id: i32, secret: \u0026String) -\u003e Result\u003cString, Error\u003e {\r\n    debug!(\"Encoding JWT token for user\");\r\n    let now = Utc::now();\r\n    let expire: chrono::TimeDelta = Duration::hours(24);\r\n    let exp: usize = (now + expire).timestamp() as usize;\r\n    let iat: usize = now.timestamp() as usize;\r\n    let claim = Claims {\r\n        iat,\r\n        exp,\r\n        username,\r\n        id,\r\n    };\r\n\r\n    encode(\r\n        \u0026Header::default(),\r\n        \u0026claim,\r\n        \u0026EncodingKey::from_secret(secret.as_ref()),\r\n    )\r\n    .map(|token| {\r\n        info!(\"JWT token encoded successfully\");\r\n        token\r\n    })\r\n    .map_err(|e| {\r\n        error!(\"Failed to encode JWT token: {:?}\", e);\r\n        Error::new(\"Error in encoding jwt token\")\r\n    })\r\n}\r\n\r\n#[instrument(skip(jwt_token, secret))]\r\npub fn decode_jwt(jwt_token: String, secret: \u0026String) -\u003e Result\u003cTokenData\u003cClaims\u003e, Error\u003e {\r\n    debug!(\"Decoding JWT token\");\r\n    decode(\r\n        \u0026jwt_token,\r\n        \u0026DecodingKey::from_secret(secret.as_ref()),\r\n        \u0026Validation::default(),\r\n    )\r\n    .map(|data: TokenData\u003cClaims\u003e| {\r\n        info!(\"JWT token decoded successfully for user: {}\", data.claims.username);\r\n        data\r\n    })\r\n    .map_err(|e| {\r\n        error!(\"Failed to decode JWT token: {:?}\", e);\r\n        Error::new(\"Error in decoding jwt token\")\r\n    })\r\n}\r\n\r\n#[instrument(skip(state, req, next))]\r\npub async fn authentication_middleware(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    mut req: Request,\r\n    next: Next,\r\n) -\u003e Result\u003cResponse\u003cBody\u003e, AppError\u003e {\r\n    debug!(\"Running authentication middleware\");\r\n    let auth_header = req.headers_mut().get(http::header::AUTHORIZATION);\r\n    let auth_header = match auth_header {\r\n        Some(header) =\u003e header\r\n            .to_str()\r\n            .map_err(|_| {\r\n                warn!(\"Invalid authorization header format\");\r\n                AppError::forbidden(\"Empty header is not allowed\")\r\n            })?,\r\n        None =\u003e {\r\n            warn!(\"Missing authorization header\");\r\n            return Err(AppError::forbidden(\r\n                \"Please add the JWT token to the header\",\r\n            ));\r\n        }\r\n    };\r\n    let mut header = auth_header.split_whitespace();\r\n    let (_bearer, token) = (header.next(), header.next());\r\n    let token_data = match decode_jwt(token.unwrap().to_string(), \u0026state.jwt_secret) {\r\n        Ok(data) =\u003e data,\r\n        Err(_) =\u003e {\r\n            warn!(\"Failed to decode JWT token\");\r\n            return Err(AppError::unauthorized(\"Unable to decode token\"));\r\n        }\r\n    };\r\n\r\n    // Fetch the user details from the database\r\n    let current_user = match state\r\n        .user\r\n        .find_by_username(\u0026token_data.claims.username)\r\n        .await?\r\n    {\r\n        Some(user) =\u003e {\r\n            info!(\"User authenticated: {}\", user.username);\r\n            user\r\n        }\r\n        None =\u003e {\r\n            warn!(\"User not found in database: {}\", token_data.claims.username);\r\n            return Err(AppError::unauthorized(\"You are not an authorized user\"));\r\n        }\r\n    };\r\n    req.extensions_mut().insert(current_user);\r\n    // voledo si può recuperare lo user da extension\r\n    Ok(next.run(req).await)\r\n}\r\n\r\n/// Middleware che verifica che l'utente corrente sia membro della chat specificata\r\n/// Estrae chat_id dal path, verifica la membership tramite metadata e inserisce il metadata nell'Extension\r\n#[instrument(skip(state, req, next))]\r\npub async fn chat_membership_middleware(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    mut req: Request,\r\n    next: Next,\r\n) -\u003e Result\u003cResponse\u003cBody\u003e, AppError\u003e {\r\n    debug!(\"Running chat membership middleware\");\r\n    // 1. Ottenere l'utente corrente dall'Extension (deve essere stato inserito dall'authentication_middleware)\r\n    let current_user = req\r\n        .extensions()\r\n        .get::\u003cUser\u003e()\r\n        .ok_or_else(|| {\r\n            warn!(\"User not found in request extensions\");\r\n            AppError::unauthorized(\"User not authenticated\")\r\n        })?\r\n        .clone();\r\n\r\n    // 2. Estrarre chat_id dal path\r\n    let chat_id: i32 = req\r\n        .uri()\r\n        .path()\r\n        .split('/')\r\n        .find_map(|segment| segment.parse::\u003ci32\u003e().ok())\r\n        .ok_or_else(|| {\r\n            warn!(\"Chat ID not found in path: {}\", req.uri().path());\r\n            AppError::bad_request(\"Chat ID not found in path\")\r\n        })?;\r\n\r\n    debug!(\"Checking membership for user {} in chat {}\", current_user.user_id, chat_id);\r\n    \r\n    // 3. Verificare che l'utente sia membro della chat tramite metadata\r\n    let metadata = state\r\n        .meta\r\n        .read(\u0026(current_user.user_id, chat_id))\r\n        .await?\r\n        .ok_or_else(|| {\r\n            warn!(\"User {} is not a member of chat {}\", current_user.user_id, chat_id);\r\n            AppError::forbidden(\"You are not a member of this chat\")\r\n        })?;\r\n\r\n    info!(\"User {} verified as member of chat {}\", current_user.user_id, chat_id);\r\n    \r\n    // 4. Inserire il metadata nell'Extension per uso successivo negli handler\r\n    req.extensions_mut().insert(metadata);\r\n\r\n    Ok(next.run(req).await)\r\n}\r\n\r\n/// Helper function per verificare che un utente abbia uno dei ruoli richiesti\r\n///\r\n/// # Arguments\r\n/// * `metadata` - Il metadata dell'utente da verificare\r\n/// * `allowed_roles` - Lista di ruoli permessi\r\n///\r\n/// # Returns\r\n/// * `Ok(())` se il ruolo è permesso\r\n/// * `Err(AppError)` se il ruolo non è tra quelli permessi\r\n#[instrument(skip(metadata))]\r\npub fn require_role(\r\n    metadata: \u0026UserChatMetadata,\r\n    allowed_roles: \u0026[UserRole],\r\n) -\u003e Result\u003c(), AppError\u003e {\r\n    debug!(\"Checking role requirements for user {} in chat {}\", metadata.user_id, metadata.chat_id);\r\n    let user_role = metadata\r\n        .user_role\r\n        .as_ref()\r\n        .ok_or_else(|| {\r\n            warn!(\"User role not found in metadata for user {}\", metadata.user_id);\r\n            AppError::forbidden(\"User role not found in metadata\")\r\n        })?;\r\n\r\n    if !allowed_roles.contains(user_role) {\r\n        warn!(\r\n            \"User {} has insufficient role {:?}, required one of: {:?}\",\r\n            metadata.user_id, user_role, allowed_roles\r\n        );\r\n        return Err(AppError::forbidden(\"Insufficient role\").with_details(format!(\r\n            \"This action requires one of the following roles: {:?}\",\r\n            allowed_roles\r\n        )));\r\n    }\r\n\r\n    info!(\"Role check passed for user {} with role {:?}\", metadata.user_id, user_role);\r\n    Ok(())\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","config.rs"],"content":"use dotenv::dotenv;\r\nuse std::env;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct Config {\r\n    pub database_url: String,\r\n    pub jwt_secret: String,\r\n    pub server_host: String,\r\n    pub server_port: u16,\r\n    pub max_connections: u32,\r\n    pub connection_lifetime_secs: u64,\r\n    pub app_env: String,\r\n    pub log_level: String,\r\n}\r\n\r\nimpl Config {\r\n    /// Carica la configurazione dalle variabili d'ambiente\r\n    /// Chiama dotenv() automaticamente\r\n    pub fn from_env() -\u003e Result\u003cSelf, String\u003e {\r\n        dotenv().ok();\r\n\r\n        let database_url = env::var(\"DATABASE_URL\")\r\n            .map_err(|_| \"DATABASE_URL must be set in .env file\".to_string())?;\r\n\r\n        let jwt_secret = env::var(\"JWT_SECRET\").unwrap_or_else(|_| {\r\n            eprintln!(\"WARNING: JWT_SECRET not set, using default (not secure for production!)\");\r\n            \"un segreto meno bello\".to_string()\r\n        });\r\n\r\n        let server_host = env::var(\"SERVER_HOST\").unwrap_or_else(|_| \"127.0.0.1\".to_string());\r\n\r\n        let server_port = env::var(\"SERVER_PORT\")\r\n            .unwrap_or_else(|_| \"3000\".to_string())\r\n            .parse::\u003cu16\u003e()\r\n            .map_err(|_| \"Invalid SERVER_PORT: must be a number between 0-65535\".to_string())?;\r\n\r\n        let max_connections = env::var(\"MAX_DB_CONNECTIONS\")\r\n            .unwrap_or_else(|_| \"1000\".to_string())\r\n            .parse::\u003cu32\u003e()\r\n            .map_err(|_| \"Invalid MAX_DB_CONNECTIONS: must be a positive number\".to_string())?;\r\n\r\n        let connection_lifetime_secs = env::var(\"DB_CONNECTION_LIFETIME_SECS\")\r\n            .unwrap_or_else(|_| \"1\".to_string())\r\n            .parse::\u003cu64\u003e()\r\n            .map_err(|_| {\r\n                \"Invalid DB_CONNECTION_LIFETIME_SECS: must be a positive number\".to_string()\r\n            })?;\r\n\r\n        let app_env = env::var(\"APP_ENV\").unwrap_or_else(|_| \"development\".to_string());\r\n\r\n        let log_level = env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\r\n\r\n        Ok(Config {\r\n            database_url,\r\n            jwt_secret,\r\n            server_host,\r\n            server_port,\r\n            max_connections,\r\n            connection_lifetime_secs,\r\n            app_env,\r\n            log_level,\r\n        })\r\n    }\r\n\r\n    /// Stampa la configurazione (nascondendo i segreti)\r\n    pub fn print_info(\u0026self) {\r\n        println!(\"   Server Configuration:\");\r\n        println!(\"   Environment: {}\", self.app_env);\r\n        println!(\"   Log Level: {}\", self.log_level);\r\n        println!(\r\n            \"   Server Address: {}:{}\",\r\n            self.server_host, self.server_port\r\n        );\r\n        println!(\"   Database: {}\", Self::mask_url(\u0026self.database_url));\r\n        println!(\"   Max DB Connections: {}\", self.max_connections);\r\n        println!(\"   Connection Lifetime: {}s\", self.connection_lifetime_secs);\r\n        println!(\r\n            \"   JWT Secret: {}\",\r\n            if self.jwt_secret == \"un segreto meno bello\" {\r\n                \"   USING DEFAULT (INSECURE!)\"\r\n            } else {\r\n                \"✓ Custom secret configured\"\r\n            }\r\n        );\r\n    }\r\n\r\n    /// Maschera l'URL del database per il logging\r\n    fn mask_url(url: \u0026str) -\u003e String {\r\n        if let Some(at_pos) = url.find('@') {\r\n            if let Some(scheme_end) = url.find(\"://\") {\r\n                let scheme = \u0026url[..scheme_end + 3];\r\n                let after_at = \u0026url[at_pos..];\r\n                return format!(\"{}***{}\", scheme, after_at);\r\n            }\r\n        }\r\n        \"***\".to_string()\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","error.rs"],"content":"use axum::{http::StatusCode, response::IntoResponse, Json};\r\nuse serde::Serialize;\r\n\r\n#[derive(Serialize)]\r\nstruct ErrorResponse {\r\n    error: \u0026'static str,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    details: Option\u003cString\u003e,\r\n}\r\n\r\npub struct AppError {\r\n    status: StatusCode,\r\n    message: \u0026'static str,\r\n    details: Option\u003cString\u003e,\r\n}\r\n\r\nimpl AppError {\r\n    pub fn new(status: StatusCode, message: \u0026'static str) -\u003e Self {\r\n        Self {\r\n            status,\r\n            message,\r\n            details: None,\r\n        }\r\n    }\r\n\r\n    pub fn with_details(mut self, details: impl Into\u003cString\u003e) -\u003e Self {\r\n        self.details = Some(details.into());\r\n        self\r\n    }\r\n\r\n    // Common error constructors\r\n    pub fn not_found(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::NOT_FOUND, message)\r\n    }\r\n\r\n    pub fn bad_request(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::BAD_REQUEST, message)\r\n    }\r\n\r\n    pub fn unauthorized(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::UNAUTHORIZED, message)\r\n    }\r\n\r\n    pub fn forbidden(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::FORBIDDEN, message)\r\n    }\r\n\r\n    pub fn conflict(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::CONFLICT, message)\r\n    }\r\n\r\n    pub fn internal_server_error(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::INTERNAL_SERVER_ERROR, message)\r\n    }\r\n\r\n    pub fn service_unavailable(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::SERVICE_UNAVAILABLE, message)\r\n    }\r\n}\r\n\r\nimpl From\u003csqlx::Error\u003e for AppError {\r\n    fn from(err: sqlx::Error) -\u003e Self {\r\n        match err {\r\n            sqlx::Error::RowNotFound =\u003e Self::not_found(\"Resource not found\"),\r\n\r\n            sqlx::Error::Database(_) =\u003e Self::bad_request(\"Database error\"),\r\n\r\n            sqlx::Error::PoolTimedOut | sqlx::Error::PoolClosed =\u003e {\r\n                Self::service_unavailable(\"Database unavailable\")\r\n            }\r\n\r\n            _ =\u003e Self::internal_server_error(\"Internal server error\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003caxum::Error\u003e for AppError {\r\n    fn from(err: axum::Error) -\u003e Self {\r\n        Self::internal_server_error(\"Internal server error\").with_details(err.to_string())\r\n    }\r\n}\r\n\r\nimpl From\u003cvalidator::ValidationErrors\u003e for AppError {\r\n    fn from(err: validator::ValidationErrors) -\u003e Self {\r\n        Self::bad_request(\"Validation error\").with_details(err.to_string())\r\n    }\r\n}\r\n\r\nimpl IntoResponse for AppError {\r\n    fn into_response(self) -\u003e axum::response::Response {\r\n        let body = Json(ErrorResponse {\r\n            error: self.message,\r\n            details: self.details,\r\n        });\r\n        (self.status, body).into_response()\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","mod.rs"],"content":"//! Core Module - Componenti infrastrutturali dell'applicazione\r\n//!\r\n//! Questo modulo contiene tutti i componenti \"core\" dell'applicazione:\r\n//! - Autenticazione e JWT\r\n//! - Configurazione\r\n//! - Gestione errori\r\n//! - Stato applicazione\r\n\r\npub mod auth;\r\npub mod config;\r\npub mod error;\r\npub mod state;\r\n\r\n// Re-exports per facilitare l'import\r\npub use auth::{authentication_middleware, chat_membership_middleware, encode_jwt, require_role};\r\npub use config::Config;\r\npub use error::AppError;\r\npub use state::AppState;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","state.rs"],"content":"//! Application State - Stato globale dell'applicazione\r\n//!\r\n//! Contiene tutti i repository, configurazioni e stato condiviso\r\n//! necessario per gestire l'applicazione.\r\n\r\nuse crate::repositories::{\r\n    ChatRepository, InvitationRepository, MessageRepository, UserChatMetadataRepository,\r\n    UserRepository,\r\n};\r\nuse crate::ws::chatmap::ChatMap;\r\nuse crate::ws::usermap::UserMap;\r\nuse sqlx::MySqlPool;\r\n\r\n/// Stato globale dell'applicazione condiviso tra tutte le route e middleware\r\npub struct AppState {\r\n    /// Repository per la gestione degli utenti\r\n    pub user: UserRepository,\r\n\r\n    /// Repository per la gestione delle chat\r\n    pub chat: ChatRepository,\r\n\r\n    /// Repository per la gestione dei messaggi\r\n    pub msg: MessageRepository,\r\n\r\n    /// Repository per la gestione degli inviti\r\n    pub invitation: InvitationRepository,\r\n\r\n    /// Repository per la gestione dei metadati utente-chat\r\n    pub meta: UserChatMetadataRepository,\r\n\r\n    /// Secret key per JWT token\r\n    pub jwt_secret: String,\r\n\r\n    /// Mappa concorrente degli utenti online con i loro canali WebSocket\r\n    /// Key: user_id, Value: Sender per inviare messaggi al WebSocket dell'utente\r\n    pub users_online: UserMap,\r\n\r\n    /// Struttura di gestione delle chat con almeno un utente online\r\n    pub chats_online: ChatMap,\r\n}\r\n\r\nimpl AppState {\r\n    /// Crea una nuova istanza di AppState inizializzando tutti i repository\r\n    /// con il pool di connessioni fornito e la JWT secret.\r\n    ///\r\n    /// # Arguments\r\n    /// * `pool` - Pool di connessioni MySQL condiviso\r\n    /// * `jwt_secret` - Chiave segreta per la firma dei token JWT\r\n    ///\r\n    /// # Returns\r\n    /// Nuova istanza di AppState con tutti i repository inizializzati\r\n    pub fn new(pool: MySqlPool, jwt_secret: String) -\u003e Self {\r\n        Self {\r\n            user: UserRepository::new(pool.clone()),\r\n            chat: ChatRepository::new(pool.clone()),\r\n            msg: MessageRepository::new(pool.clone()),\r\n            invitation: InvitationRepository::new(pool.clone()),\r\n            meta: UserChatMetadataRepository::new(pool),\r\n            jwt_secret,\r\n            users_online: UserMap::new(),\r\n            chats_online: ChatMap::new(),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","chat.rs"],"content":"//! Chat DTOs - Data Transfer Objects per chat\r\n\r\nuse crate::entities::{Chat, ChatType};\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct ChatDTO {\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub title: Option\u003cString\u003e,\r\n    pub description: Option\u003cString\u003e,\r\n    pub chat_type: Option\u003cChatType\u003e,\r\n    pub user_list: Option\u003cVec\u003ci32\u003e\u003e, // lista user_id per chat private/gruppo\r\n}\r\n\r\nimpl From\u003cChat\u003e for ChatDTO {\r\n    fn from(value: Chat) -\u003e Self {\r\n        Self {\r\n            chat_id: Some(value.chat_id),\r\n            title: value.title,\r\n            description: value.description,\r\n            chat_type: Some(value.chat_type),\r\n            user_list: None, // da popolare manualmente se necessario\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare una nuova chat (senza chat_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateChatDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 100,\r\n        message = \"Chat title must be between 1 and 100 characters\"\r\n    ))]\r\n    pub title: Option\u003cString\u003e,\r\n\r\n    #[validate(length(max = 500, message = \"Chat description must not exceed 500 characters\"))]\r\n    pub description: Option\u003cString\u003e,\r\n\r\n    pub chat_type: ChatType,\r\n}\r\n\r\n/// DTO per aggiornare una chat (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateChatDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 100,\r\n        message = \"Chat title must be between 1 and 100 characters\"\r\n    ))]\r\n    pub title: Option\u003cString\u003e,\r\n\r\n    #[validate(length(max = 500, message = \"Chat description must not exceed 500 characters\"))]\r\n    pub description: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","invitation.rs"],"content":"//! Invitation DTOs - Data Transfer Objects per inviti\r\n\r\nuse crate::entities::{Invitation, InvitationStatus};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct InvitationDTO {\r\n    pub invite_id: Option\u003ci32\u003e,\r\n    pub target_chat_id: Option\u003ci32\u003e,\r\n    pub invited_id: Option\u003ci32\u003e,\r\n    pub invitee_id: Option\u003ci32\u003e,\r\n    pub state: Option\u003cInvitationStatus\u003e,\r\n    pub created_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n\r\nimpl From\u003cInvitation\u003e for InvitationDTO {\r\n    fn from(value: Invitation) -\u003e Self {\r\n        Self {\r\n            invite_id: Some(value.invite_id),\r\n            target_chat_id: Some(value.target_chat_id),\r\n            invited_id: Some(value.invited_id),\r\n            invitee_id: Some(value.invitee_id),\r\n            state: Some(value.state),\r\n            created_at: Some(value.created_at),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo invito (senza invite_id, state e created_at)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct CreateInvitationDTO {\r\n    pub target_chat_id: i32,\r\n    pub invited_id: i32,\r\n    pub invitee_id: i32,\r\n}\r\n\r\n/// DTO per aggiornare un invito (solo lo stato è modificabile)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UpdateInvitationDTO {\r\n    pub state: Option\u003cInvitationStatus\u003e,\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","message.rs"],"content":"//! Message DTOs - Data Transfer Objects per messaggi\r\n\r\nuse crate::entities::{Message, MessageType};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct MessageDTO {\r\n    pub message_id: Option\u003ci32\u003e,\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub sender_id: Option\u003ci32\u003e,\r\n    pub content: Option\u003cString\u003e,\r\n    pub message_type: Option\u003cMessageType\u003e,\r\n    pub created_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n\r\nimpl From\u003cMessage\u003e for MessageDTO {\r\n    fn from(value: Message) -\u003e Self {\r\n        Self {\r\n            message_id: Some(value.message_id),\r\n            chat_id: Some(value.chat_id),\r\n            sender_id: Some(value.sender_id),\r\n            content: Some(value.content),\r\n            message_type: Some(value.message_type),\r\n            created_at: Some(value.created_at),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo messaggio (senza message_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateMessageDTO {\r\n    pub chat_id: i32,\r\n    pub sender_id: i32,\r\n\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 5000,\r\n        message = \"Message content must be between 1 and 5000 characters\"\r\n    ))]\r\n    pub content: String,\r\n    pub message_type: MessageType,\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n}\r\n\r\nimpl TryFrom\u003cMessageDTO\u003e for CreateMessageDTO {\r\n    type Error = \u0026'static str;\r\n    fn try_from(value: MessageDTO) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Ok(Self {\r\n            chat_id: value.chat_id.ok_or(\"chat_id missing\")?,\r\n            sender_id: value.sender_id.ok_or(\"sender_id missing\")?,\r\n            content: value.content.ok_or(\"content missing\")?,\r\n            message_type: value.message_type.ok_or(\"message_type missing\")?,\r\n            created_at: value.created_at.unwrap_or_else(Utc::now),\r\n        })\r\n    }\r\n}\r\n\r\n/// DTO per aggiornare un messaggio (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateMessageDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 5000,\r\n        message = \"Message content must be between 1 and 5000 characters\"\r\n    ))]\r\n    pub content: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","mod.rs"],"content":"//! DTOs module - Data Transfer Objects\r\n//!\r\n//! Questo modulo contiene tutti i DTOs usati per la comunicazione client-server.\r\n//! I DTOs separano la rappresentazione esterna (API) dalla rappresentazione interna (entities).\r\n\r\npub mod chat;\r\npub mod invitation;\r\npub mod message;\r\npub mod query;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-exports per mantenere la compatibilità con il codice esistente\r\npub use chat::{ChatDTO, CreateChatDTO, UpdateChatDTO};\r\npub use invitation::{CreateInvitationDTO, InvitationDTO, UpdateInvitationDTO};\r\npub use message::{CreateMessageDTO, MessageDTO, UpdateMessageDTO};\r\npub use query::{MessagesQuery, UserSearchQuery};\r\npub use user::{CreateUserDTO, UpdateUserDTO, UserDTO};\r\npub use user_chat_metadata::{CreateUserChatMetadataDTO, UpdateUserChatMetadataDTO, UserInChatDTO};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","query.rs"],"content":"//! Query DTOs - Data Transfer Objects per query di ricerca\r\n\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// DTO per query parameters di ricerca utenti\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserSearchQuery {\r\n    pub search: String,\r\n}\r\n\r\n/// DTO per query parameters di paginazione messaggi\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct MessagesQuery {\r\n    #[serde(default)]\r\n    pub before_date: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","user.rs"],"content":"//! User DTOs - Data Transfer Objects per utenti\r\n\r\nuse crate::entities::User;\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n// struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserDTO {\r\n    pub id: Option\u003ci32\u003e,\r\n    pub username: Option\u003cString\u003e,\r\n}\r\n\r\nimpl From\u003cUser\u003e for UserDTO {\r\n    fn from(value: User) -\u003e Self {\r\n        Self {\r\n            id: Some(value.user_id),\r\n            username: Some(value.username)\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo utente (senza user_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateUserDTO {\r\n    #[validate(length(\r\n        min = 3,\r\n        max = 50,\r\n        message = \"Username must be between 3 and 50 characters\"\r\n    ))]\r\n    #[validate(custom(\r\n        function = \"validate_username\",\r\n        message = \"Username can only contain letters, numbers, and underscores\"\r\n    ))]\r\n    pub username: String,\r\n\r\n    #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\r\n    #[validate(custom(\r\n        function = \"validate_password_strength\",\r\n        message = \"Password must contain at least one uppercase, one lowercase, and one number\"\r\n    ))]\r\n    pub password: String,\r\n}\r\n\r\nfn validate_username(username: \u0026str) -\u003e Result\u003c(), validator::ValidationError\u003e {\r\n    lazy_static::lazy_static! {\r\n        static ref USERNAME_REGEX: regex::Regex = regex::Regex::new(r\"^[a-zA-Z0-9_]+$\").unwrap();\r\n    }\r\n\r\n    // Bloccare \"Deleted User\" - username riservato dal sistema\r\n    if username == \"Deleted User\" {\r\n        return Err(validator::ValidationError::new(\"reserved_username\"));\r\n    }\r\n\r\n    if USERNAME_REGEX.is_match(username) {\r\n        Ok(())\r\n    } else {\r\n        Err(validator::ValidationError::new(\"invalid_username\"))\r\n    }\r\n}\r\n\r\nfn validate_password_strength(password: \u0026str) -\u003e Result\u003c(), validator::ValidationError\u003e {\r\n    let has_uppercase = password.chars().any(|c| c.is_uppercase());\r\n    let has_lowercase = password.chars().any(|c| c.is_lowercase());\r\n    let has_digit = password.chars().any(|c| c.is_numeric());\r\n\r\n    if has_uppercase \u0026\u0026 has_lowercase \u0026\u0026 has_digit {\r\n        Ok(())\r\n    } else {\r\n        Err(validator::ValidationError::new(\"weak_password\"))\r\n    }\r\n}\r\n\r\n/// DTO per aggiornare un utente esistente (solo password modificabile)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateUserDTO {\r\n    #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\r\n    #[validate(custom(\r\n        function = \"validate_password_strength\",\r\n        message = \"Password must contain at least one uppercase, one lowercase, and one number\"\r\n    ))]\r\n    pub password: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","user_chat_metadata.rs"],"content":"//! UserChatMetadata DTOs - Data Transfer Objects per metadati utente-chat\r\n\r\nuse crate::entities::{UserChatMetadata, UserRole};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Struct per restituire info più semplici per le liste\r\n/// (nome = UserInChatDTO nell'originale, rappresenta un utente in una chat con il suo ruolo)\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserInChatDTO {\r\n    pub user_id: Option\u003ci32\u003e,\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub username: Option\u003cString\u003e,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n    //pub messages_visible_from: Option\u003cDateTime\u003cUtc\u003e\u003e,         // superfluo per il tipo di operazione\r\n    //pub messages_received_until: Option\u003cDateTime\u003cUtc\u003e\u003e,       // superfluo per il tipo di operazione\r\n}\r\n\r\nimpl From\u003cUserChatMetadata\u003e for UserInChatDTO {\r\n    fn from(value: UserChatMetadata) -\u003e Self {\r\n        Self {\r\n            user_id: Some(value.user_id),\r\n            chat_id: Some(value.chat_id),\r\n            username: None, // Non è presente in UserChatMetadata, va popolato altrove\r\n            user_role: value.user_role,\r\n            member_since: Some(value.member_since),\r\n            // messages_visible_from: Some(value.messages_visible_from),\r\n            // messages_received_until: Some(value.messages_received_until),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare nuovi metadati utente-chat (senza member_since, messages_visible_from, messages_received_until - gestiti dal DB)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct CreateUserChatMetadataDTO {\r\n    pub user_id: i32,\r\n    pub chat_id: i32,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: DateTime\u003cUtc\u003e,\r\n    pub messages_visible_from: DateTime\u003cUtc\u003e,\r\n    pub messages_received_until: DateTime\u003cUtc\u003e,\r\n}\r\n\r\n/// DTO per aggiornare metadati utente-chat (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UpdateUserChatMetadataDTO {\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub messages_visible_from: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n    pub messages_received_until: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","chat.rs"],"content":"//! Chat entity - Entità chat\r\n\r\nuse super::enums::ChatType;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Chat {\r\n    pub chat_id: i32,\r\n    pub title: Option\u003cString\u003e,\r\n    pub description: Option\u003cString\u003e,\r\n    pub chat_type: ChatType,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","enums.rs"],"content":"//! Enumerazioni - Tipi enumerati utilizzati nelle entità\r\n\r\nuse serde::{Deserialize, Serialize};\r\n\r\n// ********************* ENUMERAZIONI UTILI **********************//\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, sqlx::Type)]\r\n#[sqlx(type_name = \"message_type\", rename_all = \"UPPERCASE\")]\r\npub enum MessageType {\r\n    UserMessage,\r\n    SystemMessage,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, sqlx::Type)]\r\n#[sqlx(type_name = \"user_role\", rename_all = \"UPPERCASE\")]\r\npub enum UserRole {\r\n    Owner,\r\n    Admin,\r\n    Member,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, sqlx::Type, PartialEq)]\r\n#[sqlx(type_name = \"invitation_status\", rename_all = \"UPPERCASE\")]\r\npub enum InvitationStatus {\r\n    Pending,\r\n    Accepted,\r\n    Rejected,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, sqlx::Type, PartialEq)]\r\n#[sqlx(type_name = \"chat_type\", rename_all = \"UPPERCASE\")]\r\npub enum ChatType {\r\n    Group,\r\n    Private,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","invitation.rs"],"content":"//! Invitation entity - Entità invito\r\n\r\nuse super::enums::InvitationStatus;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Invitation {\r\n    pub invite_id: i32,\r\n    pub target_chat_id: i32, // chat ( di gruppo ) in cui si viene invitati\r\n    pub invited_id: i32,     // utente invitato\r\n    pub invitee_id: i32,     // utente che invita\r\n    pub state: InvitationStatus,\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","message.rs"],"content":"//! Message entity - Entità messaggio\r\n\r\nuse super::enums::MessageType;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Message {\r\n    pub message_id: i32,\r\n    pub chat_id: i32,\r\n    pub sender_id: i32, // rendere opzionale per i messaggi di sistema visto che il sistema non ha tipo ?\r\n    pub content: String,\r\n    // il server si aspetta una stringa litterale iso8601 che viene parsata in oggetto DateTime di tipo UTC\r\n    // la conversione viene fatta in automatico da serde, la feature è stata abilitata\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n    // campo rinominato rispetto a uml perchè type è una parola protetta\r\n    pub message_type: MessageType,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","mod.rs"],"content":"//! Entities module - Entità del dominio applicativo\r\n//!\r\n//! Questo modulo contiene tutte le entità (models) che rappresentano i dati persistiti nel database.\r\n//! Ogni entity corrisponde a una tabella nel database.\r\n\r\npub mod chat;\r\npub mod enums;\r\npub mod invitation;\r\npub mod message;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-exports per facilitare l'import\r\npub use chat::Chat;\r\npub use enums::{ChatType, InvitationStatus, MessageType, UserRole};\r\npub use invitation::Invitation;\r\npub use message::Message;\r\npub use user::User;\r\npub use user_chat_metadata::UserChatMetadata;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","user.rs"],"content":"//! User entity - Entità utente con metodi per gestione password\r\n\r\nuse bcrypt::{DEFAULT_COST, hash, verify};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct User {\r\n    /* se vogliamo rinominare campi usiamo la macro\r\n     * #[serde(rename = \"userId\")]\r\n     */\r\n    pub user_id: i32,\r\n    pub username: String,\r\n    pub password: String,\r\n}\r\n\r\nimpl User {\r\n    /// Verify if target_password matches the stored hashed password\r\n    pub fn verify_password(\u0026self, target_password: \u0026String) -\u003e bool {\r\n        verify(target_password, \u0026self.password).unwrap_or(false)\r\n    }\r\n\r\n    /// Hash a password using bcrypt with default cost\r\n    pub fn hash_password(password: \u0026str) -\u003e Result\u003cString, bcrypt::BcryptError\u003e {\r\n        let hash = hash(password, DEFAULT_COST)?;\r\n        Ok(hash)\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","user_chat_metadata.rs"],"content":"//! UserChatMetadata entity - Entità metadata utente-chat\r\n\r\nuse super::enums::UserRole;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UserChatMetadata {\r\n    pub user_id: i32,\r\n    pub chat_id: i32,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: DateTime\u003cUtc\u003e,\r\n    // sostituisce deliver_from con un nome più esplicativo\r\n    // sostituito al posto dell'id del messaggio il datetime, è da intendersi come\r\n    // \"visualizza i messaggi da questo istante in poi, questo istante ESCLUSO\"\r\n    pub messages_visible_from: DateTime\u003cUtc\u003e,\r\n    // sostituisce last delivered con un nume più esplicativo\r\n    // sostituito al posto dell'id del messaggio il date time, è da intendersi come\r\n    // \"ho ricevuto i messaggi fino a questo istante, istante INCLUSO\"\r\n    pub messages_received_until: DateTime\u003cUtc\u003e,\r\n    //per ora non esludo i due campi dalla deserializzazione\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","main.rs"],"content":"mod core;\nmod dtos;\nmod entities;\nmod repositories;\nmod services;\nmod ws;\n\nuse crate::core::{AppState, Config, authentication_middleware, chat_membership_middleware};\nuse crate::services::*;\nuse crate::ws::ws_handler;\nuse axum::{\n    Router, middleware,\n    routing::{any, delete, get, patch, post},\n};\nuse sqlx::mysql::MySqlPoolOptions;\nuse std::{net::SocketAddr, sync::Arc, time::Duration};\nuse tokio::net::TcpListener;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n/// Configura le routes di autenticazione (login, register)\nfn configure_auth_routes() -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/login\", post(login_user))\n        .route(\"/register\", post(register_user))\n}\n\n/// Configura le routes per la gestione degli utenti\nfn configure_user_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/\", get(search_user_with_username))\n        .route(\"/{user_id}\", get(get_user_by_id))\n        .route(\"/me\", delete(delete_my_account))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ))\n}\n\n/// Configura le routes per la gestione delle chat\nfn configure_chat_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    // Rotte che NON richiedono membership (solo autenticazione)\n    let public_routes = Router::new()\n        .route(\"/\", get(list_chats).post(create_chat))\n        .layer(middleware::from_fn_with_state(\n            state.clone(),\n            authentication_middleware,\n        ));\n\n    // Rotte che richiedono membership (autenticazione + membership middleware)\n    let member_routes = Router::new()\n        .route(\"/{chat_id}/messages\", get(get_chat_messages))\n        .route(\"/{chat_id}/members\", get(list_chat_members))\n        .route(\"/{chat_id}/invite/{user_id}\", post(invite_to_chat))\n        .route(\n            \"/{chat_id}/members/{user_id}/role\",\n            patch(update_member_role),\n        )\n        .route(\"/{chat_id}/transfer_ownership\", patch(transfer_ownership))\n        .route(\"/{chat_id}/members/{user_id}\", delete(remove_member))\n        .route(\"/{chat_id}/leave\", post(leave_chat))\n        .layer(middleware::from_fn_with_state(\n            state.clone(),\n            chat_membership_middleware,\n        ))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ));\n\n    public_routes.merge(member_routes)\n}\n\n/// Configura le routes per la gestione degli inviti\nfn configure_invitation_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/pending\", get(list_pending_invitations))\n        .route(\"/{invite_id}/{action}\", post(respond_to_invitation))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ))\n}\n\n#[tokio::main]\nasync fn main() {\n    // Carica la configurazione dalle variabili d'ambiente\n    let config = Config::from_env().expect(\"Failed to load configuration. Check your .env file.\");\n\n    // Inizializza il tracing subscriber con il log level dalla configurazione\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| format!(\"server={},tower_http=debug\", config.log_level).into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    // Stampa info sulla configurazione\n    config.print_info();\n\n    // Builder per configurare le connessioni al database con retry automatico\n    let pool_options = MySqlPoolOptions::new()\n        .max_connections(config.max_connections)\n        .max_lifetime(Duration::from_secs(config.connection_lifetime_secs))\n        .acquire_timeout(Duration::from_secs(2)) // Timeout per l'acquisizione di una connessione dal pool\n        .test_before_acquire(true);\n\n    // Avvio il pool di connessioni al database con retry automatico ogni 2 secondi\n    println!(\"Attempting to connect to database...\");\n    let connection_pool = loop {\n        match pool_options.clone().connect(\u0026config.database_url).await {\n            Ok(pool) =\u003e {\n                println!(\"✓ Database connection established successfully!\");\n                break pool;\n            }\n            Err(e) =\u003e {\n                eprintln!(\"✗ Failed to connect to database: {}\", e);\n                eprintln!(\"  Retrying in 2 seconds...\");\n                tokio::time::sleep(Duration::from_secs(2)).await;\n            }\n        }\n    };\n\n    // Creiamo lo stato dell'applicazione con i repository e la configurazione\n    let state = Arc::new(AppState::new(connection_pool, config.jwt_secret.clone()));\n\n    // Definizione indirizzo del server\n    let addr = SocketAddr::from((\n        config\n            .server_host\n            .parse::\u003cstd::net::IpAddr\u003e()\n            .expect(\"Invalid SERVER_HOST format\"),\n        config.server_port,\n    ));\n    println!(\"Server listening on http://{}\", addr);\n\n    // Creazione del listener TCP per ascoltare l'indirizzo\n    let listener = TcpListener::bind(addr)\n        .await\n        .expect(\"Unable to start TCP listener.\");\n\n    // Costruzione del router principale con tutte le routes\n    let app = Router::new()\n        .route(\"/\", get(root))\n        .nest(\"/auth\", configure_auth_routes())\n        .nest(\"/users\", configure_user_routes(state.clone()))\n        .nest(\"/chats\", configure_chat_routes(state.clone()))\n        .nest(\"/invitations\", configure_invitation_routes(state.clone()))\n        .route(\n            \"/ws\",\n            any(ws_handler).layer(middleware::from_fn_with_state(\n                state.clone(),\n                authentication_middleware,\n            )),\n        )\n        .with_state(state);\n\n    // Avvia il server\n    axum::serve(listener, app)\n        .await\n        .expect(\"Error serving the application\");\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","chat.rs"],"content":"//! ChatRepository - Repository per la gestione delle chat\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateChatDTO, UpdateChatDTO};\r\nuse crate::entities::{Chat, ChatType};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// CHAT REPOSITORY\r\npub struct ChatRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl ChatRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get private chat between two users (if exists)\r\n    /// Optimized query: uses GROUP BY + HAVING instead of multiple JOINs for better performance\r\n    #[instrument(skip(self), fields(user1 = %user1_id, user2 = %user2_id))]\r\n    pub async fn get_private_chat_between_users(\r\n        \u0026self,\r\n        user1_id: \u0026i32,\r\n        user2_id: \u0026i32,\r\n    ) -\u003e Result\u003cOption\u003cChat\u003e, Error\u003e {\r\n        debug!(\"Finding private chat between two users\");\r\n        let chat = sqlx::query_as!(\r\n            Chat,\r\n            r#\"\r\n            SELECT \r\n                c.chat_id,\r\n                c.title,\r\n                c.description,\r\n                c.chat_type as \"chat_type: ChatType\"\r\n            FROM chats c\r\n            INNER JOIN userchatmetadata ucm ON c.chat_id = ucm.chat_id\r\n            WHERE c.chat_type = 'PRIVATE' \r\n            AND ucm.user_id IN (?, ?)\r\n            GROUP BY c.chat_id, c.title, c.description, c.chat_type\r\n            HAVING COUNT(DISTINCT ucm.user_id) = 2\r\n            \"#,\r\n            user1_id,\r\n            user2_id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if chat.is_some() {\r\n            info!(\"Private chat found\");\r\n        } else {\r\n            debug!(\"No private chat found\");\r\n        }\r\n\r\n        Ok(chat)\r\n    }\r\n}\r\n\r\nimpl Create\u003cChat, CreateChatDTO\u003e for ChatRepository {\r\n    #[instrument(skip(self, data), fields(chat_type = ?data.chat_type))]\r\n    async fn create(\u0026self, data: \u0026CreateChatDTO) -\u003e Result\u003cChat, Error\u003e {\r\n        debug!(\"Creating new chat\");\r\n        // Insert chat using MySQL syntax\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO chats (title, description, chat_type) \r\n            VALUES (?, ?, ?)\r\n            \"#,\r\n            data.title,\r\n            data.description,\r\n            data.chat_type\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Chat created with id {}\", new_id);\r\n\r\n        // Return the created chat with the new ID\r\n        Ok(Chat {\r\n            chat_id: new_id,\r\n            title: data.title.clone(),\r\n            description: data.description.clone(),\r\n            chat_type: data.chat_type.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cChat, i32\u003e for ChatRepository {\r\n    #[instrument(skip(self), fields(chat_id = %id))]\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cChat\u003e, Error\u003e {\r\n        debug!(\"Reading chat by id\");\r\n        let chat = sqlx::query_as!(\r\n            Chat,\r\n            r#\"\r\n            SELECT \r\n                chat_id,\r\n                title,\r\n                description,\r\n                chat_type as \"chat_type: ChatType\"\r\n            FROM chats \r\n            WHERE chat_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if chat.is_some() {\r\n            debug!(\"Chat found\");\r\n        } else {\r\n            debug!(\"Chat not found\");\r\n        }\r\n\r\n        Ok(chat)\r\n    }\r\n}\r\n\r\nimpl Update\u003cChat, UpdateChatDTO, i32\u003e for ChatRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %id))]\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateChatDTO) -\u003e Result\u003cChat, Error\u003e {\r\n        debug!(\"Updating chat\");\r\n        // First, get the current chat to ensure it exists\r\n        let current_chat = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no fields to update, return current chat\r\n        if data.title.is_none() \u0026\u0026 data.description.is_none() {\r\n            debug!(\"No fields to update, returning current chat\");\r\n            return Ok(current_chat);\r\n        }\r\n\r\n        // Build dynamic UPDATE query using QueryBuilder (idiomatic SQLx way)\r\n        let mut query_builder = sqlx::QueryBuilder::new(\"UPDATE chats SET \");\r\n\r\n        let mut separated = query_builder.separated(\", \");\r\n        if let Some(ref title) = data.title {\r\n            separated.push(\"title = \");\r\n            separated.push_bind_unseparated(title);\r\n        }\r\n        if let Some(ref description) = data.description {\r\n            separated.push(\"description = \");\r\n            separated.push_bind_unseparated(description);\r\n        }\r\n\r\n        query_builder.push(\" WHERE chat_id = \");\r\n        query_builder.push_bind(id);\r\n\r\n        query_builder.build().execute(\u0026self.connection_pool).await?;\r\n\r\n        info!(\"Chat updated successfully\");\r\n\r\n        // Fetch and return the updated chat\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for ChatRepository {\r\n    #[instrument(skip(self), fields(chat_id = %id))]\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        debug!(\"Deleting chat\");\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        info!(\"Chat deleted successfully\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::entities::ChatType;\r\n    use sqlx::MySqlPool;\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: get_private_chat_between_users */\r\n    /*------------------------------------------- */\r\n\r\n    /// Test: trova una chat privata esistente tra due utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) e Bob (user_id=2) hanno una chat privata (chat_id=2)\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        assert!(result.is_some());\r\n        let chat = result.unwrap();\r\n        assert_eq!(chat.chat_id, 2);\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: l'ordine degli utenti non influisce sul risultato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_order_independent(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca prima con (alice, bob)\r\n        let result1 = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        // Cerca poi con (bob, alice)\r\n        let result2 = repo.get_private_chat_between_users(\u00262, \u00261).await?;\r\n        \r\n        assert!(result1.is_some());\r\n        assert!(result2.is_some());\r\n        assert_eq!(result1.unwrap().chat_id, result2.unwrap().chat_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat quando non esiste tra i due utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) e Charlie (user_id=3) non hanno chat privata\r\n        let result = repo.get_private_chat_between_users(\u00262, \u00263).await?;\r\n        \r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat GROUP quando si cerca PRIVATE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_ignores_group_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) e Bob (user_id=2) sono entrambi nella \"General Chat\" (GROUP)\r\n        // Ma questo metodo deve trovare solo chat PRIVATE\r\n        // Hanno già una chat privata (chat_id=2), quindi il test verifica che restituisca quella\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        assert!(result.is_some());\r\n        let chat = result.unwrap();\r\n        // Deve essere la chat privata, non la group chat\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        assert_eq!(chat.chat_id, 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat con utenti inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_invalid_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca con user_id inesistenti\r\n        let result = repo.get_private_chat_between_users(\u0026999, \u00261000).await?;\r\n        \r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: gestione con stesso user_id per entrambi i parametri\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_same_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca chat privata tra lo stesso utente\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00261).await?;\r\n        \r\n        // Non dovrebbe trovare nulla (una chat privata richiede 2 utenti distinti)\r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina userchatmetadata\r\n    /// La chat rimane ma non è più trovabile con questo metodo\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Verifica che la chat esista\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        \r\n        // Elimina Alice (user_id=1)\r\n        // CASCADE DELETE eliminerà le righe in userchatmetadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // Ora la chat non dovrebbe più essere trovabile\r\n        // perché manca un record in userchatmetadata\r\n        let result_after = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_after.is_none());\r\n        \r\n        // Verifica che la chat esista ancora nel database\r\n        let chat_exists = sqlx::query!(\r\n            \"SELECT chat_id FROM chats WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_optional(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert!(chat_exists.is_some(), \"La chat dovrebbe esistere ancora\");\r\n        \r\n        // Verifica che userchatmetadata sia stato eliminato per user_id=1\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            1\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 0, \"Metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat elimina userchatmetadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Verifica che la chat esista\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        let chat_id = result_before.unwrap().chat_id;\r\n        \r\n        // Elimina la chat\r\n        // CASCADE DELETE eliminerà anche userchatmetadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // La chat non dovrebbe più essere trovabile\r\n        let result_after = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_after.is_none());\r\n        \r\n        // Verifica che userchatmetadata sia stato eliminato\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 0, \"Metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: verifica che l'eliminazione di un solo utente\r\n    /// non rompa la query (dovrebbe restituire None)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_partial_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Elimina Bob (user_id=2) - CASCADE elimina il suo userchatmetadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // La chat privata ha ora solo 1 membro invece di 2\r\n        // La query HAVING COUNT(DISTINCT ucm.user_id) = 2 non dovrebbe trovare nulla\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result.is_none());\r\n        \r\n        // Verifica che rimanga solo 1 record in userchatmetadata per questa chat\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 1, \"Dovrebbe rimanere solo 1 membro\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: verifica comportamento con chat che ha messaggi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_with_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Inserisci un messaggio nella chat privata\r\n        sqlx::query!(\r\n            \"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, ?, ?, NOW())\",\r\n            2, 1, \"Test message\"\r\n        )\r\n        .execute(\u0026repo.connection_pool)\r\n        .await?;\r\n        \r\n        // La chat dovrebbe essere trovabile normalmente\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        \r\n        // Elimina la chat - CASCADE elimina anche i messaggi\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 2)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi siano stati eliminati\r\n        let message_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(message_count.count, 0, \"Messaggi dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures sono stati caricati in ordine: users, chats\r\n        // Implementa qui i tuoi test per ChatRepository\r\n        Ok(())\r\n    }\r\n\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: create                         */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_create_group_chat_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per una chat di gruppo\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Test Group Chat\".to_string()),\r\n            description: Some(\"A test group chat for testing\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        // Testa la creazione\r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che la chat sia stata creata correttamente\r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, Some(\"Test Group Chat\".to_string()));\r\n        assert_eq!(created_chat.description, Some(\"A test group chat for testing\".to_string()));\r\n        assert_eq!(created_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_private_chat_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per una chat privata (senza title/description)\r\n        let create_dto = CreateChatDTO {\r\n            title: None,\r\n            description: None,\r\n            chat_type: ChatType::Private,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, None);\r\n        assert_eq!(created_chat.description, None);\r\n        assert_eq!(created_chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_chat_with_minimal_data(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea chat con solo il campo obbligatorio\r\n        let create_dto = CreateChatDTO {\r\n            title: None,\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, None);\r\n        assert_eq!(created_chat.description, None);\r\n        assert_eq!(created_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: read                           */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_read_existing_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat direttamente nel database\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Test Chat', 'Test Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la lettura\r\n        let chat = repo.read(\u00261).await?;\r\n        \r\n        assert!(chat.is_some());\r\n        let chat = chat.unwrap();\r\n        assert_eq!(chat.chat_id, 1);\r\n        assert_eq!(chat.title, Some(\"Test Chat\".to_string()));\r\n        assert_eq!(chat.description, Some(\"Test Description\".to_string()));\r\n        assert_eq!(chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la lettura di una chat inesistente\r\n        let chat = repo.read(\u0026999).await?;\r\n        \r\n        assert!(chat.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat privata\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, NULL, NULL, 'PRIVATE')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        let chat = repo.read(\u00261).await?;\r\n        \r\n        assert!(chat.is_some());\r\n        let chat = chat.unwrap();\r\n        assert_eq!(chat.chat_id, 1);\r\n        assert_eq!(chat.title, None);\r\n        assert_eq!(chat.description, None);\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n/*------------------------------------------- */\r\n/* Unit tests: update                         */\r\n/*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_update_chat_title_and_description(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per l'aggiornamento\r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"Updated Title\".to_string()),        \r\n            description: Some(\"Updated Description\".to_string()), \r\n        };\r\n        \r\n        // Testa l'aggiornamento\r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.chat_id, 1);\r\n        assert_eq!(updated_chat.title, Some(\"Updated Title\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Updated Description\".to_string()));\r\n        assert_eq!(updated_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_chat_only_title(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Aggiorna solo il titolo\r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"New Title Only\".to_string()),  \r\n            description: None, // Non aggiornare la description\r\n        };\r\n        \r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.title, Some(\"New Title Only\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Original Description\".to_string())); // Rimasta invariata\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_chat_with_no_changes(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // DTO senza cambiamenti (tutti i campi None)\r\n        let update_dto = UpdateChatDTO {\r\n            title: None,\r\n            description: None,\r\n        };\r\n        \r\n        // Dovrebbe restituire la chat invariata\r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.title, Some(\"Original Title\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Original Description\".to_string()));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"New Title\".to_string()),  \r\n            description: None,\r\n        };\r\n        \r\n        // Testa l'aggiornamento di una chat inesistente\r\n        let result = repo.update(\u0026999, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err());\r\n        match result {\r\n            Err(sqlx::Error::RowNotFound) =\u003e {}, // Comportamento atteso\r\n            _ =\u003e panic!(\"Expected RowNotFound error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n    /*------------------------------------------- */\r\n    /* Unit tests: delete                         */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_delete_existing_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Chat to Delete', 'Will be deleted', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Verifica che la chat esista prima della cancellazione\r\n        let chat_before = repo.read(\u00261).await?;\r\n        assert!(chat_before.is_some());\r\n        \r\n        // Testa la cancellazione\r\n        let result = repo.delete(\u00261).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che la chat sia stata eliminata\r\n        let chat_after = repo.read(\u00261).await?;\r\n        assert!(chat_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_delete_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la cancellazione di una chat inesistente\r\n        // Dovrebbe completarsi senza errori (operazione idempotente)\r\n        let result = repo.delete(\u0026999).await;\r\n        assert!(result.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests:  cascade deletions behavior    */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea utenti e chat\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat tramite CRUD\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Test Chat\".to_string()),\r\n            description: Some(\"Test Description\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi metadata utenti alla chat\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW()), (2, ?, NOW(), NOW(), 'MEMBER', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata esistano\r\n        let metadata_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(metadata_count_before.count, 2);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sui metadata)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che i metadata siano stati eliminati automaticamente\r\n        let metadata_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(metadata_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Chat with Messages\".to_string()),\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi metadata utente\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi messaggi alla chat\r\n        sqlx::query!(\"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, 1, 'Message 1', NOW()), (?, 1, 'Message 2', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi esistano\r\n        let message_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(message_count_before.count, 2);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sui messaggi)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che i messaggi siano stati eliminati automaticamente\r\n        let message_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(message_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Chat with Invitations\".to_string()),\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi inviti per la chat\r\n        sqlx::query!(\"INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) VALUES (?, 2, 1, 'PENDING', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti esistano\r\n        let invitation_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(invitation_count_before.count, 1);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sugli inviti)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che gli inviti siano stati eliminati automaticamente\r\n        let invitation_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(invitation_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_complete_chat_lifecycle(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Test completo del ciclo di vita di una chat con tutti gli elementi collegati\r\n        \r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Complete Lifecycle Chat\".to_string()),\r\n            description: Some(\"Testing complete CASCADE behavior\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi membri\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW()), (2, ?, NOW(), NOW(), 'MEMBER', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi messaggi\r\n        sqlx::query!(\"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, 1, 'Hello!', NOW()), (?, 2, 'Hi there!', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi inviti\r\n        sqlx::query!(\"INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) VALUES (?, 3, 1, 'PENDING', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutto esista\r\n        let metadata_count = sqlx::query!(\"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let message_count = sqlx::query!(\"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let invitation_count = sqlx::query!(\"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        \r\n        assert_eq!(metadata_count, 2);\r\n        assert_eq!(message_count, 2);\r\n        assert_eq!(invitation_count, 1);\r\n        \r\n        // Elimina la chat\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che tutto sia stato eliminato (CASCADE)\r\n        let metadata_after = sqlx::query!(\"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let message_after = sqlx::query!(\"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let invitation_after = sqlx::query!(\"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        \r\n        assert_eq!(metadata_after, 0);\r\n        assert_eq!(message_after, 0);\r\n        assert_eq!(invitation_after, 0);\r\n        \r\n        // Verifica che gli utenti esistano ancora\r\n        let user_count = sqlx::query!(\"SELECT COUNT(*) as count FROM users\").fetch_one(\u0026pool).await?.count;\r\n        assert_eq!(user_count, 3, \"Gli utenti non dovrebbero essere eliminati\");\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":22,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":93,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":123,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":8,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","invitation.rs"],"content":"//! InvitationRepository - Repository per la gestione degli inviti\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateInvitationDTO, UpdateInvitationDTO};\r\nuse crate::entities::{Invitation, InvitationStatus};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n//INVITATION REPOSITORY\r\npub struct InvitationRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl InvitationRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get all pending invitations for a specific user\r\n    pub async fn find_many_by_user_id(\u0026self, user_id: \u0026i32) -\u003e Result\u003cVec\u003cInvitation\u003e, Error\u003e {\r\n        let invitations = sqlx::query_as!(\r\n            Invitation,\r\n            r#\"\r\n            SELECT \r\n                invite_id,\r\n                target_chat_id,\r\n                invited_id,\r\n                invitee_id,\r\n                state as \"state: InvitationStatus\",\r\n                created_at\r\n            FROM invitations \r\n            WHERE invited_id = ? AND state = 'PENDING'\r\n            \"#,\r\n            user_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(invitations)\r\n    }\r\n\r\n    /// Check if there's already a pending invitation for user to chat\r\n    pub async fn has_pending_invitation(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003cbool, Error\u003e {\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ? AND target_chat_id = ? AND state = 'PENDING'\",\r\n            user_id,\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(count.count \u003e 0)\r\n    }\r\n}\r\n\r\nimpl Create\u003cInvitation, CreateInvitationDTO\u003e for InvitationRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %data.target_chat_id, inviter = %data.invitee_id, invited = %data.invited_id))]\r\n    async fn create(\u0026self, data: \u0026CreateInvitationDTO) -\u003e Result\u003cInvitation, Error\u003e {\r\n        debug!(\"Creating new invitation\");\r\n        // Insert invitation using MySQL syntax\r\n        // state e created_at vengono gestiti dal database (default: Pending e NOW())\r\n        let now = chrono::Utc::now();\r\n        let state = InvitationStatus::Pending; // default state\r\n\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) \r\n            VALUES (?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.target_chat_id,\r\n            data.invited_id,\r\n            data.invitee_id,\r\n            state,\r\n            now\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Invitation created with id {}\", new_id);\r\n\r\n        // Return the created invitation with the new ID\r\n        Ok(Invitation {\r\n            invite_id: new_id,\r\n            target_chat_id: data.target_chat_id,\r\n            invited_id: data.invited_id,\r\n            invitee_id: data.invitee_id,\r\n            state,\r\n            created_at: now,\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cInvitation, i32\u003e for InvitationRepository {\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cInvitation\u003e, Error\u003e {\r\n        let invitation = sqlx::query_as!(\r\n            Invitation,\r\n            r#\"\r\n            SELECT \r\n                invite_id,\r\n                target_chat_id,\r\n                invited_id,\r\n                invitee_id,\r\n                state as \"state: InvitationStatus\",\r\n                created_at\r\n            FROM invitations \r\n            WHERE invite_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(invitation)\r\n    }\r\n}\r\n\r\nimpl Update\u003cInvitation, UpdateInvitationDTO, i32\u003e for InvitationRepository {\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateInvitationDTO) -\u003e Result\u003cInvitation, Error\u003e {\r\n        // First, get the current invitation to ensure it exists\r\n        let current_invitation = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no state to update, return current invitation\r\n        if data.state.is_none() {\r\n            return Ok(current_invitation);\r\n        }\r\n\r\n        // Update invitation state\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = ? WHERE invite_id = ?\",\r\n            data.state,\r\n            id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Fetch and return the updated invitation\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for InvitationRepository {\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\"DELETE FROM invitations WHERE invite_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use sqlx::MySqlPool;\r\n\r\n    // ============================================================================\r\n    // Tests for find_many_by_user_id method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che find_many_by_user_id restituisca solo inviti PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_returns_only_pending(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Assumendo che il fixture \"invitations\" contenga inviti con invited_id = 1\r\n        let user_id = 1;\r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        // Verifica che tutti gli inviti restituiti siano PENDING\r\n        for inv in \u0026invitations {\r\n            assert_eq!(inv.state, InvitationStatus::Pending);\r\n            assert_eq!(inv.invited_id, user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che restituisca un array vuoto per utenti senza inviti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_returns_empty_when_no_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 999; // utente senza inviti\r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        assert!(invitations.is_empty());\r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che gli inviti ACCEPTED/REJECTED siano esclusi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_excludes_non_pending_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Crea un invito PENDING\r\n        let user_id = 2;\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: user_id,\r\n            invitee_id: 3,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito PENDING venga restituito\r\n        let invitations_pending = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(invitations_pending.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Aggiorna lo stato ad ACCEPTED\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = 'ACCEPTED' WHERE invite_id = ?\",\r\n            created.invite_id\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Verifica che l'invito ACCEPTED non venga restituito\r\n        let invitations_after = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminata una chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_chat_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let chat_id = 1;\r\n        \r\n        // Crea un invito per la chat\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 2,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito esista\r\n        let invitations_before = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(invitations_before.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Elimina la chat (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti per quella chat siano stati eliminati in cascata\r\n        let invitations_after = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.target_chat_id == chat_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitante (invitee)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_inviter_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let inviter_id = 1;\r\n        let invited_id = 2;\r\n        \r\n        // Crea un invito dove user 1 invita user 2\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id,\r\n            invitee_id: inviter_id,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito esista\r\n        let invitations_before = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(invitations_before.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Elimina l'utente invitante (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti da quell'utente siano stati eliminati in cascata\r\n        let invitations_after = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.invitee_id == inviter_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitato (invited)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_invited_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let inviter_id = 1;\r\n        let invited_id = 2;\r\n        \r\n        // Crea un invito dove user 1 invita user 2\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id,\r\n            invitee_id: inviter_id,\r\n        };\r\n        \r\n        repo.create(\u0026invite).await?;\r\n        \r\n        // Elimina l'utente invitato (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", invited_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti per quell'utente siano stati eliminati in cascata\r\n        // (non dovrebbe esserci nessun invito restituito)\r\n        let invitations_after = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(invitations_after.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che restituisca correttamente più inviti PENDING per lo stesso utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_multiple_pending_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let mut created_ids = Vec::new();\r\n        \r\n        // Crea più inviti PENDING per lo stesso utente\r\n        for chat_id in 2..=3 {\r\n            let invite = CreateInvitationDTO {\r\n                target_chat_id: chat_id,\r\n                invited_id: user_id,\r\n                invitee_id: 1,\r\n            };\r\n            let created = repo.create(\u0026invite).await?;\r\n            created_ids.push(created.invite_id);\r\n        }\r\n        \r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        // Verifica che tutti gli inviti creati siano restituiti\r\n        for created_id in \u0026created_ids {\r\n            assert!(invitations.iter().any(|inv| inv.invite_id == *created_id));\r\n        }\r\n        \r\n        // Verifica che tutti siano PENDING e per l'utente corretto\r\n        for inv in invitations.iter().filter(|inv| created_ids.contains(\u0026inv.invite_id)) {\r\n            assert_eq!(inv.invited_id, user_id);\r\n            assert_eq!(inv.state, InvitationStatus::Pending);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for has_pending_invitation method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che has_pending_invitation ritorni true per inviti PENDING esistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_returns_true_when_pending_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Bob invita Charlie (user_id=3) al General Chat (chat_id=1) con stato PENDING\r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(has_pending, \"Expected pending invitation to exist\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation ritorni false quando non ci sono inviti PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_returns_false_when_no_pending(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // User e chat che non hanno inviti PENDING\r\n        let user_id = 1;\r\n        let chat_id = 2;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation escluda inviti ACCEPTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_excludes_accepted_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Alice invita Bob (user_id=2) al Dev Team (chat_id=3) con stato ACCEPTED\r\n        let user_id = 2;\r\n        let chat_id = 3;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation (only ACCEPTED exists)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation escluda inviti REJECTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_excludes_rejected_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Charlie invita Alice (user_id=1) al General Chat (chat_id=1) con stato REJECTED\r\n        let user_id = 1;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation (only REJECTED exists)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation passi da true a false quando l'invito viene accettato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_changes_after_state_update(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        let chat_id = 1;\r\n        \r\n        // Crea un invito PENDING\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che sia PENDING\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation after creation\");\r\n        \r\n        // Aggiorna lo stato ad ACCEPTED\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = 'ACCEPTED' WHERE invite_id = ?\",\r\n            created.invite_id\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Verifica che non ci sia più un invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after acceptance\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminata la chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_chat_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before chat deletion\");\r\n        \r\n        // Elimina la chat (CASCADE DELETE dovrebbe eliminare gli inviti)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after chat deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_invited_user_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before user deletion\");\r\n        \r\n        // Elimina l'utente invitato (CASCADE DELETE dovrebbe eliminare gli inviti)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after user deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitante\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_inviter_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invited_user_id = 3;\r\n        let inviter_user_id = 2; // Bob è l'invitante\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture (Bob invita Charlie)\r\n        let has_pending_before = repo.has_pending_invitation(\u0026invited_user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before inviter deletion\");\r\n        \r\n        // Elimina l'utente invitante (CASCADE DELETE dovrebbe eliminare gli inviti creati da lui)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026invited_user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after inviter deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation gestisca correttamente utenti inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_has_pending_invitation_with_nonexistent_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_user_id = 9999;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026nonexistent_user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation gestisca correttamente chat inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_has_pending_invitation_with_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let nonexistent_chat_id = 9999;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026nonexistent_chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation for nonexistent chat\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation rispetti la UNIQUE constraint (non duplicati PENDING)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_unique_constraint(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING\r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending);\r\n        \r\n        // Prova a creare un duplicato (dovrebbe fallire per la UNIQUE constraint)\r\n        let duplicate_invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_invite).await;\r\n        \r\n        // Verifica che l'inserimento fallisca\r\n        assert!(result.is_err(), \"Expected duplicate invitation to fail\");\r\n        \r\n        // Verifica che ci sia ancora solo un invito PENDING\r\n        let still_has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(still_has_pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for CREATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che create crei correttamente un nuovo invito PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        \r\n        // Verifica che l'invito sia stato creato con i dati corretti\r\n        assert!(created.invite_id \u003e 0);\r\n        assert_eq!(created.target_chat_id, invite_dto.target_chat_id);\r\n        assert_eq!(created.invited_id, invite_dto.invited_id);\r\n        assert_eq!(created.invitee_id, invite_dto.invitee_id);\r\n        assert_eq!(created.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 9999, // chat inesistente\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid chat_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per invited_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_invited_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 9999, // utente inesistente\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid invited_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per invitee_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_inviter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 9999, // utente inesistente\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid invitee_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create rispetti la UNIQUE constraint (target_chat_id, invited_id, state)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_create_invitation_fails_with_duplicate(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture esiste già: (target_chat_id=1, invited_id=3, state=PENDING)\r\n        let duplicate_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 3,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected unique constraint violation for duplicate invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possano creare più inviti PENDING per lo stesso utente in chat diverse\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_multiple_invitations_different_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        \r\n        // Crea inviti per chat diverse\r\n        for chat_id in 1..=3 {\r\n            let invite_dto = CreateInvitationDTO {\r\n                target_chat_id: chat_id,\r\n                invited_id: user_id,\r\n                invitee_id: 1,\r\n            };\r\n            \r\n            let created = repo.create(\u0026invite_dto).await?;\r\n            assert_eq!(created.target_chat_id, chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possa creare un invito PENDING se già esiste un invito con stato diverso\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_create_invitation_different_state_allowed(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste (1, 3, PENDING)\r\n        // Prima aggiorna lo stato esistente a REJECTED\r\n        sqlx::query!(\"UPDATE invitations SET state = 'REJECTED' WHERE target_chat_id = 1 AND invited_id = 3\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Ora possiamo creare un nuovo PENDING (perché la UNIQUE è su chat+user+state)\r\n        let new_invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 3,\r\n            invitee_id: 2,\r\n        };\r\n        \r\n        let created = repo.create(\u0026new_invite).await?;\r\n        assert_eq!(created.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for READ method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che read restituisca un invito esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id = 1\r\n        let invite_id = 1;\r\n        \r\n        let invitation = repo.read(\u0026invite_id).await?;\r\n        \r\n        assert!(invitation.is_some());\r\n        let inv = invitation.unwrap();\r\n        assert_eq!(inv.invite_id, invite_id);\r\n        assert_eq!(inv.target_chat_id, 1);\r\n        assert_eq!(inv.invited_id, 3);\r\n        assert_eq!(inv.invitee_id, 2);\r\n        assert_eq!(inv.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca None per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let invitation = repo.read(\u0026nonexistent_id).await?;\r\n        \r\n        assert!(invitation.is_none(), \"Expected None for nonexistent invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca l'invito dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        \r\n        let read_invitation = repo.read(\u0026created.invite_id).await?;\r\n        \r\n        assert!(read_invitation.is_some());\r\n        let inv = read_invitation.unwrap();\r\n        assert_eq!(inv.invite_id, created.invite_id);\r\n        assert_eq!(inv.target_chat_id, created.target_chat_id);\r\n        assert_eq!(inv.invited_id, created.invited_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminata la chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_chat_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è associato a chat_id=1\r\n        let invite_id = 1;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la chat (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 1\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminato l'utente invitato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_invited_user_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 ha invited_id=3\r\n        let invite_id = 1;\r\n        let invited_user_id = 3;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina l'utente invitato (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", invited_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminato l'utente invitante\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_inviter_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 ha invitee_id=2 (Bob)\r\n        let invite_id = 1;\r\n        let inviter_user_id = 2;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina l'utente invitante (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for UPDATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che update aggiorni correttamente lo stato da PENDING ad ACCEPTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_to_accepted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.invite_id, invite_id);\r\n        assert_eq!(updated.state, InvitationStatus::Accepted);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update aggiorni correttamente lo stato da PENDING a REJECTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_to_rejected(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Rejected),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.invite_id, invite_id);\r\n        assert_eq!(updated.state, InvitationStatus::Rejected);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update con state=None non modifichi l'invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_with_no_state_change(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let before = repo.read(\u0026invite_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        // Lo stato dovrebbe rimanere invariato\r\n        assert_eq!(updated.state, before.state);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update fallisca per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let result = repo.update(\u0026nonexistent_id, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected error for nonexistent invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa cambiare stato più volte\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        // Prima update: PENDING -\u003e ACCEPTED\r\n        let update1 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        let result1 = repo.update(\u0026invite_id, \u0026update1).await?;\r\n        assert_eq!(result1.state, InvitationStatus::Accepted);\r\n        \r\n        // Seconda update: ACCEPTED -\u003e REJECTED\r\n        let update2 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Rejected),\r\n        };\r\n        let result2 = repo.update(\u0026invite_id, \u0026update2).await?;\r\n        assert_eq!(result2.state, InvitationStatus::Rejected);\r\n        \r\n        // Terza update: REJECTED -\u003e PENDING\r\n        let update3 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Pending),\r\n        };\r\n        let result3 = repo.update(\u0026invite_id, \u0026update3).await?;\r\n        assert_eq!(result3.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update preservi gli altri campi dell'invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1\r\n        let invite_id = 1;\r\n        \r\n        let before = repo.read(\u0026invite_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        // Verifica che solo lo stato sia cambiato\r\n        assert_eq!(updated.invite_id, before.invite_id);\r\n        assert_eq!(updated.target_chat_id, before.target_chat_id);\r\n        assert_eq!(updated.invited_id, before.invited_id);\r\n        assert_eq!(updated.invitee_id, before.invitee_id);\r\n        assert_eq!(updated.created_at, before.created_at);\r\n        assert_ne!(updated.state, before.state); // solo lo stato cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for DELETE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che delete elimini correttamente un invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 esiste\r\n        let invite_id = 1;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina\r\n        repo.delete(\u0026invite_id).await?;\r\n        \r\n        // Verifica che non esista più\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non fallisca per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        // DELETE su id inesistente non dovrebbe dare errore (affected rows = 0 è ok)\r\n        let result = repo.delete(\u0026nonexistent_id).await;\r\n        \r\n        assert!(result.is_ok(), \"Expected delete to succeed even for nonexistent id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete rimuova l'invito dal database\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_removes_from_database(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo invito\r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 2,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        let invite_id = created.invite_id;\r\n        \r\n        // Verifica che esista\r\n        assert!(repo.read(\u0026invite_id).await?.is_some());\r\n        \r\n        // Elimina\r\n        repo.delete(\u0026invite_id).await?;\r\n        \r\n        // Verifica che non sia più recuperabile\r\n        assert!(repo.read(\u0026invite_id).await?.is_none());\r\n        \r\n        // Verifica che non compaia in has_pending_invitation\r\n        let has_pending = repo.has_pending_invitation(\u0026invite_dto.invited_id, \u0026invite_dto.target_chat_id).await?;\r\n        assert!(!has_pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete multipli funzionino correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_multiple_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esistono inviti 1, 2, 3\r\n        let invite_ids = vec![1, 2, 3];\r\n        \r\n        // Elimina tutti\r\n        for id in \u0026invite_ids {\r\n            repo.delete(id).await?;\r\n        }\r\n        \r\n        // Verifica che nessuno esista più\r\n        for id in \u0026invite_ids {\r\n            let result = repo.read(id).await?;\r\n            assert!(result.is_none(), \"Expected invitation {} to be deleted\", id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non influenzi altri inviti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_does_not_affect_other_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esistono inviti 1, 2, 3\r\n        let delete_id = 1;\r\n        let keep_ids = vec![2, 3];\r\n        \r\n        // Elimina solo l'invito 1\r\n        repo.delete(\u0026delete_id).await?;\r\n        \r\n        // Verifica che 1 sia eliminato\r\n        assert!(repo.read(\u0026delete_id).await?.is_none());\r\n        \r\n        // Verifica che 2 e 3 esistano ancora\r\n        for id in keep_ids {\r\n            let result = repo.read(\u0026id).await?;\r\n            assert!(result.is_some(), \"Expected invitation {} to still exist\", id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possa ricreare un invito dopo delete\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_recreate_after_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste (1, 3, PENDING)\r\n        let original = repo.read(\u00261).await?.unwrap();\r\n        \r\n        // Elimina\r\n        repo.delete(\u00261).await?;\r\n        \r\n        // Ricrea con gli stessi dati\r\n        let recreate_dto = CreateInvitationDTO {\r\n            target_chat_id: original.target_chat_id,\r\n            invited_id: original.invited_id,\r\n            invitee_id: original.invitee_id,\r\n        };\r\n        \r\n        let recreated = repo.create(\u0026recreate_dto).await?;\r\n        \r\n        // Verifica che sia stato ricreato (avrà un ID diverso)\r\n        assert_ne!(recreated.invite_id, original.invite_id);\r\n        assert_eq!(recreated.target_chat_id, original.target_chat_id);\r\n        assert_eq!(recreated.invited_id, original.invited_id);\r\n        assert_eq!(recreated.invitee_id, original.invitee_id);\r\n        assert_eq!(recreated.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":20,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":21,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":22,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":34,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":37,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":39,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":43,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":48,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":50,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":51,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":53,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":54,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":56,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":62,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":101,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":102,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":103,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":115,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":117,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":118,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":120,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":125,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":127,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":128,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":129,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":130,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":133,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":138,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":140,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":143,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":144,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":152,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":153,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":154,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":155,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":157,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":41,"coverable":41},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","message.rs"],"content":"//! MessageRepository - Repository per la gestione dei messaggi\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateMessageDTO, UpdateMessageDTO};\r\nuse crate::entities::{Message, MessageType};\r\nuse chrono::{DateTime, Utc};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// MESSAGE REPO\r\npub struct MessageRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl MessageRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get paginated messages for a chat within a time range\r\n    ///\r\n    /// Retrieves messages visible to a user based on their `messages_visible_from` timestamp\r\n    /// (from UserChatMetadata). Supports both:\r\n    /// - Loading recent messages (when `before_date` is None): gets the most recent `limit` messages\r\n    /// - Loading older messages (when `before_date` is Some): gets `limit` messages before that date\r\n    ///\r\n    /// # Arguments\r\n    /// * `chat_id` - The chat ID\r\n    /// * `messages_visible_from` - Lower bound timestamp (from UserChatMetadata.messages_visible_from)\r\n    /// * `before_date` - Optional upper bound timestamp for pagination\r\n    /// * `limit` - Maximum number of messages to return\r\n    ///\r\n    /// # Returns\r\n    /// Messages ordered from newest to oldest (DESC), limited to `limit` count\r\n    pub async fn find_many_paginated(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n        messages_visible_from: \u0026DateTime\u003cUtc\u003e,\r\n        before_date: Option\u003c\u0026DateTime\u003cUtc\u003e\u003e,\r\n        limit: i64,\r\n    ) -\u003e Result\u003cVec\u003cMessage\u003e, Error\u003e {\r\n        let messages = if let Some(before) = before_date {\r\n            sqlx::query_as!(\r\n                Message,\r\n                r#\"\r\n                SELECT \r\n                    message_id, \r\n                    chat_id, \r\n                    sender_id, \r\n                    content, \r\n                    created_at,\r\n                    message_type as \"message_type: MessageType\"\r\n                FROM messages \r\n                WHERE chat_id = ? \r\n                  AND created_at \u003e= ? \r\n                  AND created_at \u003c ?\r\n                ORDER BY created_at DESC\r\n                LIMIT ?\r\n                \"#,\r\n                chat_id,\r\n                messages_visible_from,\r\n                before,\r\n                limit\r\n            )\r\n            .fetch_all(\u0026self.connection_pool)\r\n            .await?\r\n        } else {\r\n            sqlx::query_as!(\r\n                Message,\r\n                r#\"\r\n                SELECT \r\n                    message_id, \r\n                    chat_id, \r\n                    sender_id, \r\n                    content, \r\n                    created_at,\r\n                    message_type as \"message_type: MessageType\"\r\n                FROM messages \r\n                WHERE chat_id = ? \r\n                  AND created_at \u003e= ?\r\n                ORDER BY created_at DESC\r\n                LIMIT ?\r\n                \"#,\r\n                chat_id,\r\n                messages_visible_from,\r\n                limit\r\n            )\r\n            .fetch_all(\u0026self.connection_pool)\r\n            .await?\r\n        };\r\n\r\n        Ok(messages)\r\n    }\r\n}\r\n\r\nimpl Create\u003cMessage, CreateMessageDTO\u003e for MessageRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %data.chat_id, sender_id = %data.sender_id))]\r\n    async fn create(\u0026self, data: \u0026CreateMessageDTO) -\u003e Result\u003cMessage, Error\u003e {\r\n        debug!(\"Creating new message\");\r\n        // Insert message using MySQL syntax\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO messages (chat_id, sender_id, content, message_type, created_at) \r\n            VALUES (?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.chat_id,\r\n            data.sender_id,\r\n            data.content,\r\n            \u0026data.message_type,\r\n            data.created_at\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Message created with id {}\", new_id);\r\n\r\n        // Return the created message with the new ID\r\n        Ok(Message {\r\n            message_id: new_id,\r\n            chat_id: data.chat_id,\r\n            sender_id: data.sender_id,\r\n            content: data.content.clone(),\r\n            created_at: data.created_at,\r\n            message_type: data.message_type.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cMessage, i32\u003e for MessageRepository {\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cMessage\u003e, Error\u003e {\r\n        let message = sqlx::query_as!(\r\n            Message,\r\n            r#\"\r\n            SELECT \r\n                message_id, \r\n                chat_id, \r\n                sender_id, \r\n                content, \r\n                created_at,\r\n                message_type as \"message_type: MessageType\"\r\n            FROM messages \r\n            WHERE message_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(message)\r\n    }\r\n}\r\n\r\nimpl Update\u003cMessage, UpdateMessageDTO, i32\u003e for MessageRepository {\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateMessageDTO) -\u003e Result\u003cMessage, Error\u003e {\r\n        // First, get the current message to ensure it exists\r\n        let current_message = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no content to update, return current message\r\n        if data.content.is_none() {\r\n            return Ok(current_message);\r\n        }\r\n\r\n        // Update message content\r\n        sqlx::query!(\r\n            \"UPDATE messages SET content = ? WHERE message_id = ?\",\r\n            data.content,\r\n            id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Fetch and return the updated message\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for MessageRepository {\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\"DELETE FROM messages WHERE message_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    \r\n    use sqlx::{MySqlPool};\r\n    use super::*;\r\n    use crate::entities::MessageType;\r\n    use chrono::{DateTime, Utc};\r\n\r\n    //------------------------------\r\n    //TESTS FOR find_many_paginated\r\n    //------------------------------\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_recent_messages_without_before_date(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa il recupero dei messaggi più recenti senza before_date\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap(); // Epoca Unix per vedere tutti i messaggi\r\n        let limit = 10;\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, limit).await?;\r\n        \r\n        // Verifica che ci siano 3 messaggi\r\n        assert_eq!(messages.len(), 3);\r\n        \r\n        // Verifica che tutti appartengano alla chat corretta\r\n        for message in \u0026messages {\r\n            assert_eq!(message.chat_id, 1);\r\n        }\r\n        \r\n        // Verifica l'ordinamento (il più recente dovrebbe essere primo)\r\n        // I messaggi con created_at più alta dovrebbero venire prima\r\n        if messages.len() \u003e= 2 {\r\n            assert!(messages[0].created_at \u003e= messages[1].created_at);\r\n        }\r\n        if messages.len() \u003e= 3 {\r\n            assert!(messages[1].created_at \u003e= messages[2].created_at);\r\n        }\r\n        \r\n        // Il messaggio più recente dovrebbe essere quello con INTERVAL 8 MINUTE (più vicino a NOW)\r\n        assert_eq!(messages[0].content, \"Good morning!\");\r\n        assert_eq!(messages[1].content, \"Hi Alice!\");\r\n        assert_eq!(messages[2].content, \"Hello everyone!\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_before_date_filter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Prima recupera tutti i messaggi per ottenere una data di riferimento\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let all_messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Usa la data del secondo messaggio più recente come before_date\r\n        let before_date = all_messages[1].created_at;\r\n        \r\n        let filtered_messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, Some(\u0026before_date), 10).await?;\r\n        \r\n        // Dovrebbe restituire solo i messaggi precedenti alla data specificata (1 messaggio)\r\n        assert_eq!(filtered_messages.len(), 1);\r\n        assert_eq!(filtered_messages[0].content, \"Hello everyone!\");\r\n        \r\n        // Verifica che tutti i messaggi siano anteriori alla data specificata\r\n        for message in \u0026filtered_messages {\r\n            assert!(message.created_at \u003c before_date);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_messages_visible_from_filter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Usa una data nel futuro come messages_visible_from per simulare un utente\r\n        // che è entrato nella chat dopo tutti i messaggi\r\n        let future_date = Utc::now() + chrono::Duration::minutes(5);\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026future_date, None, 10).await?;\r\n        \r\n        // Non dovrebbe restituire alcun messaggio perché tutti sono precedenti a messages_visible_from\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_limit(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let limit = 2; // Limita a 2 messaggi\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, limit).await?;\r\n        \r\n        // Verifica che il limite sia rispettato\r\n        assert_eq!(messages.len(), 2);\r\n        \r\n        // Verifica che siano i 2 più recenti\r\n        assert_eq!(messages[0].content, \"Good morning!\");\r\n        assert_eq!(messages[1].content, \"Hi Alice!\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let nonexistent_chat_id = 999;\r\n        \r\n        let messages = repo.find_many_paginated(\u0026nonexistent_chat_id, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Non dovrebbe restituire alcun messaggio per una chat inesistente\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_empty_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat senza messaggi\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (999, 'Empty Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 999, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        \r\n        let messages = repo.find_many_paginated(\u0026999, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Chat vuota dovrebbe restituire array vuoto\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_message_type_preservation(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Inserisci messaggi di diversi tipi\r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'User message', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 1, 'System message test', 'SYSTEMMESSAGE', NOW() - INTERVAL 5 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        assert_eq!(messages.len(), 2);\r\n        \r\n        // Verifica che ci sia almeno un messaggio di sistema e uno utente\r\n        let system_messages: Vec\u003c_\u003e = messages.iter()\r\n            .filter(|m| m.message_type == MessageType::SystemMessage)\r\n            .collect();\r\n        let user_messages: Vec\u003c_\u003e = messages.iter()\r\n            .filter(|m| m.message_type == MessageType::UserMessage)\r\n            .collect();\r\n        \r\n        assert_eq!(system_messages.len(), 1);\r\n        assert_eq!(user_messages.len(), 1);\r\n        assert_eq!(system_messages[0].content, \"System message test\");\r\n        assert_eq!(user_messages[0].content, \"User message\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_cascade_behavior_on_chat_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (2, 'Test Chat', 'PRIVATE')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 2, NOW(), NOW(), 'OWNER', NOW()), (2, 2, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (4, 2, 1, 'Test message 1', 'USERMESSAGE', NOW() - INTERVAL 5 MINUTE),\r\n            (5, 2, 2, 'Test message 2', 'USERMESSAGE', NOW() - INTERVAL 4 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Clona il pool prima di passarlo al repository\r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Prima verifica che ci siano messaggi per la chat 2\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let messages_before = repo.find_many_paginated(\u00262, \u0026messages_visible_from, None, 10).await?;\r\n        assert_eq!(messages_before.len(), 2);\r\n        \r\n        // Elimina la chat 2\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi siano stati eliminati automaticamente\r\n        let messages_after = repo.find_many_paginated(\u00262, \u0026messages_visible_from, None, 10).await?;\r\n        assert_eq!(messages_after.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_cascade_behavior_on_user_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Alice message', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Bob message', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Charlie message', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new((pool).clone());\r\n        \r\n        // Prima verifica che ci siano messaggi dell'utente 2 \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let all_messages_before = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        let bob_messages_before: Vec\u003c_\u003e = all_messages_before.iter()\r\n            .filter(|m| m.sender_id == 2)\r\n            .collect();\r\n        assert_eq!(bob_messages_before.len(), 1);\r\n        assert_eq!(bob_messages_before[0].content, \"Bob message\");\r\n        \r\n        // Elimina l'utente bob \r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi di bob siano stati eliminati automaticamente\r\n        let all_messages_after = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        let bob_messages_after: Vec\u003c_\u003e = all_messages_after.iter()\r\n            .filter(|m| m.sender_id == 2)\r\n            .collect();\r\n        assert_eq!(bob_messages_after.len(), 0);\r\n        \r\n        // Verifica che gli altri messaggi siano ancora presenti\r\n        assert_eq!(all_messages_after.len(), 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR create\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_create_message_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test necessari\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Crea un DTO per il nuovo messaggio\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Test message content\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        // Testa la creazione\r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che il messaggio sia stato creato correttamente\r\n        assert!(created_message.message_id \u003e 0);\r\n        assert_eq!(created_message.chat_id, create_dto.chat_id);\r\n        assert_eq!(created_message.sender_id, create_dto.sender_id);\r\n        assert_eq!(created_message.content, create_dto.content);\r\n        assert_eq!(created_message.message_type, create_dto.message_type);\r\n        assert_eq!(created_message.created_at, create_dto.created_at);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_system_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'system', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"User joined the chat\".to_string(),\r\n            message_type: MessageType::SystemMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created_message.message_type, MessageType::SystemMessage);\r\n        assert_eq!(created_message.content, \"User joined the chat\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR read\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_read_existing_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Inserisci un messaggio direttamente\r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Test message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la lettura\r\n        let message = repo.read(\u00261).await?;\r\n        \r\n        assert!(message.is_some());\r\n        let message = message.unwrap();\r\n        assert_eq!(message.message_id, 1);\r\n        assert_eq!(message.chat_id, 1);\r\n        assert_eq!(message.sender_id, 1);\r\n        assert_eq!(message.content, \"Test message\");\r\n        assert_eq!(message.message_type, MessageType::UserMessage);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la lettura di un messaggio inesistente\r\n        let message = repo.read(\u0026999).await?;\r\n        \r\n        assert!(message.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    //------------------------------\r\n    //TESTS FOR update\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_update_message_content(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Original message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Crea DTO per l'aggiornamento\r\n        let update_dto = UpdateMessageDTO {\r\n            content: Some(\"Updated message content\".to_string()),\r\n        };\r\n        \r\n        // Testa l'aggiornamento\r\n        let updated_message = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_message.message_id, 1);\r\n        assert_eq!(updated_message.content, \"Updated message content\");\r\n        assert_eq!(updated_message.chat_id, 1);\r\n        assert_eq!(updated_message.sender_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_message_with_none_content(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Original message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // DTO con content = None (nessun aggiornamento)\r\n        let update_dto = UpdateMessageDTO {\r\n            content: None,\r\n        };\r\n        \r\n        // Testa l'aggiornamento con None\r\n        let updated_message = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        // Il messaggio dovrebbe rimanere invariato\r\n        assert_eq!(updated_message.content, \"Original message\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let update_dto = UpdateMessageDTO {\r\n            content: Some(\"New content\".to_string()),\r\n        };\r\n        \r\n        // Testa l'aggiornamento di un messaggio inesistente\r\n        let result = repo.update(\u0026999, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err());\r\n        match result {\r\n            Err(sqlx::Error::RowNotFound) =\u003e {}, // Comportamento atteso\r\n            _ =\u003e panic!(\"Expected RowNotFound error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    //------------------------------\r\n    //TESTS FOR delete\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_delete_existing_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Message to delete', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Verifica che il messaggio esista prima della cancellazione\r\n        let message_before = repo.read(\u00261).await?;\r\n        assert!(message_before.is_some());\r\n        \r\n        // Testa la cancellazione\r\n        let result = repo.delete(\u00261).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che il messaggio sia stato eliminato\r\n        let message_after = repo.read(\u00261).await?;\r\n        assert!(message_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_delete_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la cancellazione di un messaggio inesistente\r\n        // Dovrebbe completarsi senza errori (operazione idempotente)\r\n        let result = repo.delete(\u0026999).await;\r\n        assert!(result.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR cascade deletions behavior\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_behavior_on_chat_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Crea un messaggio tramite CRUD\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Test message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che il messaggio esista\r\n        let message_before = repo.read(\u0026created_message.message_id).await?;\r\n        assert!(message_before.is_some());\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 1\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il messaggio sia stato eliminato automaticamente\r\n        let message_after = repo.read(\u0026created_message.message_id).await?;\r\n        assert!(message_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_behavior_on_user_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Crea messaggi per entrambi gli utenti\r\n        let alice_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Alice message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let bob_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 2,\r\n            content: \"Bob message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let alice_message = repo.create(\u0026alice_dto).await?;\r\n        let bob_message = repo.create(\u0026bob_dto).await?;\r\n        \r\n        // Verifica che entrambi i messaggi esistano\r\n        assert!(repo.read(\u0026alice_message.message_id).await?.is_some());\r\n        assert!(repo.read(\u0026bob_message.message_id).await?.is_some());\r\n        \r\n        // Elimina l'utente Bob (dovrebbe attivare CASCADE DELETE sui suoi messaggi)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il messaggio di Bob sia stato eliminato\r\n        assert!(repo.read(\u0026bob_message.message_id).await?.is_none());\r\n        \r\n        // Verifica che il messaggio di Alice sia ancora presente\r\n        assert!(repo.read(\u0026alice_message.message_id).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_message_with_invalid_foreign_keys(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Tenta di creare un messaggio con chat_id e sender_id inesistenti\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 999, // Chat inesistente\r\n            sender_id: 999, // Utente inesistente\r\n            content: \"Test message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        // Dovrebbe fallire a causa dei vincoli di foreign key\r\n        let result = repo.create(\u0026create_dto).await;\r\n        assert!(result.is_err());\r\n        \r\n        // Verifica che sia un errore di foreign key constraint\r\n        match result {\r\n            Err(sqlx::Error::Database(db_err)) =\u003e {\r\n                // MySQL error code per foreign key constraint violation\r\n                assert!(db_err.message().contains(\"foreign key constraint\") || \r\n                    db_err.message().contains(\"Cannot add or update\"));\r\n            },\r\n            _ =\u003e panic!(\"Expected foreign key constraint error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":35,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":42,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":69,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":85,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":86,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":88,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":89,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":92,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":98,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":133,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":134,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":135,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":147,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":149,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":150,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":152,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":159,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":160,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":165,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":179,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":185,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":186,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":187,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":189,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":45,"coverable":45},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","mod.rs"],"content":"//! Repositories module - Coordinatore per tutti i repository del progetto\r\n//!\r\n//! Questo modulo organizza i repository in sotto-moduli separati per una migliore manutenibilità.\r\n//! Ogni repository gestisce le operazioni di database per una specifica entità.\r\n\r\n// ************************* NOTA IMPORTANTE SU SQLX ************************* //\r\n\r\n/*\r\n   hey tu!\r\n   Leggimi :D\r\n   Ti risparmio un po' di dolore ( non vedere https://docs.rs/sqlx/latest/sqlx/macro.query.html )\r\n   Quando devi fare query con sqlx, ci sono due modi: uno che permette di controllare staticamente\r\n   che la query sia corretta nel senso che lo schema che abbiamo scritto coincida con quello del db\r\n   (ovvero, in fase di compilazione, quella che ci piace perchè vogliamo essere sicuri che vada tutto bene)\r\n   e uno che fa questo check in run-time (che ci fa schifo, quindi evito proprio di parlarne).\r\n   Quindi, come si scrive una query? con la bellissima macro:\r\n   sqlx::query!(\"SELECT id, name FROM users WHERE id = ?\", 1)\r\n   Per evitare di diventare scemi con le maiuscole, si possono scrivere anche in minusolo le keyword\r\n   e si possono scrivere query anche complesse, tipo quelle annidate se serve!\r\n   Ci sarebbe anche un altro modo in realtà di scrivere la query:\r\n   sqlx::query!(\r\n       \"select * from (select (1) as id, 'Herp Derpinson' as name) accounts where id = ?\",\r\n       1i32\r\n   )\r\n   Ovvero inserendo direttamente dentro la stringa il valore, ma non si fam, anche se un valore sappiamo\r\n   Rimanere sempre quello, comunque lo mettiamo con la sintassi che abbiamo visto prima.\r\n   Ovviamente non è finita qui, la query segue il builder pattern con lazy execution -\u003e concateniamo con la dot notation\r\n   le varie operazioni supplementari, tipo: quanti risultati vogliamo ? uno solo, uno o più, almeno uno ...\r\n   ecco le opzioni:\r\n   Number of Rows\tMethod to Call*\tReturns\tNotes\r\n   None†\t        .execute(...).await\t        sqlx::Result\u003cDB::QueryResult\u003e\t            For INSERT/UPDATE/DELETE without RETURNING.\r\n   Zero or One\t    .fetch_optional(...).await\tsqlx::Result\u003cOption\u003c{adhoc struct}\u003e\u003e\t    Extra rows are ignored.\r\n   Exactly One\t    .fetch_one(...).await\t    sqlx::Result\u003c{adhoc struct}\u003e\t            Errors if no rows were returned. Extra rows are ignored. Aggregate queries, use this.\r\n   At Least One\t.fetch(...)\t                impl Stream\u003cItem = sqlx::Result\u003c{adhoc struct}\u003e\u003e\tCall .try_next().await to get each row result.\r\n   Multiple\t    .fetch_all(...)\t            sqlx::Result\u003cVec\u003c{adhoc struct}\u003e\u003e\r\n   abbiamo scritto la query, ma ricordiamoci che è un metodo async quindi dobbiamo concludere con\r\n   await e visto che abbiamo progettato bene le firme, addirittura con await? in modo che l'errore viene propagato al service\r\n   o alla route che poi lo va a gestire restituendo al client l'adeguato codice errore.\r\n   AH! Volevi fosse così semplice! E invece no, perchè si ritorniamo un result, ma questo result deve essere o l'oggetto\r\n   GIA' parsato, oppure l'errore di sqlx :D\r\n\r\n   In questi casi (quindi nella create, update, o nella read) dobbiamo usare al posto di query! -\u003e query_as!\r\n   Questa funzione magica ci fa già il parsing in automatico di quello che ci serve\r\n   Sintassi ( molto simile ) :\r\n   sqlx::query_as!(\r\n       User, // tipo in output\r\n       \"SELECT id, name, email FROM users WHERE id = ?\", //query con placeholder\r\n       1 //valori\r\n   )\r\n   .fetch_one(\u0026pool) //prendi esattamente uno da cosa? dal pool di connessioni della repo!\r\n   .await?;\r\n\r\n   Nota : visto che la compilazione è statica a compile time, se il database non è connesso correttamente o il server\r\n   che contiene mysql non è attivo, il riusltaot è che query_as! e query! danno errore\r\n\r\n\r\n*/\r\n\r\n// ************************* MODULI REPOSITORY ************************* //\r\n\r\n// Dichiarazione dei sotto-moduli\r\npub mod chat;\r\npub mod invitation;\r\npub mod message;\r\npub mod traits;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-esportazione dei trait per facilitare l'import\r\npub use traits::{Create, Delete, Read, Update};\r\n\r\n// Note: ReadMany is exported but not yet used. It will be available when needed.\r\n\r\n// Re-esportazione delle struct dei repository per facilitare l'import\r\npub use chat::ChatRepository;\r\npub use invitation::InvitationRepository;\r\npub use message::MessageRepository;\r\npub use user::UserRepository;\r\npub use user_chat_metadata::UserChatMetadataRepository;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","traits.rs"],"content":"//! Common repository traits\r\n//!\r\n//! This module defines generic interfaces for database operations.\r\n\r\n/// Trait for creating new entities in the database\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the returned entity (with ID assigned by the database)\r\n/// * `CreateDTO` - DTO for creation (without ID, will be automatically generated)\r\npub trait Create\u003cEntity, CreateDTO\u003e {\r\n    /// Creates a new entity in the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `data` - DTO containing the data for creation (without ID)\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Entity)` - Created entity with ID assigned by the database\r\n    /// * `Err(sqlx::Error)` - Error during insertion\r\n    async fn create(\u0026self, data: \u0026CreateDTO) -\u003e Result\u003cEntity, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for reading a single entity by primary key\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the entity to read\r\n/// * `Id` - Type of the primary key (e.g. `i32`, `String`, `(i32, i32)`)\r\npub trait Read\u003cEntity, Id\u003e {\r\n    /// Reads an entity from the database by its primary key\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to read\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Some(Entity))` - Entity found\r\n    /// * `Ok(None)` - No entity with that ID\r\n    /// * `Err(sqlx::Error)` - Error during reading\r\n    async fn read(\u0026self, id: \u0026Id) -\u003e Result\u003cOption\u003cEntity\u003e, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for updating existing entities\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the updated entity\r\n/// * `UpdateDTO` - DTO for updating (optional fields for partial updates)\r\n/// * `Id` - Type of the primary key\r\npub trait Update\u003cEntity, UpdateDTO, Id\u003e {\r\n    /// Updates an existing entity in the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to update\r\n    /// * `data` - DTO containing the fields to update (only `Some(_)` fields are modified)\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Entity)` - Updated entity\r\n    /// * `Err(sqlx::Error)` - Error during update (e.g. entity not found)\r\n    async fn update(\u0026self, id: \u0026Id, data: \u0026UpdateDTO) -\u003e Result\u003cEntity, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for deleting entities\r\n///\r\n/// # Type Parameters\r\n/// * `Id` - Type of the primary key\r\npub trait Delete\u003cId\u003e {\r\n    /// Deletes an entity from the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to delete\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(())` - Deletion successful\r\n    /// * `Err(sqlx::Error)` - Error during deletion\r\n    async fn delete(\u0026self, id: \u0026Id) -\u003e Result\u003c(), sqlx::Error\u003e;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","user.rs"],"content":"//! UserRepository - Repository per la gestione degli utenti\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateUserDTO, UpdateUserDTO};\r\nuse crate::entities::User;\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// USER REPO\r\npub struct UserRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl UserRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e UserRepository {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    ///considero l'username univoco\r\n    /// Find user by exact username match\r\n    /// For partial username search, use search_by_username_partial\r\n    #[instrument(skip(self), fields(username = %username))]\r\n    pub async fn find_by_username(\u0026self, username: \u0026String) -\u003e Result\u003cOption\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Finding user by username\");\r\n        let user = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE username = ?\",\r\n            username\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if user.is_some() {\r\n            info!(\"User found\");\r\n        } else {\r\n            debug!(\"User not found\");\r\n        }\r\n\r\n        Ok(user)\r\n    }\r\n\r\n    /// Search users by partial username match (for search functionality)\r\n    #[instrument(skip(self), fields(pattern = %username_pattern))]\r\n    pub async fn search_by_username_partial(\r\n        \u0026self,\r\n        username_pattern: \u0026String,\r\n    ) -\u003e Result\u003cVec\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Searching users with partial username match\");\r\n        let pattern = format!(\"{}%\", username_pattern);\r\n        let users = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE username LIKE ? LIMIT 10\",\r\n            pattern\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"Found {} users matching pattern\", users.len());\r\n        Ok(users)\r\n    }\r\n}\r\n\r\nimpl Create\u003cUser, CreateUserDTO\u003e for UserRepository {\r\n    #[instrument(skip(self, data), fields(username = %data.username))]\r\n    async fn create(\u0026self, data: \u0026CreateUserDTO) -\u003e Result\u003cUser, Error\u003e {\r\n        debug!(\"Creating new user\");\r\n        // Insert user and get the ID using MySQL syntax\r\n        let result = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            data.username,\r\n            data.password\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"User created with id {}\", new_id);\r\n\r\n        // Return the created user with the new ID\r\n        Ok(User {\r\n            user_id: new_id,\r\n            username: data.username.clone(),\r\n            password: data.password.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cUser, i32\u003e for UserRepository {\r\n    #[instrument(skip(self), fields(user_id = %id))]\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Reading user by id\");\r\n        let user = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE user_id = ?\",\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if user.is_some() {\r\n            debug!(\"User found\");\r\n        } else {\r\n            debug!(\"User not found\");\r\n        }\r\n\r\n        Ok(user)\r\n    }\r\n}\r\n\r\nimpl Update\u003cUser, UpdateUserDTO, i32\u003e for UserRepository {\r\n    #[instrument(skip(self, data), fields(user_id = %id))]\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateUserDTO) -\u003e Result\u003cUser, Error\u003e {\r\n        debug!(\"Updating user\");\r\n        // First, get the current user to ensure it exists\r\n        let current_user = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // Only password can be updated\r\n        if let Some(ref password) = data.password {\r\n            debug!(\"Updating user password\");\r\n            sqlx::query!(\r\n                \"UPDATE users SET password = ? WHERE user_id = ?\",\r\n                password,\r\n                id\r\n            )\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n            info!(\"User password updated\");\r\n\r\n            // Fetch and return the updated user\r\n            self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n        } else {\r\n            // If no password provided, return current user unchanged\r\n            debug!(\"No password update provided, returning current user\");\r\n            Ok(current_user)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for UserRepository {\r\n    /// Soft delete user by setting username to \"Deleted User\" and clearing password \"\"\r\n    /// This preserves message history while anonymizing the user\r\n    #[instrument(skip(self), fields(user_id = %user_id))]\r\n    async fn delete(\u0026self, user_id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        debug!(\"Soft deleting user\");\r\n        sqlx::query!(\r\n            \"UPDATE users SET username = 'Deleted User', password = '' WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"User soft deleted successfully\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use sqlx::MySqlPool;\r\n\r\n    // ============================================================================\r\n    // Tests for CREATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che create crei correttamente un nuovo utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"new_user\".to_string(),\r\n            password: \"hashed_password_123\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created.user_id \u003e 0);\r\n        assert_eq!(created.username, create_dto.username);\r\n        assert_eq!(created.password, create_dto.password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con UNIQUE constraint violation per username duplicato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_fails_with_duplicate_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice esiste già\r\n        let duplicate_dto = CreateUserDTO {\r\n            username: \"alice\".to_string(),\r\n            password: \"some_password\".to_string(),\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected unique constraint violation for duplicate username\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create permetta username case-sensitive differenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_case_sensitive_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: \"alice\" esiste (lowercase)\r\n        let uppercase_dto = CreateUserDTO {\r\n            username: \"ALICE\".to_string(),\r\n            password: \"password\".to_string(),\r\n        };\r\n        \r\n        // Questo dovrebbe avere successo se il DB è case-sensitive, altrimenti fallisce\r\n        let result = repo.create(\u0026uppercase_dto).await;\r\n        \r\n        // In MySQL con utf8mb4_unicode_ci (case-insensitive), questo fallisce\r\n        // Se si usa utf8mb4_bin (case-sensitive), avrebbe successo\r\n        // Verifichiamo solo che non ci sia panic\r\n        let _ = result;\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create gestisca password vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_with_empty_password(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"user_empty_pass\".to_string(),\r\n            password: \"\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create gestisca username e password lunghi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_with_long_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let long_username = \"a\".repeat(200); // Assumendo che il DB accetti 255 chars\r\n        let long_password = \"b\".repeat(500);\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: long_username.clone(),\r\n            password: long_password.clone(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created.username, long_username);\r\n        assert_eq!(created.password, long_password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for READ method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che read restituisca un utente esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_user_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: user_id=1 è alice\r\n        let user_id = 1;\r\n        \r\n        let user = repo.read(\u0026user_id).await?;\r\n        \r\n        assert!(user.is_some());\r\n        let u = user.unwrap();\r\n        assert_eq!(u.user_id, user_id);\r\n        assert_eq!(u.username, \"alice\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca None per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let user = repo.read(\u0026nonexistent_id).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca l'utente dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"test_read\".to_string(),\r\n            password: \"password123\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        let read_user = repo.read(\u0026created.user_id).await?;\r\n        \r\n        assert!(read_user.is_some());\r\n        let u = read_user.unwrap();\r\n        assert_eq!(u.user_id, created.user_id);\r\n        assert_eq!(u.username, created.username);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca tutti i campi correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_returns_all_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: user_id=2 è bob\r\n        let user_id = 2;\r\n        \r\n        let user = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        assert_eq!(user.user_id, 2);\r\n        assert_eq!(user.username, \"bob\");\r\n        assert!(!user.password.is_empty()); // password esiste\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for UPDATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che update aggiorni correttamente la password\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_password_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let new_password = \"new_hashed_password_456\".to_string();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(new_password.clone()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.user_id, user_id);\r\n        assert_eq!(updated.password, new_password);\r\n        assert_eq!(updated.username, \"alice\"); // username non cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update con password=None non modifichi l'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_with_no_password_change(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        let before = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.user_id, before.user_id);\r\n        assert_eq!(updated.username, before.username);\r\n        assert_eq!(updated.password, before.password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update fallisca per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"new_password\".to_string()),\r\n        };\r\n        \r\n        let result = repo.update(\u0026nonexistent_id, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected error for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update preservi username\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_preserves_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        let original_username = \"bob\".to_string();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"totally_new_password\".to_string()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.username, original_username);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa cambiare password a stringa vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_to_empty_password(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"\".to_string()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa essere chiamato più volte\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Primo update\r\n        let update1 = UpdateUserDTO {\r\n            password: Some(\"password1\".to_string()),\r\n        };\r\n        let result1 = repo.update(\u0026user_id, \u0026update1).await?;\r\n        assert_eq!(result1.password, \"password1\");\r\n        \r\n        // Secondo update\r\n        let update2 = UpdateUserDTO {\r\n            password: Some(\"password2\".to_string()),\r\n        };\r\n        let result2 = repo.update(\u0026user_id, \u0026update2).await?;\r\n        assert_eq!(result2.password, \"password2\");\r\n        \r\n        // Terzo update\r\n        let update3 = UpdateUserDTO {\r\n            password: Some(\"password3\".to_string()),\r\n        };\r\n        let result3 = repo.update(\u0026user_id, \u0026update3).await?;\r\n        assert_eq!(result3.password, \"password3\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for DELETE method (Soft Delete)\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che delete esegua soft delete correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_soft_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Verifica stato iniziale\r\n        let before = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(before.username, \"alice\");\r\n        assert!(!before.password.is_empty());\r\n        \r\n        // Soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Verifica che l'utente esista ancora ma sia anonimizzato\r\n        let after = repo.read(\u0026user_id).await?;\r\n        assert!(after.is_some(), \"User should still exist after soft delete\");\r\n        \r\n        let deleted_user = after.unwrap();\r\n        assert_eq!(deleted_user.user_id, user_id);\r\n        assert_eq!(deleted_user.username, \"Deleted User\");\r\n        assert_eq!(deleted_user.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non fallisca per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        // Soft delete su utente inesistente non dovrebbe dare errore\r\n        let result = repo.delete(\u0026nonexistent_id).await;\r\n        \r\n        assert!(result.is_ok(), \"Expected soft delete to succeed even for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete preservi user_id\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_preserves_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        \r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        let deleted_user = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        assert_eq!(deleted_user.user_id, user_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete possa essere chiamato più volte (idempotente)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Primo soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        let after_first = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(after_first.username, \"Deleted User\");\r\n        \r\n        // Secondo soft delete (dovrebbe essere idempotente)\r\n        repo.delete(\u0026user_id).await?;\r\n        let after_second = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(after_second.username, \"Deleted User\");\r\n        assert_eq!(after_second.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete mantenga la cronologia dei messaggi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_delete_preserves_message_history(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1; // Alice ha messaggi nei fixtures\r\n        \r\n        // Conta i messaggi prima del soft delete\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // Soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Conta i messaggi dopo il soft delete\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // I messaggi dovrebbero essere preservati\r\n        assert_eq!(messages_before.count, messages_after.count);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for find_by_username method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che find_by_username trovi un utente esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let username = \"alice\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026username).await?;\r\n        \r\n        assert!(user.is_some());\r\n        let u = user.unwrap();\r\n        assert_eq!(u.username, username);\r\n        assert_eq!(u.user_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username restituisca None per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_username = \"nonexistent_user\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026nonexistent_username).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for nonexistent username\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username sia exact match (non parziale)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_exact_match_only(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste \"alice\", cerco \"alic\" (parziale)\r\n        let partial_username = \"alic\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026partial_username).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for partial match\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username trovi utente dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"findme\".to_string(),\r\n            password: \"password\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        let found = repo.find_by_username(\u0026create_dto.username).await?;\r\n        \r\n        assert!(found.is_some());\r\n        assert_eq!(found.unwrap().user_id, created.user_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username trovi utente soft-deleted\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_after_soft_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Soft delete alice\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Cerca \"Deleted User\"\r\n        let deleted_user = repo.find_by_username(\u0026\"Deleted User\".to_string()).await?;\r\n        \r\n        // Dovrebbe trovare almeno un utente con \"Deleted User\"\r\n        assert!(deleted_user.is_some());\r\n        \r\n        // Non dovrebbe più trovare \"alice\"\r\n        let alice = repo.find_by_username(\u0026\"alice\".to_string()).await?;\r\n        assert!(alice.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for search_by_username_partial method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che search_by_username_partial trovi utenti con pattern\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice, bob, charlie\r\n        let pattern = \"a\".to_string(); // dovrebbe trovare alice e charlie\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(!users.is_empty());\r\n        // Verifica che tutti i risultati inizino con \"a\"\r\n        for user in users {\r\n            assert!(user.username.starts_with(\"a\"));\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial restituisca array vuoto per nessun match\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_no_match(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let pattern = \"xyz\".to_string(); // nessun utente inizia con xyz\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(users.is_empty(), \"Expected empty array for no matches\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial limiti i risultati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_limit(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Crea 15 utenti che iniziano con \"test\"\r\n        for i in 0..15 {\r\n            let create_dto = CreateUserDTO {\r\n                username: format!(\"test_user_{}\", i),\r\n                password: \"password\".to_string(),\r\n            };\r\n            repo.create(\u0026create_dto).await?;\r\n        }\r\n        \r\n        let pattern = \"test\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        // Dovrebbe restituire al massimo 10 risultati (LIMIT 10)\r\n        assert!(users.len() \u003c= 10, \"Expected at most 10 results\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial trovi tutti i match\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_finds_all_matches(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: bob inizia con \"b\"\r\n        let pattern = \"b\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(users.iter().any(|u| u.username == \"bob\"));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial sia case-insensitive\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_case_insensitive(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice esiste (lowercase)\r\n        let uppercase_pattern = \"A\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026uppercase_pattern).await?;\r\n        \r\n        // Con utf8mb4_unicode_ci (case-insensitive), dovrebbe trovare alice\r\n        // Se non trova nulla, il DB potrebbe essere case-sensitive\r\n        let found_alice = users.iter().any(|u| u.username.to_lowercase() == \"alice\");\r\n        \r\n        // Questo test potrebbe passare o fallire a seconda del collation del DB\r\n        // Lo lasciamo per documentazione\r\n        let _ = found_alice;\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for CASCADE behaviors with related tables\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su invitations (invited_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_hard_delete_user_cascades_to_invitations_invited(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Note: questo test usa HARD DELETE invece di soft delete per verificare CASCADE\r\n        \r\n        let user_id = 3; // Charlie è invited_id in alcuni inviti\r\n        \r\n        // Conta inviti per Charlie prima\r\n        let invitations_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(invitations_before.count \u003e 0, \"Charlie should have invitations\");\r\n        \r\n        // HARD DELETE (non soft delete)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti siano stati eliminati per CASCADE\r\n        let invitations_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(invitations_after.count, 0, \"Invitations should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su invitations (invitee_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_hard_delete_user_cascades_to_invitations_inviter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 2; // Bob è invitee_id in alcuni inviti\r\n        \r\n        // Conta inviti creati da Bob prima\r\n        let invitations_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invitee_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(invitations_before.count \u003e 0, \"Bob should have created invitations\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let invitations_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invitee_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(invitations_after.count, 0, \"Invitations should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su messages\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_hard_delete_user_cascades_to_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 1; // Alice ha messaggi\r\n        \r\n        // Conta messaggi prima\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(messages_before.count \u003e 0, \"Alice should have messages\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(messages_after.count, 0, \"Messages should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su userchatmetadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_hard_delete_user_cascades_to_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 1; // Alice è membro di varie chat\r\n        \r\n        // Conta metadata prima\r\n        let metadata_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(metadata_before.count \u003e 0, \"Alice should have chat metadata\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let metadata_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(metadata_after.count, 0, \"Metadata should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che soft delete NON causi CASCADE (preserva relazioni)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_soft_delete_preserves_relations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1; // Alice\r\n        \r\n        // Conta messaggi prima\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // SOFT DELETE tramite repository\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Verifica che i messaggi siano ancora presenti\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(messages_before.count, messages_after.count, \"Messages should be preserved with soft delete\");\r\n        \r\n        // Verifica che l'utente sia anonimizzato ma esista\r\n        let user = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(user.username, \"Deleted User\");\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":23,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":92,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":114,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":123,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":149,"address":[],"length":0,"stats":{"Line":1152921504606846976}}],"covered":8,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","user_chat_metadata.rs"],"content":"//! UserChatMetadataRepository - Repository per la gestione dei metadati utente-chat\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateUserChatMetadataDTO, UpdateUserChatMetadataDTO};\r\nuse crate::entities::{UserChatMetadata, UserRole};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// USERCHATMETADATA REPO\r\npub struct UserChatMetadataRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl UserChatMetadataRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get all members of a specific chat\r\n    pub async fn find_many_by_chat_id(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let metadata_list = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n            SELECT \r\n                user_id,\r\n                chat_id,\r\n                user_role as \"user_role: UserRole\",\r\n                member_since,\r\n                messages_visible_from,\r\n                messages_received_until\r\n            FROM userchatmetadata \r\n            WHERE chat_id = ?\r\n            \"#,\r\n            chat_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(metadata_list)\r\n    }\r\n\r\n    /// Transfer ownership from one user to another in a chat\r\n    pub async fn transfer_ownership(\r\n        \u0026self,\r\n        from_user_id: \u0026i32,\r\n        to_user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003c(), Error\u003e {\r\n        // Start a transaction for atomicity\r\n        let mut tx = self.connection_pool.begin().await?;\r\n\r\n        // Update the old owner to admin\r\n        sqlx::query!(\r\n            \"UPDATE userchatmetadata SET user_role = 'ADMIN' WHERE user_id = ? AND chat_id = ?\",\r\n            from_user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026mut *tx)\r\n        .await?;\r\n\r\n        // Update the new owner\r\n        sqlx::query!(\r\n            \"UPDATE userchatmetadata SET user_role = 'OWNER' WHERE user_id = ? AND chat_id = ?\",\r\n            to_user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026mut *tx)\r\n        .await?;\r\n\r\n        // Commit the transaction\r\n        tx.commit().await?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Get all chats for a specific user\r\n    pub async fn find_many_by_user_id(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let result = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n        SELECT\r\n            user_id,\r\n            chat_id,\r\n            user_role as \"user_role: UserRole\",\r\n            member_since,\r\n            messages_visible_from,\r\n            messages_received_until\r\n        FROM userchatmetadata\r\n        WHERE user_id = ?\r\n        \"#,\r\n            user_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(result)\r\n    }\r\n\r\n    /// Create multiple metadata entries in a single transaction\r\n    /// Ensures atomicity: either all are created or none\r\n    pub async fn create_many(\r\n        \u0026self,\r\n        metadata_list: \u0026[CreateUserChatMetadataDTO],\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        if metadata_list.is_empty() {\r\n            return Ok(Vec::new());\r\n        }\r\n\r\n        let mut tx = self.connection_pool.begin().await?;\r\n\r\n        let mut created = Vec::with_capacity(metadata_list.len());\r\n\r\n        for data in metadata_list {\r\n            sqlx::query!(\r\n                r#\"\r\n                INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until) \r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n                \"#,\r\n                data.user_id,\r\n                data.chat_id,\r\n                data.user_role,\r\n                data.member_since,\r\n                data.messages_visible_from,\r\n                data.messages_received_until\r\n            )\r\n            .execute(\u0026mut *tx)\r\n            .await?;\r\n\r\n            created.push(UserChatMetadata {\r\n                user_id: data.user_id,\r\n                chat_id: data.chat_id,\r\n                user_role: data.user_role.clone(),\r\n                member_since: data.member_since,\r\n                messages_visible_from: data.messages_visible_from,\r\n                messages_received_until: data.messages_received_until,\r\n            });\r\n        }\r\n\r\n        tx.commit().await?;\r\n\r\n        Ok(created)\r\n    }\r\n\r\n    pub async fn update_user_role(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n        new_role: \u0026UserRole,\r\n    ) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        // Mappo l'enum sul valore testuale usato in DB\r\n        let role_str = match new_role {\r\n            UserRole::Owner =\u003e \"OWNER\",\r\n            UserRole::Admin =\u003e \"ADMIN\",\r\n            UserRole::Member =\u003e \"MEMBER\",\r\n        };\r\n\r\n        // UPDATE mirato su chiave composta (user_id, chat_id)\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            UPDATE userchatmetadata\r\n            SET user_role = ?\r\n            WHERE user_id = ? AND chat_id = ?\r\n            \"#,\r\n            role_str,\r\n            user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Se nessuna riga è stata toccata, la coppia (user_id, chat_id) non esiste\r\n        if result.rows_affected() == 0 {\r\n            return Err(sqlx::Error::RowNotFound);\r\n        }\r\n\r\n        // Ritorno il record aggiornato\r\n        self.read(\u0026(*user_id, *chat_id))\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Create\u003cUserChatMetadata, CreateUserChatMetadataDTO\u003e for UserChatMetadataRepository {\r\n    #[instrument(skip(self, data), fields(user_id = %data.user_id, chat_id = %data.chat_id))]\r\n    async fn create(\u0026self, data: \u0026CreateUserChatMetadataDTO) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        debug!(\"Creating new user chat metadata\");\r\n        // Insert metadata using MySQL syntax\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata \r\n            (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until) \r\n            VALUES (?, ?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.user_id,\r\n            data.chat_id,\r\n            data.user_role,\r\n            data.member_since,\r\n            data.messages_visible_from,\r\n            data.messages_received_until\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"User chat metadata created for user {} in chat {}\", data.user_id, data.chat_id);\r\n\r\n        // Return the created metadata\r\n        Ok(UserChatMetadata {\r\n            user_id: data.user_id,\r\n            chat_id: data.chat_id,\r\n            user_role: data.user_role.clone(),\r\n            member_since: data.member_since,\r\n            messages_visible_from: data.messages_visible_from,\r\n            messages_received_until: data.messages_received_until,\r\n        })\r\n    }\r\n}\r\n\r\n/// Alias per chiarezza: tipo usato come 'ID' composto per le operazioni\r\n/// su `UserChatMetadata`.\r\n/// Convenzione:\r\n/// - `UserChatKey.0` =\u003e `user_id`\r\n/// - `UserChatKey.1` =\u003e `chat_id`\r\n///\r\n/// Usare questo alias nelle firme di `read`, `update`, `delete` aiuta\r\n/// l'IDE a mostrare la documentazione quando si richiama quelle funzioni.\r\npub type UserChatKey = (i32, i32);\r\n\r\nimpl Read\u003cUserChatMetadata, UserChatKey\u003e for UserChatMetadataRepository {\r\n    async fn read(\u0026self, id: \u0026UserChatKey) -\u003e Result\u003cOption\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let metadata = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n            SELECT \r\n                user_id,\r\n                chat_id,\r\n                user_role as \"user_role: UserRole\",\r\n                member_since,\r\n                messages_visible_from,\r\n                messages_received_until\r\n            FROM userchatmetadata \r\n            WHERE user_id = ? \r\n            AND chat_id = ?\r\n            \"#,\r\n            id.0,\r\n            id.1\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(metadata)\r\n    }\r\n}\r\n\r\nimpl Update\u003cUserChatMetadata, UpdateUserChatMetadataDTO, UserChatKey\u003e\r\n    for UserChatMetadataRepository\r\n{\r\n    async fn update(\r\n        \u0026self,\r\n        id: \u0026UserChatKey,\r\n        data: \u0026UpdateUserChatMetadataDTO,\r\n    ) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        // First, get the current metadata to ensure it exists\r\n        let current_metadata = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no fields to update, return current metadata\r\n        if data.user_role.is_none()\r\n            \u0026\u0026 data.messages_visible_from.is_none()\r\n            \u0026\u0026 data.messages_received_until.is_none()\r\n        {\r\n            return Ok(current_metadata);\r\n        }\r\n\r\n        // Build dynamic UPDATE query using QueryBuilder (idiomatic SQLx way)\r\n        let mut query_builder = sqlx::QueryBuilder::new(\"UPDATE userchatmetadata SET \");\r\n\r\n        let mut separated = query_builder.separated(\", \");\r\n        if let Some(ref role) = data.user_role {\r\n            separated.push(\"user_role = \");\r\n            separated.push_bind_unseparated(role);\r\n        }\r\n        if let Some(ref visible_from) = data.messages_visible_from {\r\n            separated.push(\"messages_visible_from = \");\r\n            separated.push_bind_unseparated(visible_from);\r\n        }\r\n        if let Some(ref received_until) = data.messages_received_until {\r\n            separated.push(\"messages_received_until = \");\r\n            separated.push_bind_unseparated(received_until);\r\n        }\r\n\r\n        query_builder.push(\" WHERE user_id = \");\r\n        query_builder.push_bind(id.0);\r\n\r\n        query_builder.push(\" AND chat_id = \");\r\n        query_builder.push_bind(id.1);\r\n\r\n        query_builder.build().execute(\u0026self.connection_pool).await?;\r\n\r\n        // Fetch and return the updated metadata\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003cUserChatKey\u003e for UserChatMetadataRepository {\r\n    async fn delete(\u0026self, id: \u0026UserChatKey) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id=?\",\r\n            id.0,\r\n            id.1\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::entities::UserRole;\r\n    use sqlx::MySqlPool;\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: find_many_by_chat_id */\r\n    /*----------------------------------*/\r\n\r\n    /// Test: trova tutti i membri di una chat esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // La \"General Chat\" (chat_id=1) ha 3 membri: alice, bob, charlie\r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti gli user_id siano presenti\r\n        let user_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.user_id).collect();\r\n        assert!(user_ids.contains(\u00261)); // alice\r\n        assert!(user_ids.contains(\u00262)); // bob\r\n        assert!(user_ids.contains(\u00263)); // charlie\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trova i membri di una chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // La chat privata Alice-Bob (chat_id=2) ha 2 membri\r\n        let result = repo.find_many_by_chat_id(\u00262).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let user_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.user_id).collect();\r\n        assert!(user_ids.contains(\u00261)); // alice\r\n        assert!(user_ids.contains(\u00262)); // bob\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: restituisce lista vuota per chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Chat inesistente\r\n        let result = repo.find_many_by_chat_id(\u0026999).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i ruoli siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_with_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // General Chat (chat_id=1): alice=OWNER, bob=MEMBER, charlie=MEMBER\r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        // Trova alice (user_id=1)\r\n        let alice_metadata = result.iter().find(|m| m.user_id == 1).unwrap();\r\n        assert_eq!(alice_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        // Trova bob (user_id=2)\r\n        let bob_metadata = result.iter().find(|m| m.user_id == 2).unwrap();\r\n        assert_eq!(bob_metadata.user_role, Some(UserRole::Member));\r\n        \r\n        // Trova charlie (user_id=3)\r\n        let charlie_metadata = result.iter().find(|m| m.user_id == 3).unwrap();\r\n        assert_eq!(charlie_metadata.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica i diversi ruoli in una chat (OWNER, ADMIN, MEMBER)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_different_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Dev Team (chat_id=3): alice=OWNER, charlie=ADMIN\r\n        let result = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let alice = result.iter().find(|m| m.user_id == 1).unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Owner));\r\n        \r\n        let charlie = result.iter().find(|m| m.user_id == 3).unwrap();\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina i suoi metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: General Chat ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina Bob (user_id=2)\r\n        // CASCADE DELETE eliminerà i suoi metadata in tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: General Chat dovrebbe avere solo 2 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che Bob non sia più presente\r\n        let user_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.user_id).collect();\r\n        assert!(!user_ids.contains(\u00262)); // bob non c'è più\r\n        assert!(user_ids.contains(\u00261)); // alice c'è ancora\r\n        assert!(user_ids.contains(\u00263)); // charlie c'è ancora\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat elimina tutti i metadata associati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina la chat\r\n        // CASCADE DELETE eliminerà tutti i metadata associati\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: nessun metadata dovrebbe esistere per quella chat\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Verifica nel database che i metadata siano stati eliminati\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            1\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(count.count, 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di utente che è OWNER in più chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER in chat 1, 2 e 3\r\n        // Verifica stato iniziale\r\n        let chat1_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        let chat2_before = repo.find_many_by_chat_id(\u00262).await?;\r\n        let chat3_before = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(chat1_before.len(), 3); // General Chat\r\n        assert_eq!(chat2_before.len(), 2); // Private Alice-Bob\r\n        assert_eq!(chat3_before.len(), 2); // Dev Team\r\n        \r\n        // Elimina Alice\r\n        // CASCADE eliminerà i suoi metadata da tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che Alice sia stata rimossa da tutte le chat\r\n        let chat1_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        let chat2_after = repo.find_many_by_chat_id(\u00262).await?;\r\n        let chat3_after = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(chat1_after.len(), 2); // bob e charlie rimangono\r\n        assert_eq!(chat2_after.len(), 1); // solo bob rimane\r\n        assert_eq!(chat3_after.len(), 1); // solo charlie rimane\r\n        \r\n        // Verifica che Alice non sia in nessuna chat\r\n        assert!(!chat1_after.iter().any(|m| m.user_id == 1));\r\n        assert!(!chat2_after.iter().any(|m| m.user_id == 1));\r\n        assert!(!chat3_after.iter().any(|m| m.user_id == 1));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiunta di un nuovo membro e verifica che sia trovato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_after_adding_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Dev Team (chat_id=3) inizialmente ha 2 membri: alice e charlie\r\n        let result_before = repo.find_many_by_chat_id(\u00263).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Aggiungi Bob al Dev Team\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until)\r\n            VALUES (?, ?, 'MEMBER', NOW(), NOW(), NOW())\r\n            \"#,\r\n            2, 3\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora dovrebbe avere 3 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00263).await?;\r\n        assert_eq!(result_after.len(), 3);\r\n        \r\n        // Verifica che Bob sia presente\r\n        let bob = result_after.iter().find(|m| m.user_id == 2);\r\n        assert!(bob.is_some());\r\n        assert_eq!(bob.unwrap().user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: rimozione di un membro specifico\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_after_removing_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Rimuovi Charlie dalla General Chat\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id = ?\",\r\n            3, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora dovrebbe avere 2 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che Charlie non ci sia più\r\n        assert!(!result_after.iter().any(|m| m.user_id == 3));\r\n        \r\n        // Ma alice e bob dovrebbero essere ancora presenti\r\n        assert!(result_after.iter().any(|m| m.user_id == 1));\r\n        assert!(result_after.iter().any(|m| m.user_id == 2));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i timestamp siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_with_timestamps(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        // Verifica che tutti i membri abbiano timestamp validi\r\n        for metadata in result {\r\n            assert!(metadata.member_since \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_visible_from \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_received_until \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di più utenti contemporaneamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_multiple_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina Bob e Charlie\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id IN (?, ?)\", 2, 3)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dovrebbe rimanere solo Alice\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 1);\r\n        assert_eq!(result_after[0].user_id, 1);\r\n        assert_eq!(result_after[0].user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*--------------------------------*/\r\n    /* Unit tests: transfer_ownership */\r\n    /*--------------------------------*/\r\n\r\n    /// Test: trasferimento di ownership da un utente ad un altro\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER della General Chat (chat_id=1)\r\n        // Bob (user_id=2) è MEMBER della General Chat\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        assert_eq!(bob_before.user_role, Some(UserRole::Member));\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Dopo il trasferimento:\r\n        // Alice dovrebbe essere ADMIN\r\n        // Bob dovrebbe essere OWNER\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership da OWNER ad ADMIN\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_owner_to_admin(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Dev Team (chat_id=3): alice=OWNER, charlie=ADMIN\r\n        let alice_before = repo.read(\u0026(1, 3)).await?.unwrap();\r\n        let charlie_before = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        assert_eq!(charlie_before.user_role, Some(UserRole::Admin));\r\n        \r\n        // Trasferisci ownership da Alice a Charlie\r\n        repo.transfer_ownership(\u00261, \u00263, \u00263).await?;\r\n        \r\n        // Alice dovrebbe diventare ADMIN\r\n        // Charlie dovrebbe diventare OWNER\r\n        let alice_after = repo.read(\u0026(1, 3)).await?.unwrap();\r\n        let charlie_after = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership in chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Private Alice-Bob (chat_id=2): alice=OWNER, bob=MEMBER\r\n        repo.transfer_ownership(\u00261, \u00262, \u00262).await?;\r\n        \r\n        let alice = repo.read(\u0026(1, 2)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 2)).await?.unwrap();\r\n        \r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità della transazione - entrambe le operazioni devono avere successo\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_atomicity(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Verifica stato iniziale\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Trasferimento valido\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica che entrambe le modifiche siano state applicate\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento con utente non esistente nel database\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_nonexistent_target(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato prima del tentativo\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Tentativo di trasferire ownership a un utente inesistente (999)\r\n        // Il database non dovrebbe avere un utente con id 999 in questa chat\r\n        let result = repo.transfer_ownership(\u00261, \u0026999, \u00261).await;\r\n        \r\n        // L'operazione dovrebbe completarsi senza errori anche se l'utente target non esiste\r\n        // perché MySQL UPDATE su righe inesistenti non genera errore\r\n        assert!(result.is_ok());\r\n        \r\n        // Alice dovrebbe essere diventata ADMIN (prima parte dell'operazione)\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione del vecchio owner dopo trasferimento\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_old_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob nella General Chat\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina Alice (ex-owner, ora admin)\r\n        // CASCADE eliminerà i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice non dovrebbe più esistere nei metadata\r\n        let alice = repo.read(\u0026(1, 1)).await?;\r\n        assert!(alice.is_none());\r\n        \r\n        // Bob dovrebbe essere ancora owner\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        // La chat dovrebbe avere 2 membri invece di 3\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione del nuovo owner dopo trasferimento\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_new_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina Bob (nuovo owner)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe più esistere\r\n        let bob_after = repo.read(\u0026(2, 1)).await?;\r\n        assert!(bob_after.is_none());\r\n        \r\n        // Alice (ora admin) dovrebbe essere ancora presente\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione della chat dopo trasferimento ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina la chat\r\n        // CASCADE eliminerà tutti i metadata associati\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessun metadata dovrebbe esistere per questa chat\r\n        let alice_after = repo.read(\u0026(1, 1)).await?;\r\n        let bob_after = repo.read(\u0026(2, 1)).await?;\r\n        \r\n        assert!(alice_after.is_none());\r\n        assert!(bob_after.is_none());\r\n        \r\n        // Verifica che la chat non abbia membri\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: doppio trasferimento di ownership (A-\u003eB-\u003eC)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_chain(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale: alice=OWNER, bob=MEMBER, charlie=MEMBER\r\n        // Primo trasferimento: Alice -\u003e Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        let alice_after_first = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after_first = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after_first.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after_first.user_role, Some(UserRole::Owner));\r\n        \r\n        // Secondo trasferimento: Bob -\u003e Charlie\r\n        repo.transfer_ownership(\u00262, \u00263, \u00261).await?;\r\n        \r\n        let bob_after_second = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie_after_second = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(bob_after_second.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie_after_second.user_role, Some(UserRole::Owner));\r\n        \r\n        // Alice dovrebbe essere ancora admin (non modificata nel secondo trasferimento)\r\n        let alice_final = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_final.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership e poi rollback manuale\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_and_rollback(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // \"Rollback\" manuale: ritrasferisci ownership da Bob ad Alice\r\n        repo.transfer_ownership(\u00262, \u00261, \u00261).await?;\r\n        \r\n        // Verifica che siamo tornati allo stato originale (quasi)\r\n        let alice_final = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_final = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_final.user_role, Some(UserRole::Owner));\r\n        assert_eq!(bob_final.user_role, Some(UserRole::Admin)); // Bob era MEMBER, ora è ADMIN\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che il trasferimento non modifichi altri campi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Salva i valori iniziali\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        let alice_member_since = alice_before.member_since;\r\n        let alice_visible_from = alice_before.messages_visible_from;\r\n        let bob_member_since = bob_before.member_since;\r\n        let bob_visible_from = bob_before.messages_visible_from;\r\n        \r\n        // Trasferisci ownership\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica che solo user_role sia cambiato\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        // Verifica che i timestamp non siano cambiati\r\n        assert_eq!(alice_after.member_since, alice_member_since);\r\n        assert_eq!(alice_after.messages_visible_from, alice_visible_from);\r\n        assert_eq!(bob_after.member_since, bob_member_since);\r\n        assert_eq!(bob_after.messages_visible_from, bob_visible_from);\r\n        \r\n        // Solo i ruoli dovrebbero essere cambiati\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: find_many_by_user_id */\r\n    /*----------------------------------*/\r\n\r\n    /// Test: trova tutte le chat di un utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) è in 3 chat: General Chat (1), Private Alice-Bob (2), Dev Team (3)\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti i chat_id siano presenti\r\n        let chat_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261)); // General Chat\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob\r\n        assert!(chat_ids.contains(\u00263)); // Dev Team\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trova le chat di un utente che è in meno chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_fewer_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) è in 2 chat: General Chat (1), Private Alice-Bob (2)\r\n        let result = repo.find_many_by_user_id(\u00262).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261)); // General Chat\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob\r\n        assert!(!chat_ids.contains(\u00263)); // NON è in Dev Team\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: restituisce lista vuota per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Utente inesistente\r\n        let result = repo.find_many_by_user_id(\u0026999).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica i ruoli dell'utente nelle varie chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_with_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è OWNER in tutte e 3 le sue chat\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        for metadata in \u0026result {\r\n            assert_eq!(metadata.user_role, Some(UserRole::Owner));\r\n        }\r\n        \r\n        // Charlie (user_id=3): MEMBER in General Chat, ADMIN in Dev Team\r\n        let charlie_result = repo.find_many_by_user_id(\u00263).await?;\r\n        \r\n        let general_chat = charlie_result.iter().find(|m| m.chat_id == 1).unwrap();\r\n        assert_eq!(general_chat.user_role, Some(UserRole::Member));\r\n        \r\n        let dev_team = charlie_result.iter().find(|m| m.chat_id == 3).unwrap();\r\n        assert_eq!(dev_team.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i timestamp siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_with_timestamps(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        // Verifica che tutti i metadata abbiano timestamp validi\r\n        for metadata in result {\r\n            assert!(metadata.member_since \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_visible_from \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_received_until \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina tutti i suoi metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: Bob è in 2 chat\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Elimina Bob\r\n        // CASCADE DELETE eliminerà tutti i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: Bob non dovrebbe avere metadata\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Verifica nel database\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(count.count, 0, \"Tutti i metadata dell'utente dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat rimuove il metadata per quell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina General Chat (chat_id=1)\r\n        // CASCADE eliminerà i metadata di tutti gli utenti per quella chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: Alice dovrebbe essere in 2 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che la chat eliminata non sia più presente\r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(!chat_ids.contains(\u00261)); // General Chat eliminata\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob ancora presente\r\n        assert!(chat_ids.contains(\u00263)); // Dev Team ancora presente\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di più chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_multiple_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina 2 chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id IN (?, ?)\", 1, 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice dovrebbe essere solo in 1 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 1);\r\n        assert_eq!(result_after[0].chat_id, 3); // Solo Dev Team rimane\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di utente con molte chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_user_with_multiple_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Verifica che sia presente in tutte e 3\r\n        let chat_ids_before: Vec\u003ci32\u003e = result_before.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids_before.contains(\u00261));\r\n        assert!(chat_ids_before.contains(\u00262));\r\n        assert!(chat_ids_before.contains(\u00263));\r\n        \r\n        // Elimina Alice\r\n        // CASCADE eliminerà tutti i suoi metadata in tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice non dovrebbe avere più metadata\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        \r\n        // Le chat dovrebbero esistere ancora (non sono state eliminate)\r\n        let chat1_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 1)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        let chat2_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 2)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        let chat3_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 3)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(chat1_exists.is_some(), \"Chat 1 dovrebbe esistere ancora\");\r\n        assert!(chat2_exists.is_some(), \"Chat 2 dovrebbe esistere ancora\");\r\n        assert!(chat3_exists.is_some(), \"Chat 3 dovrebbe esistere ancora\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiunta di un utente a una nuova chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_adding_to_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob inizialmente è in 2 chat\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Aggiungi Bob al Dev Team (chat_id=3)\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until)\r\n            VALUES (?, ?, 'MEMBER', NOW(), NOW(), NOW())\r\n            \"#,\r\n            2, 3\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora Bob dovrebbe essere in 3 chat\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 3);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261));\r\n        assert!(chat_ids.contains(\u00262));\r\n        assert!(chat_ids.contains(\u00263)); // Nuovo\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: rimozione di un utente da una chat specifica\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_leaving_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Alice lascia General Chat (chat_id=1)\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id = ?\",\r\n            1, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora Alice dovrebbe essere in 2 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(!chat_ids.contains(\u00261)); // Non più in General Chat\r\n        assert!(chat_ids.contains(\u00262));\r\n        assert!(chat_ids.contains(\u00263));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica risultati dopo trasferimento ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_ownership_transfer(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale\r\n        let alice_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_before.len(), 3);\r\n        \r\n        // Verifica che Alice sia OWNER in tutte le sue chat\r\n        for metadata in \u0026alice_before {\r\n            assert_eq!(metadata.user_role, Some(UserRole::Owner));\r\n        }\r\n        \r\n        // Trasferisci ownership da Alice a Bob nella General Chat\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Alice dovrebbe essere ancora in 3 chat\r\n        let alice_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_after.len(), 3);\r\n        \r\n        // Ma il suo ruolo in General Chat dovrebbe essere ADMIN\r\n        let general_chat_metadata = alice_after.iter().find(|m| m.chat_id == 1).unwrap();\r\n        assert_eq!(general_chat_metadata.user_role, Some(UserRole::Admin));\r\n        \r\n        // I suoi ruoli nelle altre chat dovrebbero essere ancora OWNER\r\n        let private_chat_metadata = alice_after.iter().find(|m| m.chat_id == 2).unwrap();\r\n        assert_eq!(private_chat_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        let dev_team_metadata = alice_after.iter().find(|m| m.chat_id == 3).unwrap();\r\n        assert_eq!(dev_team_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: utente in solo una chat (caso minimo)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_single_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Rimuovi Bob da tutte le chat tranne una\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id != ?\",\r\n            2, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Bob dovrebbe essere solo in 1 chat\r\n        let result = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result.len(), 1);\r\n        assert_eq!(result[0].chat_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di tutte le chat di un utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_all_user_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è in 2 chat (chat_id=1, chat_id=2)\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Elimina entrambe le chat di Bob\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id IN (?, ?)\", 1, 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe avere più chat\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Ma Bob (l'utente) dovrebbe esistere ancora\r\n        let user_exists = sqlx::query!(\"SELECT user_id FROM users WHERE user_id = ?\", 2)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        assert!(user_exists.is_some(), \"L'utente Bob dovrebbe esistere ancora\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica ordinamento dei risultati (se presente)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_result_order(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è in 3 chat\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti i risultati siano validi e abbiano lo stesso user_id\r\n        for metadata in \u0026result {\r\n            assert_eq!(metadata.user_id, 1);\r\n            assert!(metadata.chat_id \u003e 0);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: interazione tra eliminazione utente e chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_mixed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale: Bob in 2 chat, Charlie in 2 chat\r\n        let bob_before = repo.find_many_by_user_id(\u00262).await?;\r\n        let charlie_before = repo.find_many_by_user_id(\u00263).await?;\r\n        assert_eq!(bob_before.len(), 2);\r\n        assert_eq!(charlie_before.len(), 2);\r\n        \r\n        // Elimina Bob (utente)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Elimina una chat dove Charlie è membro\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe avere metadata\r\n        let bob_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(bob_after.len(), 0);\r\n        \r\n        // Charlie dovrebbe essere in 1 sola chat (Dev Team)\r\n        let charlie_after = repo.find_many_by_user_id(\u00263).await?;\r\n        assert_eq!(charlie_after.len(), 1);\r\n        assert_eq!(charlie_after[0].chat_id, 3);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*-------------------------*/\r\n    /* Unit tests: create_many */\r\n    /*-------------------------*/\r\n\r\n    /// Test: creazione di più metadata in una singola transazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            \"Test Description\",\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Prepara i dati per creare 3 membri contemporaneamente\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // Crea tutti i metadata\r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica che siano stati creati tutti e 3\r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica i ruoli\r\n        assert_eq!(result[0].user_role, Some(UserRole::Owner));\r\n        assert_eq!(result[1].user_role, Some(UserRole::Admin));\r\n        assert_eq!(result[2].user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica che siano stati effettivamente inseriti nel database\r\n        let chat_members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(chat_members.len(), 3);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione con lista vuota restituisce lista vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_empty_list(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let empty_list: Vec\u003cCreateUserChatMetadataDTO\u003e = vec![];\r\n        let result = repo.create_many(\u0026empty_list).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione di un singolo metadata (caso minimo)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_single_item(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Single Member Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        assert_eq!(result.len(), 1);\r\n        assert_eq!(result[0].user_id, 1);\r\n        assert_eq!(result[0].chat_id, new_chat_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità della transazione - se uno fallisce, falliscono tutti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_atomicity_user_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 999, // Utente inesistente\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // La creazione dovrebbe fallire\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        // Verifica che nessun metadata sia stato creato (rollback automatico)\r\n        let chat_members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(chat_members.len(), 0, \"Nessun metadata dovrebbe essere creato (transazione rollback)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità - chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_atomicity_chat_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: 999, // Chat inesistente\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // La creazione dovrebbe fallire\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: violazione di chiave primaria (user_id, chat_id duplicati)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_duplicate_key_violation(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: 1, // Alice è già nella General Chat\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // Dovrebbe fallire perché Alice è già nella chat\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"newuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata per il nuovo utente\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id: 1,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 1);\r\n        \r\n        // Verifica che il metadata esista\r\n        let metadata_exists = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(metadata_exists.is_some());\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let metadata_after = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(metadata_after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Aggiungi membri\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 2);\r\n        \r\n        // Verifica che i metadata esistano\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 2);\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata siano stati eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione di molti metadata (stress test)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_large_batch(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea più utenti per il test\r\n        for i in 4..=10 {\r\n            sqlx::query!(\r\n                \"INSERT INTO users (user_id, username, password) VALUES (?, ?, ?)\",\r\n                i,\r\n                format!(\"user{}\", i),\r\n                \"password\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        }\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Large Group Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Prepara metadata per 10 utenti (user_id 1-10)\r\n        let now = chrono::Utc::now();\r\n        let metadata_list: Vec\u003cCreateUserChatMetadataDTO\u003e = (1..=10)\r\n            .map(|user_id| CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: if user_id == 1 {\r\n                    Some(UserRole::Owner)\r\n                } else if user_id \u003c= 3 {\r\n                    Some(UserRole::Admin)\r\n                } else {\r\n                    Some(UserRole::Member)\r\n                },\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            })\r\n            .collect();\r\n        \r\n        // Crea tutti i metadata\r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 10);\r\n        \r\n        // Verifica nel database\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 10);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica ordine di restituzione dei metadata creati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_preserves_order(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Order Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica che l'ordine sia preservato\r\n        assert_eq!(result[0].user_id, 3);\r\n        assert_eq!(result[1].user_id, 1);\r\n        assert_eq!(result[2].user_id, 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione con diversi ruoli\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_different_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Roles Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica i ruoli\r\n        assert_eq!(result[0].user_role, Some(UserRole::Owner));\r\n        assert_eq!(result[1].user_role, Some(UserRole::Admin));\r\n        assert_eq!(result[2].user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica che i ruoli siano stati salvati correttamente\r\n        let owner = repo.read(\u0026(1, new_chat_id)).await?.unwrap();\r\n        let admin = repo.read(\u0026(2, new_chat_id)).await?.unwrap();\r\n        let member = repo.read(\u0026(3, new_chat_id)).await?.unwrap();\r\n        \r\n        assert_eq!(owner.user_role, Some(UserRole::Owner));\r\n        assert_eq!(admin.user_role, Some(UserRole::Admin));\r\n        assert_eq!(member.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione multipla e poi eliminazione di più utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_multiple_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea nuovi utenti\r\n        let user4_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user4\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user5_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user5\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Aggiungi i nuovi utenti alla chat\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: user4_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: user5_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica creazione\r\n        let members_before = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_before.len(), 2);\r\n        \r\n        // Elimina entrambi gli utenti\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id IN (?, ?)\", user4_id, user5_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata siano stati eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------*/\r\n    /* Unit tests: update_user_role */\r\n    /*------------------------------*/\r\n\r\n    /// Test: aggiornamento ruolo da MEMBER a ADMIN\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_member_to_admin(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) è MEMBER nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Member));\r\n        \r\n        // Promuovi Bob ad ADMIN\r\n        let result = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        assert_eq!(result.user_id, 2);\r\n        assert_eq!(result.chat_id, 1);\r\n        assert_eq!(result.user_role, Some(UserRole::Admin));\r\n        \r\n        // Verifica nel database\r\n        let after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo da ADMIN a OWNER\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_admin_to_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Charlie (user_id=3) è ADMIN nel Dev Team (chat_id=3)\r\n        let before = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Admin));\r\n        \r\n        // Promuovi Charlie a OWNER\r\n        let result = repo.update_user_role(\u00263, \u00263, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo da OWNER a MEMBER (demozione)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_owner_to_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) è OWNER nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Degrada Alice a MEMBER\r\n        let result = repo.update_user_role(\u00261, \u00261, \u0026UserRole::Member).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica persistenza\r\n        let after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando user_id non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tentativo di aggiornare utente inesistente\r\n        let result = repo.update_user_role(\u0026999, \u00261, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando chat_id non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_chat_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tentativo di aggiornare in una chat inesistente\r\n        let result = repo.update_user_role(\u00261, \u0026999, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando la combinazione (user_id, chat_id) non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_metadata_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) non è nel Dev Team (chat_id=3)\r\n        let result = repo.update_user_role(\u00262, \u00263, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che solo user_role cambi, altri campi rimangono invariati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Salva i valori originali\r\n        let before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let original_member_since = before.member_since;\r\n        let original_visible_from = before.messages_visible_from;\r\n        let original_received_until = before.messages_received_until;\r\n        \r\n        // Aggiorna solo il ruolo\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica che gli altri campi siano invariati\r\n        let after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after.member_since, original_member_since);\r\n        assert_eq!(after.messages_visible_from, original_visible_from);\r\n        assert_eq!(after.messages_received_until, original_received_until);\r\n        assert_eq!(after.user_role, Some(UserRole::Admin)); // Solo questo cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo allo stesso valore (idempotenza)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_same_value(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è già OWNER\r\n        let before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Owner));\r\n        \r\n        // \"Aggiorna\" a OWNER (stesso valore)\r\n        let result = repo.update_user_role(\u00261, \u00261, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        // Verifica che funzioni senza problemi\r\n        let after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamenti multipli sequenziali\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_multiple_sequential(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Sequenza: MEMBER -\u003e ADMIN -\u003e OWNER -\u003e MEMBER\r\n        let metadata = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(metadata.user_role, Some(UserRole::Member));\r\n        \r\n        // MEMBER -\u003e ADMIN\r\n        let result1 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        assert_eq!(result1.user_role, Some(UserRole::Admin));\r\n        \r\n        // ADMIN -\u003e OWNER\r\n        let result2 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Owner).await?;\r\n        assert_eq!(result2.user_role, Some(UserRole::Owner));\r\n        \r\n        // OWNER -\u003e MEMBER\r\n        let result3 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Member).await?;\r\n        assert_eq!(result3.user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica finale\r\n        let final_state = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(final_state.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento in chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Private Alice-Bob (chat_id=2): Bob è MEMBER\r\n        let before = repo.read(\u0026(2, 2)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Member));\r\n        \r\n        // Promuovi Bob a OWNER nella chat privata\r\n        let result = repo.update_user_role(\u00262, \u00262, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento ruolo e poi eliminazione utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Promuovi Bob ad ADMIN\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica l'aggiornamento\r\n        let after_update = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after_update.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina Bob - CASCADE dovrebbe eliminare tutti i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Il metadata non dovrebbe più esistere\r\n        let after_delete = repo.read(\u0026(2, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento ruolo e poi eliminazione chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Promuovi Bob ad ADMIN nella General Chat\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica l'aggiornamento\r\n        let after_update = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after_update.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessun metadata dovrebbe esistere per questa chat\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamenti concorrenti su utenti diversi nella stessa chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_multiple_users_same_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // General Chat (chat_id=1): aggiorna ruoli di più utenti\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica che entrambi siano stati aggiornati\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(bob.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        // Alice dovrebbe essere ancora OWNER (non modificata)\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo dopo transfer_ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_after_transfer_ownership(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Alice dovrebbe essere ADMIN ora\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        \r\n        // Degrada Alice a MEMBER\r\n        repo.update_user_role(\u00261, \u00261, \u0026UserRole::Member).await?;\r\n        \r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Member));\r\n        \r\n        // Bob dovrebbe essere ancora OWNER\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update_user_role funzioni con tutti e tre i ruoli\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_all_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat con 3 membri\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Aggiorna a ruoli diversi\r\n        repo.update_user_role(\u00261, \u0026new_chat_id, \u0026UserRole::Owner).await?;\r\n        repo.update_user_role(\u00262, \u0026new_chat_id, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u0026new_chat_id, \u0026UserRole::Member).await?; // Rimane MEMBER\r\n        \r\n        // Verifica\r\n        let user1 = repo.read(\u0026(1, new_chat_id)).await?.unwrap();\r\n        let user2 = repo.read(\u0026(2, new_chat_id)).await?.unwrap();\r\n        let user3 = repo.read(\u0026(3, new_chat_id)).await?.unwrap();\r\n        \r\n        assert_eq!(user1.user_role, Some(UserRole::Owner));\r\n        assert_eq!(user2.user_role, Some(UserRole::Admin));\r\n        assert_eq!(user3.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento di più utenti e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_multiple_updates_then_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Aggiorna più ruoli nella General Chat\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica gli aggiornamenti\r\n        let members_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members_before.len(), 3);\r\n        \r\n        // Conta gli admin\r\n        let admin_count = members_before.iter().filter(|m| m.user_role == Some(UserRole::Admin)).count();\r\n        assert_eq!(admin_count, 2);\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutti i metadata dovrebbero essere eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members_after.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che rows_affected sia corretto\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_rows_affected(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Aggiornamento valido\r\n        let result = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await;\r\n        assert!(result.is_ok(), \"L'aggiornamento dovrebbe avere successo\");\r\n        \r\n        // Aggiornamento invalido (metadata inesistente)\r\n        let result_invalid = repo.update_user_role(\u0026999, \u0026999, \u0026UserRole::Admin).await;\r\n        assert!(result_invalid.is_err(), \"Dovrebbe fallire con RowNotFound\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: create (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: errore con user_id inesistente (violazione foreign key)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_user_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 999, // Utente inesistente\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation su user_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con chat_id inesistente (violazione foreign key)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_chat_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: 999, // Chat inesistente\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation su chat_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_both_not_exist(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 888,\r\n            chat_id: 999,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con chiave primaria duplicata (user_id, chat_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_duplicate_key(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1, // Alice è già nella General Chat (fixtures)\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con duplicate primary key error\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore tentando di creare dopo che l'utente esiste ma viene eliminato durante l'operazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_user_deleted_before_insert(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"tempuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Elimina immediatamente l'utente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Prova a creare il metadata per l'utente appena eliminato\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire perché l'utente è stato eliminato\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore tentando di creare dopo che la chat viene eliminata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_chat_deleted_before_insert(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Elimina immediatamente la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Prova a creare il metadata per la chat appena eliminata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire perché la chat è stata eliminata\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_user_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata per il nuovo utente\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che il metadata esista\r\n        let exists = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(exists.is_some(), \"Il metadata dovrebbe esistere dopo la creazione\");\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato automaticamente (CASCADE DELETE su user_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_chat_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che il metadata esista\r\n        let exists = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(exists.is_some(), \"Il metadata dovrebbe esistere dopo la creazione\");\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato automaticamente (CASCADE DELETE su chat_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione di più metadata per utenti diversi nella stessa chat, poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_chat_removes_all_members_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Group\",\r\n            Some(\"Group to be deleted\"),\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea metadata per 3 utenti\r\n        for user_id in [1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(if user_id == 1 { UserRole::Owner } else { UserRole::Member }),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che tutti i metadata esistano\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 3, \"Dovrebbero esserci 3 membri\");\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che TUTTI i metadata siano stati eliminati (CASCADE)\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE DELETE)\");\r\n        \r\n        // Verifica anche singolarmente\r\n        for user_id in [1, 2, 3] {\r\n            let metadata = repo.read(\u0026(user_id, new_chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata per user_id {} dovrebbe essere eliminato\", user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione di metadata per lo stesso utente in più chat, poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_user_removes_all_chats_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea 2 nuove chat\r\n        let chat_ids: Vec\u003ci32\u003e = vec![\r\n            sqlx::query!(\r\n                \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n                \"Test Chat 1\",\r\n                None::\u003cString\u003e,\r\n                \"GROUP\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?\r\n            .last_insert_id() as i32,\r\n            sqlx::query!(\r\n                \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n                \"Test Chat 2\",\r\n                None::\u003cString\u003e,\r\n                \"GROUP\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?\r\n            .last_insert_id() as i32,\r\n        ];\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Aggiungi l'utente a entrambe le chat\r\n        for \u0026chat_id in \u0026chat_ids {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che l'utente sia in 2 chat\r\n        let user_chats = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats.len(), 2, \"L'utente dovrebbe essere in 2 chat\");\r\n        \r\n        // Elimina l'utente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che TUTTI i metadata siano stati eliminati (CASCADE)\r\n        let user_chats_after = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE DELETE)\");\r\n        \r\n        // Verifica anche singolarmente\r\n        for \u0026chat_id in \u0026chat_ids {\r\n            let metadata = repo.read(\u0026(new_user_id, chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata per chat_id {} dovrebbe essere eliminato\", chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con creazioni multiple e CASCADE su entrambe le FK\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 nuovi utenti\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea 2 nuove chat\r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea una matrice di metadata: ogni utente in ogni chat\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica: 4 metadata creati (2 utenti x 2 chat)\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user1_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user2_id).await?.len(), 2);\r\n        \r\n        // Elimina user1 - dovrebbe rimuovere 2 metadata (user1 in chat1 e chat2)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 1, \"Chat1 dovrebbe avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 1, \"Chat2 dovrebbe avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user1_id).await?.len(), 0, \"User1 non dovrebbe avere metadata\");\r\n        \r\n        // Elimina chat1 - dovrebbe rimuovere 1 metadata (user2 in chat1)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 0, \"Chat1 non dovrebbe avere membri\");\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 1, \"Chat2 dovrebbe ancora avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user2_id).await?.len(), 1, \"User2 dovrebbe essere in 1 chat\");\r\n        \r\n        // Verifica che rimanga solo il metadata di user2 in chat2\r\n        let remaining = repo.read(\u0026(user2_id, chat2_id)).await?;\r\n        assert!(remaining.is_some(), \"Dovrebbe rimanere solo user2 in chat2\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di creare dopo che un altro metadata nella stessa chat causa un errore\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_isolation_between_creates(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Prima creazione: successo\r\n        let dto1 = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result1 = repo.create(\u0026dto1).await;\r\n        assert!(result1.is_ok(), \"La prima creazione dovrebbe avere successo\");\r\n        \r\n        // Seconda creazione con user_id invalido: fallimento\r\n        let dto2 = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result2 = repo.create(\u0026dto2).await;\r\n        assert!(result2.is_err(), \"La seconda creazione dovrebbe fallire\");\r\n        \r\n        // Terza creazione valida: dovrebbe avere successo nonostante il fallimento precedente\r\n        let dto3 = CreateUserChatMetadataDTO {\r\n            user_id: 2,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result3 = repo.create(\u0026dto3).await;\r\n        assert!(result3.is_ok(), \"La terza creazione dovrebbe avere successo (isolamento degli errori)\");\r\n        \r\n        // Verifica: dovrebbero esserci solo 2 metadata (quello fallito non è stato inserito)\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 2, \"Dovrebbero esserci solo 2 membri (quello fallito non è stato inserito)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: read (casi negativi) */\r\n    /*----------------------------------*/\r\n\r\n    /// Test NEGATIVO: read di metadata inesistente (user_id valido ma non in quella chat)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_not_exists_valid_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team chat (chat_id=3)\r\n        let result = repo.read(\u0026(2, 3)).await?;\r\n        \r\n        assert!(result.is_none(), \"Il metadata non dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read di metadata inesistente (chat_id valido ma utente non membro)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_not_exists_valid_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Charlie (user_id=3) non è nella chat privata Alice-Bob (chat_id=2)\r\n        let result = repo.read(\u0026(3, 2)).await?;\r\n        \r\n        assert!(result.is_none(), \"Il metadata non dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con user_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(999, 1)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per user_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con chat_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(1, 999)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per chat_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(888, 999)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(-1, -1)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(0, 0)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo delete dell'utente (CASCADE DELETE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) è nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some(), \"Bob dovrebbe essere nella General Chat\");\r\n        \r\n        // Elimina Bob - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(2, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE su user_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo delete della chat (CASCADE DELETE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some(), \"Alice dovrebbe essere nella General Chat\");\r\n        \r\n        // Elimina la General Chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(1, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE su chat_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read multipli dopo delete dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_after_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat (fixtures)\r\n        let chats_before = repo.find_many_by_user_id(\u00261).await?;\r\n        let alice_chat_ids: Vec\u003ci32\u003e = chats_before.iter().map(|m| m.chat_id).collect();\r\n        \r\n        // Verifica che Alice sia in tutte quelle chat\r\n        for \u0026chat_id in \u0026alice_chat_ids {\r\n            let metadata = repo.read(\u0026(1, chat_id)).await?;\r\n            assert!(metadata.is_some(), \"Alice dovrebbe essere nella chat {}\", chat_id);\r\n        }\r\n        \r\n        // Elimina Alice\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutte le read dovrebbero restituire None\r\n        for \u0026chat_id in \u0026alice_chat_ids {\r\n            let metadata = repo.read(\u0026(1, chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata di Alice nella chat {} dovrebbe essere eliminato\", chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read multipli dopo delete della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_after_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat ha 3 membri\r\n        let members_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        let user_ids: Vec\u003ci32\u003e = members_before.iter().map(|m| m.user_id).collect();\r\n        \r\n        assert_eq!(user_ids.len(), 3, \"La General Chat dovrebbe avere 3 membri\");\r\n        \r\n        // Verifica che tutti i membri siano nella chat\r\n        for \u0026user_id in \u0026user_ids {\r\n            let metadata = repo.read(\u0026(user_id, 1)).await?;\r\n            assert!(metadata.is_some(), \"L'utente {} dovrebbe essere nella General Chat\", user_id);\r\n        }\r\n        \r\n        // Elimina la General Chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutte le read dovrebbero restituire None\r\n        for \u0026user_id in \u0026user_ids {\r\n            let metadata = repo.read(\u0026(user_id, 1)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata dell'utente {} dovrebbe essere eliminato\", user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read dopo delete manuale (non CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_manual_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(before.is_some(), \"Il metadata dovrebbe esistere\");\r\n        \r\n        // Delete manuale\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after.is_none(), \"Il metadata non dovrebbe più esistere dopo delete\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo creazione e immediata eliminazione CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_create_and_immediate_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"tempuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(before.is_some(), \"Il metadata dovrebbe esistere\");\r\n        \r\n        // Elimina l'utente immediatamente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato immediatamente (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // User valido, chat invalida\r\n        let result1 = repo.read(\u0026(1, 999)).await?;\r\n        assert!(result1.is_none());\r\n        \r\n        // User invalido, chat valida\r\n        let result2 = repo.read(\u0026(999, 1)).await?;\r\n        assert!(result2.is_none());\r\n        \r\n        // User negativo, chat valida\r\n        let result3 = repo.read(\u0026(-5, 1)).await?;\r\n        assert!(result3.is_none());\r\n        \r\n        // User valido, chat negativa\r\n        let result4 = repo.read(\u0026(1, -5)).await?;\r\n        assert!(result4.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso - read dopo eliminazioni multiple\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una matrice di test: 2 utenti, 2 chat\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata (user1 in chat1, user1 in chat2, user2 in chat1, user2 in chat2)\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica che tutti esistano\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina user1 - dovrebbe eliminare 2 metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none(), \"user1-chat1 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none(), \"user1-chat2 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some(), \"user2-chat1 dovrebbe esistere\");\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some(), \"user2-chat2 dovrebbe esistere\");\r\n        \r\n        // Elimina chat1 - dovrebbe eliminare 1 metadata rimanente\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none(), \"user2-chat1 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some(), \"user2-chat2 dovrebbe ancora esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read dopo update fallito non dovrebbe influenzare il risultato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_failed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta di creare con FK invalida (dovrebbe fallire)\r\n        let now = chrono::Utc::now();\r\n        let invalid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let create_result = repo.create(\u0026invalid_dto).await;\r\n        assert!(create_result.is_err(), \"La creazione dovrebbe fallire\");\r\n        \r\n        // Read dovrebbe confermare che non esiste\r\n        let after_failed_create = repo.read(\u0026(999, 1)).await?;\r\n        assert!(after_failed_create.is_none(), \"Non dovrebbe esistere dopo creazione fallita\");\r\n        \r\n        // Tenta di leggere un metadata esistente per confermare che il database è ancora consistente\r\n        let existing = repo.read(\u0026(1, 1)).await?;\r\n        assert!(existing.is_some(), \"I metadata esistenti dovrebbero essere ancora accessibili\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read ripetuti dopo CASCADE DELETE confermano persistenza dell'eliminazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_times_after_cascade(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_some());\r\n        \r\n        // Elimina Bob\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Leggi multiple volte - dovrebbe sempre restituire None\r\n        for _ in 0..5 {\r\n            let result = repo.read(\u0026(2, 1)).await?;\r\n            assert!(result.is_none(), \"Dovrebbe sempre restituire None dopo CASCADE DELETE\");\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: update (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: update di metadata inesistente (user_id e chat_id non associati)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team (chat_id=3)\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(2, 3), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per metadata inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con user_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Member),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(999, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per user_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con chat_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Owner),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per chat_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(888, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per entrambi gli ID inesistenti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Member),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(-1, -1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Owner),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(0, 0), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_then_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente e metadata\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Update del metadata\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026(new_user_id, 1), \u0026update_dto).await?;\r\n        assert_eq!(updated.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_then_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Update del metadata\r\n        let future = chrono::Utc::now() + chrono::Duration::days(30);\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: None,\r\n            messages_visible_from: None,\r\n            messages_received_until: Some(future),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026(1, new_chat_id), \u0026update_dto).await?;\r\n        // Verifica che l'update sia avvenuto (il timestamp dovrebbe essere vicino a 'future')\r\n        assert!(updated.messages_received_until \u003e now, \"Il timestamp dovrebbe essere stato aggiornato\");\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update multipli e poi eliminazione CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_multiple_then_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Update più utenti nella General Chat\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        repo.update(\u0026(2, 1), \u0026update_dto).await?;\r\n        repo.update(\u0026(3, 1), \u0026update_dto).await?;\r\n        \r\n        // Verifica gli update\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutti i metadata dovrebbero essere eliminati\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(3, 1)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di update dopo delete dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_user_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina Bob - CASCADE elimina il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(2, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di update dopo delete della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_chat_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è nella General Chat\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la General Chat - CASCADE elimina tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update dopo delete manuale del metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_manual_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Delete manuale\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, new_chat_id), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con DTO vuoto (nessun campo da aggiornare) su metadata inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_empty_dto_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // DTO vuoto\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: None,\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // Anche se il DTO è vuoto, dovrebbe fallire perché il metadata non esiste\r\n        let result = repo.update(\u0026(999, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per metadata inesistente, anche con DTO vuoto\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con update e eliminazioni multiple\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 utenti e 2 chat\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Update tutti a Admin\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                repo.update(\u0026(user_id, chat_id), \u0026update_dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica che tutti siano Admin\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let metadata = repo.read(\u0026(user_id, chat_id)).await?.unwrap();\r\n                assert_eq!(metadata.user_role, Some(UserRole::Admin));\r\n            }\r\n        }\r\n        \r\n        // Elimina user1\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // user1 non dovrebbe più avere metadata\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none());\r\n        \r\n        // user2 dovrebbe ancora avere i suoi metadata\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina chat1\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessuno dovrebbe avere metadata per chat1\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none());\r\n        \r\n        // user2 in chat2 dovrebbe ancora esistere\r\n        let remaining = repo.read(\u0026(user2_id, chat2_id)).await?;\r\n        assert!(remaining.is_some());\r\n        assert_eq!(remaining.unwrap().user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // User valido, chat invalida\r\n        let result1 = repo.update(\u0026(1, 999), \u0026update_dto).await;\r\n        assert!(result1.is_err());\r\n        \r\n        // User invalido, chat valida\r\n        let result2 = repo.update(\u0026(999, 1), \u0026update_dto).await;\r\n        assert!(result2.is_err());\r\n        \r\n        // User negativo, chat valida\r\n        let result3 = repo.update(\u0026(-5, 1), \u0026update_dto).await;\r\n        assert!(result3.is_err());\r\n        \r\n        // User valido, chat negativa\r\n        let result4 = repo.update(\u0026(1, -5), \u0026update_dto).await;\r\n        assert!(result4.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update ripetuti dopo CASCADE DELETE falliscono\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_multiple_times_after_cascade(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_some());\r\n        \r\n        // Elimina Bob\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // Tenta update multiple volte - dovrebbero tutti fallire\r\n        for _ in 0..3 {\r\n            let result = repo.update(\u0026(2, 1), \u0026update_dto).await;\r\n            assert!(result.is_err(), \"L'update dovrebbe sempre fallire dopo CASCADE DELETE\");\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update dopo operazione fallita non influenza metadata esistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_isolation_after_failed_update(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta update su metadata inesistente\r\n        let invalid_update = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(999, 1), \u0026invalid_update).await;\r\n        assert!(result.is_err(), \"L'update dovrebbe fallire\");\r\n        \r\n        // Verifica che i metadata esistenti siano ancora accessibili e aggiornabili\r\n        let valid_update = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result2 = repo.update(\u0026(1, 1), \u0026valid_update).await;\r\n        assert!(result2.is_ok(), \"L'update valido dovrebbe avere successo\");\r\n        \r\n        let updated = result2.unwrap();\r\n        assert_eq!(updated.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: delete (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: delete di metadata inesistente (non genera errore ma non elimina nulla)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team (chat_id=3)\r\n        let result = repo.delete(\u0026(2, 3)).await;\r\n        \r\n        // Delete non genera errore anche se il record non esiste\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se il record non esiste\");\r\n        \r\n        // Verifica che i metadata esistenti non siano stati toccati\r\n        let existing = repo.read(\u0026(2, 1)).await?;\r\n        assert!(existing.is_some(), \"I metadata esistenti non dovrebbero essere toccati\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con user_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let result = repo.delete(\u0026(999, 1)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per user_id inesistente\");\r\n        \r\n        // Verifica che i metadata della chat siano intatti\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 3, \"I membri della General Chat dovrebbero essere intatti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con chat_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let result = repo.delete(\u0026(1, 999)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per chat_id inesistente\");\r\n        \r\n        // Verifica che i metadata di Alice siano intatti\r\n        let alice_chats = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_chats.len(), 3, \"Le chat di Alice dovrebbero essere intatte\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(888, 999)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore anche per entrambi gli ID inesistenti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(-1, -1)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(0, 0)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo che l'utente è già stato eliminato (CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_user_cascade_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina Bob - CASCADE elimina automaticamente il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        \r\n        // Tentativo di delete non genera errore (record già inesistente)\r\n        let result = repo.delete(\u0026(2, 1)).await;\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se già eliminato da CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo che la chat è già stata eliminata (CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_chat_cascade_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è nella General Chat\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la General Chat - CASCADE elimina tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        \r\n        // Tentativo di delete non genera errore\r\n        let result = repo.delete(\u0026(1, 1)).await;\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se già eliminato da CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete doppio dello stesso metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_twice_same_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_some());\r\n        \r\n        // Prima delete\r\n        let result1 = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(result1.is_ok());\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        // Seconda delete sullo stesso metadata (già inesistente)\r\n        let result2 = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(result2.is_ok(), \"Delete dovrebbe avere successo anche la seconda volta\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: verifica che dopo delete dell'utente, i metadata siano eliminati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_verify_cascade_on_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente con metadata in più chat\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Aggiungi l'utente a 2 chat\r\n        for \u0026chat_id in \u0026[1, 2] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che l'utente sia in 2 chat\r\n        let user_chats = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats.len(), 2);\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare automaticamente tutti i metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutti i metadata siano stati eliminati da CASCADE\r\n        let user_chats_after = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati da CASCADE\");\r\n        \r\n        // Tentativo di delete manuale non genera errori\r\n        let result1 = repo.delete(\u0026(new_user_id, 1)).await;\r\n        let result2 = repo.delete(\u0026(new_user_id, 2)).await;\r\n        assert!(result1.is_ok());\r\n        assert!(result2.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: verifica che dopo delete della chat, tutti i membri siano eliminati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_verify_cascade_on_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat con 3 membri\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Group\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che ci siano 3 membri\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 3);\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutti i metadata siano stati eliminati da CASCADE\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i membri dovrebbero essere eliminati da CASCADE\");\r\n        \r\n        // Tentativo di delete manuale non genera errori\r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let result = repo.delete(\u0026(user_id, new_chat_id)).await;\r\n            assert!(result.is_ok());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete in ordine diverso non causa problemi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_various_orders(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 3 nuovi metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Delete in ordine sparso\r\n        repo.delete(\u0026(2, new_chat_id)).await?;\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        repo.delete(\u0026(3, new_chat_id)).await?;\r\n        \r\n        // Verifica che tutti siano stati eliminati\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete non influenza altre chat dello stesso utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_does_not_affect_other_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let initial_count = repo.find_many_by_user_id(\u00261).await?.len();\r\n        assert_eq!(initial_count, 3);\r\n        \r\n        // Delete Alice dalla General Chat\r\n        repo.delete(\u0026(1, 1)).await?;\r\n        \r\n        // Alice dovrebbe essere ancora in 2 chat\r\n        let after_delete = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(after_delete.len(), 2);\r\n        \r\n        // Verifica che sia stata eliminata solo dalla General Chat\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(1, 2)).await?.is_some());\r\n        assert!(repo.read(\u0026(1, 3)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete non influenza altri utenti nella stessa chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_does_not_affect_other_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat ha 3 membri\r\n        let initial_members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(initial_members.len(), 3);\r\n        \r\n        // Delete Bob dalla General Chat\r\n        repo.delete(\u0026(2, 1)).await?;\r\n        \r\n        // Dovrebbero rimanere 2 membri\r\n        let after_delete = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(after_delete.len(), 2);\r\n        \r\n        // Verifica che solo Bob sia stato eliminato\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_some());\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(3, 1)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con delete manuali e CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 utenti e 2 chat con matrice completa\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica: 4 metadata esistono\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Delete manuale di user1 da chat1\r\n        repo.delete(\u0026(user1_id, chat1_id)).await?;\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none());\r\n        \r\n        // Elimina user1 - CASCADE elimina user1-chat2\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none());\r\n        \r\n        // user2 dovrebbe avere ancora entrambi i metadata\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina chat1 - CASCADE elimina user2-chat1\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none());\r\n        \r\n        // Solo user2-chat2 dovrebbe rimanere\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tutte queste delete non dovrebbero generare errori\r\n        assert!(repo.delete(\u0026(1, 999)).await.is_ok());\r\n        assert!(repo.delete(\u0026(999, 1)).await.is_ok());\r\n        assert!(repo.delete(\u0026(-5, 1)).await.is_ok());\r\n        assert!(repo.delete(\u0026(1, -5)).await.is_ok());\r\n        assert!(repo.delete(\u0026(0, 0)).await.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete ripetute non causano errori\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_multiple_times_no_error(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Delete multiple volte\r\n        for _ in 0..5 {\r\n            let result = repo.delete(\u0026(1, new_chat_id)).await;\r\n            assert!(result.is_ok(), \"Delete dovrebbe sempre avere successo\");\r\n        }\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo operazioni fallite non causa problemi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_failed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta create con FK invalida (fallisce)\r\n        let now = chrono::Utc::now();\r\n        let invalid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let create_result = repo.create(\u0026invalid_dto).await;\r\n        assert!(create_result.is_err());\r\n        \r\n        // Delete non dovrebbe generare errori\r\n        let delete_result = repo.delete(\u0026(999, 1)).await;\r\n        assert!(delete_result.is_ok());\r\n        \r\n        // Verifica che i metadata esistenti siano ancora validi\r\n        let existing = repo.read(\u0026(1, 1)).await?;\r\n        assert!(existing.is_some());\r\n        \r\n        // Delete valido dovrebbe funzionare\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let valid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026valid_dto).await?;\r\n        \r\n        let delete_valid = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(delete_valid.is_ok());\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n}\r\n\r\n\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":20,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":24,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":25,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":37,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":39,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":40,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":42,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":46,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":53,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":56,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":58,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":59,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":61,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":62,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":65,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":67,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":68,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":70,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":71,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":74,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":76,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":80,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":84,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":85,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":97,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":99,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":100,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":102,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":107,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":111,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":115,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":117,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":119,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":120,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":125,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":126,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":127,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":128,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":129,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":130,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":132,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":133,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":135,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":136,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":137,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":138,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":139,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":140,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":141,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":145,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":147,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":150,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":157,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":158,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":159,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":170,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":171,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":172,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":174,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":175,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":178,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":179,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":183,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":184,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":185,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":191,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":235,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":236,"address":[],"length":0,"stats":{"Line":12393906174523604992}},{"line":237,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":250,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":251,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":253,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":254,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":256,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":263,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":269,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":270,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":271,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":272,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":275,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":276,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":277,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":285,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":286,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":287,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":288,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":290,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":295,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":296,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":299,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":300,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":302,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":303,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":305,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":308,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":313,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":314,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":316,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":317,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":319,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":320,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":322,"address":[],"length":0,"stats":{"Line":2522015791327477760}}],"covered":108,"coverable":111},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","auth.rs"],"content":"//! Auth services - Gestione autenticazione e registrazione utenti\r\n\r\nuse crate::core::{AppError, AppState, encode_jwt};\r\nuse crate::dtos::{CreateUserDTO, UserDTO};\r\nuse crate::entities::User;\r\nuse crate::repositories::Create;\r\nuse axum::{\r\n    extract::{Json, State},\r\n    http::{HeaderMap, HeaderValue, StatusCode},\r\n    response::IntoResponse,\r\n};\r\nuse std::sync::Arc;\r\nuse validator::Validate;\r\nuse tracing::{debug, error, info, instrument, warn};\r\n\r\n/// DTO per il login (solo username e password)\r\n#[derive(serde::Deserialize)]\r\npub struct LoginDTO {\r\n    pub username: String,\r\n    pub password: String,\r\n}\r\n\r\n#[instrument(skip(state, body), fields(username = %body.username))]\r\npub async fn login_user(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Json(body): Json\u003cLoginDTO\u003e, // JSON body\r\n) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\r\n    debug!(\"Login attempt for user\");\r\n    // 1. Estrarre lo username dal body della richiesta, ritornare errore BAD_REQUEST se mancante\r\n    // 2. Verificare che la password sia stata fornita nel body, altrimenti ritornare errore UNAUTHORIZED (fail-fast prima della query DB)\r\n    // 3. Bloccare il caso in cui si sta cercando di fare login con \"Deleted User\" (controllo string prima della query DB)\r\n    // 4. Cercare l'utente nel database tramite username\r\n    // 5. Se l'utente non esiste, ritornare errore UNAUTHORIZED\r\n    // 6. Verificare che la password fornita, dopo essere hashata, corrisponda all'hash memorizzato\r\n    // 7. Se la password non corrisponde, ritornare errore UNAUTHORIZED con messaggio specifico\r\n    // 8. Generare un token JWT con il metodo encode che prende in input userid, username e il segreto\r\n    // 9. Costruire un cookie HttpOnly, Secure, SameSite=Lax con il token e durata 24 ore\r\n    // 10. Creare gli headers HTTP con Set-Cookie e Authorization (Bearer token)\r\n    // 11. Ritornare StatusCode::OK con gli headers\r\n\r\n    if body.username == \"Deleted User\" {\r\n        warn!(\"Login attempt with 'Deleted User' username\");\r\n        return Err(AppError::unauthorized(\"Invalid username or password\"));\r\n    }\r\n\r\n    let user = match state.user.find_by_username(\u0026body.username).await? {\r\n        Some(user) =\u003e {\r\n            debug!(\"User found in database\");\r\n            user\r\n        }\r\n        None =\u003e {\r\n            warn!(\"User not found in database\");\r\n            return Err(AppError::unauthorized(\"Invalid username or password\"));\r\n        }\r\n    };\r\n\r\n    if !user.verify_password(\u0026body.password) {\r\n        warn!(\"Invalid password for user\");\r\n        return Err(AppError::unauthorized(\r\n            \"Username or password are not correct.\",\r\n        ));\r\n    }\r\n\r\n    let token = encode_jwt(user.username.clone(), user.user_id, \u0026state.jwt_secret)?;\r\n\r\n    let cookie_value = format!(\r\n        \"token={}; HttpOnly; Secure; SameSite=Lax; Max-Age={}\",\r\n        token,\r\n        24 * 60 * 60\r\n    );\r\n\r\n    let mut headers = HeaderMap::new();\r\n    headers.insert(\"Set-Cookie\", HeaderValue::from_str(\u0026cookie_value).unwrap());\r\n    headers.insert(\r\n        \"Authorization\",\r\n        HeaderValue::from_str(\u0026format!(\"Bearer {}\", token)).unwrap(),\r\n    );\r\n\r\n    info!(\"User logged in successfully: {}\", user.username);\r\n    Ok((StatusCode::OK, headers))\r\n}\r\n\r\n#[instrument(skip(state, body), fields(username = %body.username))]\r\npub async fn register_user(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Json(body): Json\u003cCreateUserDTO\u003e, // JSON body\r\n) -\u003e Result\u003cJson\u003cUserDTO\u003e, AppError\u003e {\r\n    debug!(\"User registration attempt\");\r\n    // 1. Validare il DTO con validator (username/password format, lunghezza, \"Deleted User\")\r\n    // 2. Controllare se esiste già un utente con lo stesso username nel database\r\n    // 3. Se l'utente esiste già, ritornare errore CONFLICT con messaggio \"Username already exists\"\r\n    // 4. Generare l'hash della password fornita\r\n    // 5. Se la generazione dell'hash fallisce, ritornare errore INTERNAL_SERVER_ERROR\r\n    // 6. Creare un nuovo oggetto CreateUserDTO con username e password hashata\r\n    // 7. Salvare il nuovo utente nel database tramite il metodo create\r\n    // 8. Convertire l'utente creato in UserDTO\r\n    // 9. Ritornare il DTO dell'utente creato come risposta JSON\r\n\r\n    // Validazione con validator (include controllo \"Deleted User\")\r\n    body.validate()?;\r\n\r\n    // Controllare se esiste già un utente con lo stesso username\r\n    if let Some(_) = state.user.find_by_username(\u0026body.username).await? {\r\n        warn!(\"Username already exists\");\r\n        return Err(AppError::conflict(\"Username already exists\"));\r\n    }\r\n\r\n    let password_hash = User::hash_password(\u0026body.password)\r\n        .map_err(|e| {\r\n            error!(\"Failed to hash password: {:?}\", e);\r\n            AppError::internal_server_error(\"Failed to hash password\")\r\n        })?;\r\n\r\n    let new_user = CreateUserDTO {\r\n        username: body.username.clone(),\r\n        password: password_hash,\r\n    };\r\n\r\n    let created_user = state.user.create(\u0026new_user).await?;\r\n\r\n    info!(\"User registered successfully: {}\", created_user.username);\r\n    Ok(Json(UserDTO::from(created_user)))\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","chat.rs"],"content":"//! Chat services - Gestione operazioni sulle chat\n\nuse crate::core::{AppError, AppState};\nuse crate::dtos::{ChatDTO, CreateChatDTO, CreateUserChatMetadataDTO, MessageDTO, MessagesQuery};\nuse crate::entities::{Chat, ChatType, User, UserChatMetadata, UserRole};\nuse crate::repositories::{Create, Read};\nuse axum::{\n    Extension,\n    extract::{Json, Path, Query, State},\n};\nuse chrono::Utc;\nuse futures_util::future::try_join_all;\nuse std::sync::Arc;\nuse validator::Validate;\nuse tracing::{debug, info, instrument, warn};\n\n/// DTO per creare una chat (estende CreateChatDTO con user_list per chat private)\n#[derive(serde::Deserialize)]\npub struct CreateChatRequestDTO {\n    pub title: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub chat_type: ChatType,\n    pub user_list: Option\u003cVec\u003ci32\u003e\u003e, // Solo per chat private\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id))]\npub async fn list_chats(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cChatDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing chats for user\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti i metadata dell'utente dal database tramite user_id (singola query)\n    // 3. Estrarre tutti i chat_id dai metadata trovati\n    // 4. Recuperare tutte le chat con query parallele (primary key lookup, velocissimo)\n    // 5. Convertire ogni Chat in ChatDTO (trasformazione in memoria, nessun I/O)\n    // 6. Ritornare la lista di ChatDTO come risposta JSON\n    let chat_ids: Vec\u003ci32\u003e = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?\n        .into_iter()\n        .map(|s| s.chat_id)\n        .collect();\n\n    debug!(\"User is member of {} chats\", chat_ids.len());\n\n    let chats: Vec\u003cChat\u003e = try_join_all(chat_ids.into_iter().map(|cid| {\n        let state = state.clone();\n        async move { state.chat.read(\u0026cid).await }\n    }))\n    .await?\n    .into_iter()\n    .flatten()\n    .collect();\n\n    let chats_dto: Vec\u003cChatDTO\u003e = chats.into_iter().map(ChatDTO::from).collect();\n\n    info!(\"Successfully retrieved {} chats\", chats_dto.len());\n    Ok(Json(chats_dto))\n}\n\n#[instrument(skip(state, current_user, body), fields(user_id = %current_user.user_id, chat_type = ?body.chat_type))]\npub async fn create_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione tramite token jwt\n    Json(body): Json\u003cCreateChatRequestDTO\u003e,\n) -\u003e Result\u003cJson\u003cChatDTO\u003e, AppError\u003e {\n    debug!(\"Creating new chat\");\n    // CASO ChatType::Private:\n    // 1. Verificare che user_list sia presente nel body, altrimenti errore BAD_REQUEST\n    // 2. Verificare che user_list contenga esattamente 2 utenti, altrimenti errore BAD_REQUEST\n    // 3. Verificare che current_user sia uno dei due utenti, altrimenti errore BAD_REQUEST\n    // 4. Identificare l'user_id del secondo utente (diverso da current_user)\n    // 5. Cercare se esiste già una chat privata tra i due utenti (query DB solo dopo validazioni)\n    // 6. Se esiste già, ritornare errore CONFLICT\n    // 7. Creare ChatCreateDTO con title=None, description=None, chat_type=Private\n    // 8. Salvare la chat nel database (la chiave primaria è autoincrementale)\n    // 9. Creare metadata per entrambi gli utenti con ruolo Member e timestamp correnti (preparazione in memoria)\n    // 10. Salvare entrambi i metadata nel database in batch/transazione\n    //\n    // CASO ChatType::Group:\n    // 1. Creare ChatCreateDTO con title e description dal body, chat_type=Group\n    // 2. Salvare la chat nel database (la chiave primaria è autoincrementale)\n    // 3. Creare metadata per current_user con ruolo Owner e timestamp correnti\n    // 4. Salvare il metadata nel database\n    //\n    // FINALE:\n    // 1. Convertire la chat creata in ChatDTO (trasformazione in memoria)\n    // 2. Ritornare il ChatDTO come risposta JSON\n\n    let chat;\n    match body.chat_type {\n        ChatType::Private =\u003e {\n            debug!(\"Creating private chat\");\n            let user_list = body\n                .user_list\n                .as_ref()\n                .ok_or_else(|| {\n                    warn!(\"Private chat creation attempted without user list\");\n                    AppError::bad_request(\"Private chat should specify user list.\")\n                })?;\n\n            if user_list.len() != 2 {\n                warn!(\"Private chat creation attempted with {} users instead of 2\", user_list.len());\n                return Err(AppError::bad_request(\n                    \"Private chat should specify exactly two users.\",\n                ));\n            }\n\n            let second_user_id = user_list\n                .iter()\n                .find(|\u0026\u0026id| id != current_user.user_id)\n                .ok_or_else(|| {\n                    warn!(\"Current user not in user list for private chat\");\n                    AppError::bad_request(\"Current user must be one of the two users.\")\n                })?;\n\n            let existing_chat = state\n                .chat\n                .get_private_chat_between_users(\u0026current_user.user_id, second_user_id)\n                .await?;\n            if existing_chat.is_some() {\n                warn!(\"Private chat already exists between users {} and {}\", current_user.user_id, second_user_id);\n                return Err(AppError::conflict(\n                    \"A private chat between these users already exists.\",\n                ));\n            }\n            let new_chat = CreateChatDTO {\n                title: None,\n                description: None,\n                chat_type: ChatType::Private,\n            };\n            chat = state.chat.create(\u0026new_chat).await?;\n\n            debug!(\"Private chat created with id {}\", chat.chat_id);\n\n            let now = Utc::now();\n            let metadata_current_user = CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            let metadata_second_user = CreateUserChatMetadataDTO {\n                user_id: *second_user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            // Create both metadata in a single transaction for atomicity\n            state\n                .meta\n                .create_many(\u0026[metadata_current_user, metadata_second_user])\n                .await?;\n            \n            info!(\"Private chat created successfully between users {} and {}\", current_user.user_id, second_user_id);\n        }\n\n        ChatType::Group =\u003e {\n            debug!(\"Creating group chat\");\n            let new_chat = CreateChatDTO {\n                title: body.title.clone(),\n                description: body.description.clone(),\n                chat_type: ChatType::Group,\n            };\n\n            // Validazione con validator\n            new_chat.validate()?;\n\n            chat = state.chat.create(\u0026new_chat).await?;\n\n            debug!(\"Group chat created with id {}\", chat.chat_id);\n\n            let now = Utc::now();\n            let metadata_owner = CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Owner),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            state.meta.create(\u0026metadata_owner).await?;\n            \n            info!(\"Group chat '{}' created successfully by user {}\", chat.title.as_ref().unwrap_or(\u0026String::from(\"Unnamed\")), current_user.user_id);\n        }\n    }\n\n    let chat_dto = ChatDTO::from(chat);\n    Ok(Json(chat_dto))\n}\n\n#[instrument(skip(state, metadata), fields(chat_id = %chat_id, user_id = %metadata.user_id))]\npub async fn get_chat_messages(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Query(params): Query\u003cMessagesQuery\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003cJson\u003cVec\u003cMessageDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Fetching chat messages\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Estrarre query parameters (before_date opzionale)\n    // 3. Ottenere metadata dell'utente dall'Extension (inserito dal chat_membership_middleware)\n    // 4. Se before_date presente: recuperare 50 messaggi prima di quella data\n    //    Altrimenti: recuperare ultimi 50 messaggi disponibili\n    // 5. Convertire ogni messaggio in MessageDTO (trasformazione in memoria, nessun I/O)\n    // 6. Ritornare la lista di MessageDTO come risposta JSON\n\n    let (before_date, limit) = if let Some(date) = params.before_date {\n        (Some(date), 50)\n    } else {\n        (None, 50)\n    };\n\n    let messages = state\n        .msg\n        .find_many_paginated(\n            \u0026chat_id,\n            \u0026metadata.messages_visible_from,\n            before_date.as_ref(),\n            limit,\n        )\n        .await?;\n\n    info!(\"Retrieved {} messages for chat\", messages.len());\n\n    let messages_dto: Vec\u003cMessageDTO\u003e = messages.into_iter().map(MessageDTO::from).collect();\n\n    Ok(Json(messages_dto))\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","membership.rs"],"content":"//! Membership services - Gestione membri e ruoli nelle chat\n\nuse crate::core::{AppError, AppState, require_role};\nuse crate::dtos::{\n    CreateInvitationDTO, CreateMessageDTO, CreateUserChatMetadataDTO, InvitationDTO, MessageDTO,\n    UpdateInvitationDTO, UserInChatDTO,\n};\nuse crate::entities::{ChatType, InvitationStatus, MessageType, User, UserChatMetadata, UserRole};\nuse crate::repositories::{Create, Delete, Read, Update};\nuse crate::ws::usermap::InternalSignal;\nuse axum::{\n    Extension,\n    extract::{Json, Path, State},\n};\nuse axum_macros::debug_handler;\nuse chrono::Utc;\nuse std::sync::Arc;\nuse validator::Validate;\nuse tracing::{debug, info, instrument, warn};\n\n#[instrument(skip(state, _metadata), fields(chat_id = %chat_id))]\npub async fn list_chat_members(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Extension(_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware (verifica già la membership)\n) -\u003e Result\u003cJson\u003cVec\u003cUserInChatDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing members for chat\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Ottenere metadata dell'utente dall'Extension (membership già verificata dal middleware)\n    // 3. Recuperare tutti i metadata associati alla chat tramite chat_id (singola query)\n    // 4. Estrarre tutti gli user_id dai metadata\n    // 5. Recuperare tutti gli utenti con query parallele per ogni user_id\n    // 6. Combinare le informazioni degli utenti con i metadata (join in memoria)\n    // 7. Convertire ogni combinazione in UserInChatDTO (trasformazione in memoria)\n    // 8. Ritornare la lista di UserInChatDTO come risposta JSON\n\n    let meta = state.meta.find_many_by_chat_id(\u0026chat_id).await?;\n\n    debug!(\"Found {} members in chat\", meta.len());\n\n    let user_ids: Vec\u003ci32\u003e = meta.iter().map(|m| m.user_id).collect();\n\n    let var: Vec\u003c_\u003e = user_ids.iter().map(|id| state.user.read(id)).collect();\n    let results: Vec\u003cOption\u003cUser\u003e\u003e = futures::future::try_join_all(var).await?;\n    let users: Vec\u003cUser\u003e = results.into_iter().filter_map(|u| u).collect();\n\n    let mut result: Vec\u003cUserInChatDTO\u003e = Vec::new();\n    for user in users {\n        if let Some(m) = meta.iter().find(|m| m.user_id == user.user_id) {\n            result.push(UserInChatDTO {\n                user_id: Some(user.user_id),\n                chat_id: Some(m.chat_id),\n                username: Some(user.username),\n                user_role: m.user_role.clone(),\n                member_since: Some(m.member_since),\n            });\n        }\n    }\n\n    info!(\"Successfully retrieved {} members\", result.len());\n    Ok(Json(result))\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id))]\npub async fn list_pending_invitations(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cInvitationDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing pending invitations for user\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti gli inviti pending per l'utente corrente\n    // 3. Convertire ogni invito in InvitationDTO\n    // 4. Ritornare la lista di InvitationDTO come risposta JSON\n\n    let invitations = state\n        .invitation\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?;\n\n    info!(\"Found {} pending invitations\", invitations.len());\n\n    let invitations_dto: Vec\u003cInvitationDTO\u003e =\n        invitations.into_iter().map(InvitationDTO::from).collect();\n\n    Ok(Json(invitations_dto))\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, inviting_user = %current_user.user_id, target_user = %user_id))]\npub async fn invite_to_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, user_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Inviting user to chat\");\n    // 1. Estrarre chat_id e user_id dal path, ottenere utente corrente e metadata dall'Extension\n    // 2. Verificare che current_user sia Admin o Owner tramite metadata\n    // 3. Verificare che la chat esista e sia di tipo Group (non si può invitare in chat private)\n    // 4. Verificare che l'utente target esista nel database (fail-fast su controllo basilare)\n    // 5. Verificare che l'utente target non sia già membro\n    // 6. Controllare se esiste già un invito pending\n    // 7. Creare l'invitation nel database\n    // 8. Inviare l'invitation via WebSocket all'utente invitato (se online)\n    // 9. Ritornare OK\n\n    require_role(\u0026metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    // Verificare che la chat esista e sia di tipo Group\n    let chat = state\n        .chat\n        .read(\u0026chat_id)\n        .await?\n        .ok_or_else(|| {\n            warn!(\"Chat not found: {}\", chat_id);\n            AppError::not_found(\"Chat not found\")\n        })?;\n\n    if chat.chat_type != ChatType::Group {\n        warn!(\"Attempted to invite user to private chat\");\n        return Err(AppError::bad_request(\"Cannot invite users to private chats\"));\n    }\n\n    // Verificare che l'utente target esista nel database\n    if state.user.read(\u0026user_id).await?.is_none() {\n        warn!(\"Target user not found: {}\", user_id);\n        return Err(AppError::not_found(\"User not found\"));\n    }\n\n    // Verificare che l'utente target non sia già membro\n    if state.meta.read(\u0026(user_id, chat_id)).await?.is_some() {\n        warn!(\"User {} is already a member of chat {}\", user_id, chat_id);\n        return Err(AppError::conflict(\"User is already a member of this chat\"));\n    }\n\n    // Controllare se esiste già un invito pending\n    if state\n        .invitation\n        .has_pending_invitation(\u0026user_id, \u0026chat_id)\n        .await?\n    {\n        warn!(\"Pending invitation already exists for user {} to chat {}\", user_id, chat_id);\n        return Err(AppError::conflict(\n            \"There is already a pending invitation for this user to this chat\",\n        ));\n    }\n\n    // Creare l'invitation nel database\n    let invitation = state\n        .invitation\n        .create(\u0026CreateInvitationDTO {\n            target_chat_id: chat_id,\n            invited_id: user_id,\n            invitee_id: current_user.user_id,\n        })\n        .await?;\n\n    debug!(\"Invitation created with id {}\", invitation.invite_id);\n\n    // Inviare l'invitation via WebSocket all'utente invitato (se online)\n    let invitation_dto = InvitationDTO::from(invitation);\n    state\n        .users_online\n        .send_server_message_if_online(\u0026user_id, InternalSignal::Invitation(invitation_dto));\n\n    info!(\"User successfully invited to chat\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user), fields(invite_id = %invite_id, action = %action, user_id = %current_user.user_id))]\npub async fn respond_to_invitation(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((invite_id, action)): Path\u003c(i32, String)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Responding to invitation\");\n    // 1. Estrarre invite_id e action (accept/reject) dal path\n    // 2. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 3. Validare che action sia \"accept\" o \"reject\"\n    // 4. Recuperare l'invito dal database\n    // 5. Verificare che l'invito sia pending e che current_user sia l'invitato\n    // 6. Se accept: creare metadata per aggiungere l'utente alla chat con ruolo Member\n    // 7. Se accept e utente online: inviare segnale AddChat per sottoscriversi ai messaggi\n    // 8. Aggiornare lo stato dell'invito (Accepted/Rejected)\n    // 9. Creare messaggio di sistema nella chat target con notifica appropriata\n    // 10. Salvare il messaggio dopo validazione\n    // 11. Inviare il messaggio tramite WebSocket a tutti i membri online\n    // 12. Ritornare OK\n\n    // Validare action\n    let new_status = match action.as_str() {\n        \"accept\" =\u003e InvitationStatus::Accepted,\n        \"reject\" =\u003e InvitationStatus::Rejected,\n        _ =\u003e {\n            warn!(\"Invalid invitation action: {}\", action);\n            return Err(AppError::bad_request(\"Action must be 'accept' or 'reject'\"));\n        }\n    };\n\n    // Recuperare l'invito\n    let invitation = state\n        .invitation\n        .read(\u0026invite_id)\n        .await?\n        .ok_or_else(|| {\n            warn!(\"Invitation not found: {}\", invite_id);\n            AppError::not_found(\"Invitation not found\")\n        })?;\n\n    // Verificare che sia pending\n    if invitation.state != InvitationStatus::Pending {\n        warn!(\"Invitation {} is already processed: {:?}\", invite_id, invitation.state);\n        return Err(AppError::conflict(\"Invitation is already processed\").with_details(format!(\n            \"Invitation is already {:?}\",\n            invitation.state\n        )));\n    }\n\n    // Verificare che current_user sia l'invitato\n    if invitation.invited_id != current_user.user_id {\n        warn!(\"User {} attempted to respond to invitation for user {}\", current_user.user_id, invitation.invited_id);\n        return Err(AppError::forbidden(\"You are not the recipient of this invitation\"));\n    }\n\n    let chat_id = invitation.target_chat_id;\n\n    // Se accetta, aggiungere l'utente alla chat\n    if matches!(new_status, InvitationStatus::Accepted) {\n        debug!(\"User accepted invitation, adding to chat {}\", chat_id);\n        let now = Utc::now();\n        state\n            .meta\n            .create(\u0026CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            })\n            .await?;\n\n        // Se l'utente è online, inviare segnale AddChat per sottoscriversi ai messaggi della chat\n        state\n            .users_online\n            .send_server_message_if_online(\u0026current_user.user_id, InternalSignal::AddChat(chat_id));\n    } else {\n        debug!(\"User rejected invitation\");\n    }\n\n    // Aggiornare lo stato dell'invito\n    state\n        .invitation\n        .update(\n            \u0026invite_id,\n            \u0026UpdateInvitationDTO {\n                state: Some(new_status.clone()),\n            },\n        )\n        .await?;\n\n    // Creare messaggio di sistema appropriato\n    let content = if matches!(new_status, InvitationStatus::Accepted) {\n        format!(\"User {} has joined the chat\", current_user.username)\n    } else {\n        format!(\"User {} has declined the invitation\", current_user.username)\n    };\n\n    let create_dto = CreateMessageDTO {\n        chat_id,\n        sender_id: current_user.user_id,\n        content,\n        message_type: MessageType::SystemMessage,\n        created_at: Utc::now(),\n    };\n\n    create_dto\n        .validate()\n        .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state\n        .chats_online\n        .send(\u0026chat_id, Arc::new(MessageDTO::from(saved_message)));\n    \n    info!(\"Invitation response processed successfully\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, user_id = %current_user.user_id))]\npub async fn leave_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"User leaving chat\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare il ruolo: se è Owner, ritornare errore CONFLICT con messaggio specifico (fail-fast, controllo in memoria)\n    // 4. Cancellare i metadata di current_user per questa chat dal database\n    // 5. Se utente online: inviare segnale RemoveChat per disiscriversi dai messaggi della chat\n    // 6. Creare un messaggio di sistema che notifica l'uscita (i messaggi dell'utente rimangono nel DB)\n    // 7. Salvare il messaggio nel database\n    // 8. Inviare il messaggio tramite WebSocket a tutti i membri online (operazione non bloccante)\n    // 9. Ritornare StatusCode::OK\n\n    // L'Owner non può lasciare la chat\n    if matches!(metadata.user_role, Some(UserRole::Owner)) {\n        warn!(\"Owner attempted to leave chat\");\n        return Err(AppError::conflict(\n            \"The owner cannot leave the chat. Transfer ownership or delete the chat.\",\n        ));\n    }\n\n    state.meta.delete(\u0026(current_user.user_id, chat_id)).await?;\n\n    // Se l'utente è online, inviare segnale RemoveChat per disiscriversi dai messaggi della chat\n    state\n        .users_online\n        .send_server_message_if_online(\u0026current_user.user_id, InternalSignal::RemoveChat(chat_id));\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\"User {} has left the chat\", current_user.username)),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n    .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n    .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"User successfully left chat\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, current_metadata), fields(chat_id = %chat_id, removing_user = %current_user.user_id, target_user = %user_id))]\npub async fn remove_member(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, user_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(current_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Removing member from chat\");\n    // 1. Estrarre chat_id e user_id dal path dalla URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Admin o Owner, altrimenti ritornare errore FORBIDDEN (fail-fast)\n    // 4. Recuperare metadata dell'utente target per verificare membership (singola query)\n    // 5. Verificare che non si stia cercando di rimuovere l'Owner, altrimenti ritornare errore FORBIDDEN (controllo in memoria)\n    // 6. Cancellare i metadata dell'utente target per questa chat dal database\n    // 7. Creare un messaggio di sistema che notifica la rimozione del membro (i messaggi dell'utente rimangono nel DB)\n    // 8. Salvare il messaggio nel database dopo validazione\n    // 9. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 10. Ritornare StatusCode::OK\n\n    require_role(\u0026current_metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    let target_meta = state.meta.read(\u0026(user_id, chat_id)).await?.ok_or_else(|| {\n        warn!(\"Target user {} is not a member of chat {}\", user_id, chat_id);\n        AppError::not_found(\"The user to be removed is not a member of this chat\")\n    })?;\n\n    // Non si può rimuovere l'Owner\n    if matches!(target_meta.user_role, Some(UserRole::Owner)) {\n        warn!(\"Attempted to remove owner from chat\");\n        return Err(AppError::forbidden(\"You cannot remove the owner of the chat\"));\n    }\n\n    state.meta.delete(\u0026(user_id, chat_id)).await?;\n\n    let target_user_opt = state.user.read(\u0026user_id).await?;\n\n    let target_username = target_user_opt\n        .as_ref()\n        .map(|u| u.username.clone())\n        .unwrap_or_else(|| \"Unknown User\".to_string());\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has removed {} from the chat\",\n            current_user.username, target_username\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n        .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n        .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Member successfully removed from chat\");\n    Ok(())\n}\n\n#[debug_handler]\n#[instrument(skip(state, current_user, current_metadata, body), fields(chat_id = %chat_id, updating_user = %current_user.user_id, target_user = %user_id, new_role = ?body))]\npub async fn update_member_role(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((user_id, chat_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(current_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n    Json(body): Json\u003cUserRole\u003e,\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Updating member role in chat\");\n    // 1. Estrarre user_id e chat_id dal path della URL, nuovo ruolo dal body JSON\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Admin o Owner, altrimenti ritornare errore FORBIDDEN (fail-fast)\n    // 4. Recuperare metadata dell'utente target per verificare membership (singola query)\n    // 5. Verificare le regole di promozione: Owner può modificare tutti, Admin può modificare solo Member (controllo in memoria)\n    // 6. Admin non può assegnare ruolo Owner (controllo in memoria)\n    // 7. Aggiornare il campo user_role nei metadata dell'utente target\n    // 8. Creare un messaggio di sistema che notifica il cambio di ruolo\n    // 9. Salvare il messaggio nel database dopo validazione\n    // 10. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 11. Ritornare StatusCode::OK\n\n    require_role(\u0026current_metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    let target_meta = state.meta.read(\u0026(user_id, chat_id)).await?.ok_or_else(|| {\n        warn!(\"Target user {} is not a member of chat {}\", user_id, chat_id);\n        AppError::not_found(\n            \"The user whose role is to be changed is not a member of this chat\",\n        )\n    })?;\n\n    match current_metadata.user_role {\n        Some(UserRole::Admin) =\u003e {\n            // Admin può modificare solo Member\n            match target_meta.user_role {\n                Some(UserRole::Member) =\u003e { /* ok */ }\n                _ =\u003e {\n                    warn!(\"Admin attempted to modify non-member role\");\n                    return Err(AppError::forbidden(\"Admin can modify only members\"));\n                }\n            }\n\n            // Admin non può assegnare Owner\n            match body {\n                UserRole::Owner =\u003e {\n                    warn!(\"Admin attempted to assign owner role\");\n                    return Err(AppError::forbidden(\"Only Owner can assign ownership\"));\n                }\n                _ =\u003e { /* ok */ }\n            }\n        }\n        _ =\u003e { /* current user non-admin: altre regole già gestite sopra */ }\n    }\n\n    state\n        .meta\n        .update_user_role(\u0026user_id, \u0026chat_id, \u0026body)\n        .await?;\n\n    let target_user_opt = state.user.read(\u0026user_id).await?;\n\n    let target_username = target_user_opt\n        .as_ref()\n        .map(|u| u.username.clone())\n        .unwrap_or_else(|| \"Unknown User\".to_string());\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has changed {}'s role to {:?}\",\n            current_user.username, target_username, body\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n    .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n    .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Member role updated successfully\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, current_owner = %current_user.user_id, new_owner = %new_owner_id))]\npub async fn transfer_ownership(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, new_owner_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Transferring chat ownership\");\n    // 1. Estrarre chat_id e new_owner_id dal path della URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Owner tramite metadata\n    // 4. Verificare che current_user non stia trasferendo a se stesso (controllo in memoria)\n    // 5. Verificare che la chat esista e sia di tipo Group (le chat private non hanno owner)\n    // 6. Verificare che il nuovo owner esista come utente nel sistema\n    // 7. Trasferire ownership con metodo atomico: current_user diventa Admin, new_owner diventa Owner\n    // 8. Creare un messaggio di sistema che notifica il trasferimento di ownership\n    // 9. Salvare il messaggio nel database dopo validazione\n    // 10. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 11. Ritornare StatusCode::OK\n\n    require_role(\u0026metadata, \u0026[UserRole::Owner])?;\n\n    if current_user.user_id == new_owner_id {\n        warn!(\"Attempted to transfer ownership to self\");\n        return Err(AppError::bad_request(\n            \"Cannot transfer ownership to yourself\",\n        ));\n    }\n\n    let chat = state.chat.read(\u0026chat_id).await?;\n\n    if let Some(chat_data) = chat {\n        if chat_data.chat_type != ChatType::Group {\n            warn!(\"Attempted to transfer ownership of private chat\");\n            return Err(AppError::bad_request(\n                \"Cannot transfer ownership of private chats\",\n            ));\n        }\n    } else {\n        warn!(\"Chat not found: {}\", chat_id);\n        return Err(AppError::not_found(\"Chat not found\"));\n    }\n\n    let new_owner_user = state.user.read(\u0026new_owner_id).await?;\n\n    let new_owner_username = match new_owner_user {\n        Some(user) =\u003e user.username,\n        None =\u003e {\n            warn!(\"New owner user not found: {}\", new_owner_id);\n            return Err(AppError::not_found(\"New owner user not found\"));\n        }\n    };\n\n    debug!(\"Performing ownership transfer\");\n    // Trasferisce la proprietà dal current_user al nuovo owner\n    state\n        .meta\n        .transfer_ownership(\u0026current_user.user_id, \u0026new_owner_id, \u0026chat_id)\n        .await?;\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has transferred ownership to {}\",\n            current_user.username, new_owner_username\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n        .map_err(|e| AppError::bad_request(\"Failed to build message dto\").with_details(e.to_string()))?;\n\n    create_dto\n        .validate()\n        .map_err(|e| AppError::bad_request(\"Validation error\").with_details(e.to_string()))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Ownership transferred successfully\");\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","mod.rs"],"content":"//! Services module - Coordinatore per tutti i service handler HTTP\r\n//!\r\n//! Questo modulo organizza i service handlers in sotto-moduli separati per una migliore manutenibilità.\r\n//! Ogni modulo gestisce gli endpoint HTTP per una specifica funzionalità.\r\n\r\npub mod auth;\r\npub mod chat;\r\npub mod membership;\r\npub mod user;\r\n\r\n// Re-exports per facilitare l'import\r\npub use auth::{login_user, register_user};\r\npub use chat::{create_chat, get_chat_messages, list_chats};\r\npub use membership::{\r\n    invite_to_chat, leave_chat, list_chat_members, list_pending_invitations, remove_member,\r\n    respond_to_invitation, transfer_ownership, update_member_role,\r\n};\r\npub use user::{delete_my_account, get_user_by_id, search_user_with_username};\r\n\r\nuse crate::AppState;\r\nuse axum::{extract::State, http::StatusCode, response::IntoResponse};\r\nuse std::sync::Arc;\r\n\r\n/// Root endpoint - health check\r\npub async fn root(State(_state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\r\n    (StatusCode::OK, \"Server is running!\")\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","user.rs"],"content":"//! User services - Gestione utenti\n\nuse crate::core::{AppError, AppState};\nuse crate::dtos::{UserDTO, UserSearchQuery};\nuse crate::entities::{User, UserRole};\nuse crate::repositories::{Delete, Read};\nuse axum::{\n    Extension,\n    extract::{Json, Path, Query, State},\n    http::{HeaderMap, HeaderValue, StatusCode},\n    response::IntoResponse,\n};\nuse futures::future;\nuse std::sync::Arc;\nuse tracing::{debug, info, instrument, warn};\n\n#[instrument(skip(state), fields(search = %params.search))]\npub async fn search_user_with_username(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Query(params): Query\u003cUserSearchQuery\u003e, // query params /users/find?search=username\n) -\u003e Result\u003cJson\u003cVec\u003cUserDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Searching users with partial username\");\n    // 1. Estrarre il parametro search dalla query string\n    // 2. Cercare nel database tutti gli utenti con username che contiene parzialmente la query, cercando solo all'inizio dello username\n    // 3. Convertire ogni utente trovato in UserDTO\n    // 4. Ritornare la lista di UserDTO come risposta JSON\n    let users = state\n        .user\n        .search_by_username_partial(\u0026(params.search))\n        .await?;\n    info!(\"Found {} users matching search criteria\", users.len());\n    let users_dto = users.into_iter().map(UserDTO::from).collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(Json::from(users_dto))\n}\n\n#[instrument(skip(state), fields(user_id = %user_id))]\npub async fn get_user_by_id(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(user_id): Path\u003ci32\u003e, // parametro dalla URL /users/:user_id\n) -\u003e Result\u003cJson\u003cOption\u003cUserDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Fetching user by ID\");\n    // 1. Estrarre user_id dal path della URL\n    // 2. Cercare l'utente nel database tramite user_id\n    // 3. Se l'utente esiste, convertirlo in UserDTO\n    // 4. Ritornare Option\u003cUserDTO\u003e come risposta JSON (Some se trovato, None se non trovato)\n    let user_option = state.user.read(\u0026user_id).await?;\n    if user_option.is_some() {\n        info!(\"User found\");\n    } else {\n        warn!(\"User not found\");\n    }\n    Ok(Json(user_option.map(UserDTO::from)))\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id, username = %current_user.username))]\npub async fn delete_my_account(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione tramite token jwt\n) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n    info!(\"User account deletion initiated\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti i metadata dell'utente per identificare chat ownership (singola query)\n    let user_metadata = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?;\n\n    debug!(\"Found {} chat memberships for user\", user_metadata.len());\n\n    // 3. Gestire il caso degli ownership: se l'utente è owner di gruppi\n    for metadata in \u0026user_metadata {\n        if matches!(metadata.user_role, Some(UserRole::Owner)) {\n            debug!(\"Handling ownership transfer for chat {}\", metadata.chat_id);\n            // Recuperare tutti i membri della chat\n            let chat_members = state.meta.find_many_by_chat_id(\u0026metadata.chat_id).await?;\n\n            if chat_members.len() == 1 {\n                // Se l'owner è l'unico membro, cancellare la chat completamente\n                // ON DELETE CASCADE cancellerà automaticamente i metadata e i messaggi\n                info!(\"Deleting chat {} (user is the only member)\", metadata.chat_id);\n                state.chat.delete(\u0026metadata.chat_id).await?;\n            } else {\n                // Cercare un admin a cui trasferire l'ownership\n                let new_owner = chat_members\n                    .iter()\n                    .find(|m| {\n                        m.user_id != current_user.user_id\n                            \u0026\u0026 matches!(m.user_role, Some(UserRole::Admin))\n                    })\n                    .or_else(|| {\n                        // Se non c'è un admin, prendi qualsiasi altro membro\n                        chat_members\n                            .iter()\n                            .find(|m| m.user_id != current_user.user_id)\n                    });\n\n                if let Some(new_owner) = new_owner {\n                    // Trasferire l'ownership\n                    info!(\"Transferring ownership of chat {} to user {}\", metadata.chat_id, new_owner.user_id);\n                    state\n                        .meta\n                        .transfer_ownership(\n                            \u0026current_user.user_id,\n                            \u0026new_owner.user_id,\n                            \u0026metadata.chat_id,\n                        )\n                        .await?;\n                }\n            }\n        }\n    }\n\n    // 4. Cancellare tutti i metadata (UserChatMetadata) associati all'utente\n    // (solo per le chat non eliminate al punto 3 - quelle erano già cancellate da CASCADE)\n    // Raccogliere le chiavi per la cancellazione\n\n    let meta_ids: Vec\u003c(i32, i32)\u003e = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?\n        .into_iter()\n        .map(|m| (m.user_id, m.chat_id))\n        .collect();\n\n    debug!(\"Deleting {} metadata entries\", meta_ids.len());\n    // Cancellazione effettiva\n    future::join_all(meta_ids.iter().map(|k| state.meta.delete(\u0026k))).await;\n\n    // 5-6. Rinominare lo username dell'utente con \"Deleted User\" e sostituire la password con stringa vuota\n    info!(\"Soft deleting user account\");\n    state.user.delete(\u0026current_user.user_id).await?;\n\n    // 7-8. Creare un cookie con Max-Age=0 per forzare il logout lato client\n    let cookie = \"token=; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=0\";\n    let mut headers = HeaderMap::new();\n    headers.insert(\"Set-Cookie\", HeaderValue::from_str(cookie).unwrap());\n\n    // 9. Ritornare StatusCode::OK con gli headers e messaggio\n    info!(\"Account deleted successfully\");\n    Ok((StatusCode::OK, headers, \"Account deleted successfully\"))\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","chatmap.rs"],"content":"use crate::dtos::MessageDTO;\r\nuse crate::ws::BROADCAST_CHANNEL_CAPACITY;\r\nuse dashmap::DashMap;\r\nuse std::sync::Arc;\r\nuse tokio::sync::broadcast;\r\nuse tokio::sync::broadcast::error::SendError;\r\nuse tokio::sync::broadcast::{Receiver, Sender};\r\nuse tracing::{info, instrument, warn};\r\n\r\npub struct ChatMap {\r\n    /// Attribute to retrieve the tx head og a broadcast channel by chat_id field\r\n    channels: DashMap\u003ci32, Sender\u003cArc\u003cMessageDTO\u003e\u003e\u003e,\r\n}\r\n\r\nimpl ChatMap {\r\n    pub fn new() -\u003e Self {\r\n        ChatMap {\r\n            channels: DashMap::new(),\r\n        }\r\n    }\r\n\r\n    #[instrument(skip(self), fields(chat_id))]\r\n    pub fn subscribe(\u0026self, chat_id: \u0026i32) -\u003e Receiver\u003cArc\u003cMessageDTO\u003e\u003e {\r\n        match self.channels.get(chat_id) {\r\n            // required subscription on non existing chat channel\r\n            None =\u003e {\r\n                info!(\"Creating new broadcast channel for chat\");\r\n                // Arc\u003cMessage\u003e to share the ref, not the message. Avoid unuseful copies of message on each rx.\r\n                let (tx, rx) = broadcast::channel::\u003cArc\u003cMessageDTO\u003e\u003e(BROADCAST_CHANNEL_CAPACITY);\r\n                self.channels.insert(*chat_id, tx);\r\n                rx\r\n            }\r\n            // subscribe to an existing channel == get a rx head == subscribe to a tx\r\n            Some(c) =\u003e {\r\n                info!(\"Subscribing to existing broadcast channel\");\r\n                c.value().subscribe()\r\n            }\r\n        }\r\n    }\r\n\r\n    #[instrument(skip(self, chat_ids))]\r\n    pub fn subscribe_multiple(\u0026self, chat_ids: Vec\u003ci32\u003e) -\u003e Vec\u003cReceiver\u003cArc\u003cMessageDTO\u003e\u003e\u003e {\r\n        info!(count = chat_ids.len(), \"Subscribing to multiple chats\");\r\n        chat_ids.into_iter().map(|id| self.subscribe(\u0026id)).collect()\r\n    }\r\n\r\n    #[instrument(skip(self, msg), fields(chat_id))]\r\n    pub fn send(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n        msg: Arc\u003cMessageDTO\u003e,\r\n    ) -\u003e Result\u003cusize, SendError\u003cArc\u003cMessageDTO\u003e\u003e\u003e {\r\n        if let Some(chat) = self.channels.get(chat_id) {\r\n            match chat.send(msg.clone()) {\r\n                Ok(n) =\u003e {\r\n                    info!(receivers = n, \"Message broadcast to receivers\");\r\n                    Ok(n)\r\n                }\r\n                Err(e) =\u003e {\r\n                    warn!(\"No active receivers, removing channel\");\r\n                    // Nessuno sta ascoltando, rimuovi il channel\r\n                    drop(chat); // Rilascia il lock\r\n                    self.channels.remove(chat_id);\r\n                    Err(e)\r\n                }\r\n            }\r\n        } else {\r\n            warn!(\"Attempted to send to non-existent chat channel\");\r\n            Err(SendError(msg))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","connection.rs"],"content":"//! WebSocket Connection Management - Gestione connessioni WebSocket\r\n\r\nuse crate::ws::{BATCH_INTERVAL, BATCH_MAX_SIZE, RATE_LIMITER_MILLIS, TIMEOUT_DURATION_SECONDS};\r\nuse crate::{\r\n    AppState,\r\n    dtos::MessageDTO,\r\n    ws::{event_handlers::process_message, usermap::InternalSignal},\r\n};\r\nuse axum::extract::ws::Utf8Bytes;\r\nuse axum::extract::ws::{Message, WebSocket};\r\nuse futures_util::stream::{SplitSink, SplitStream};\r\nuse futures_util::{SinkExt, StreamExt};\r\nuse std::{sync::Arc};\r\nuse tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, unbounded_channel};\r\nuse tokio::time::Duration;\r\nuse tokio::time::{interval, timeout};\r\nuse tokio_stream::StreamMap;\r\nuse tokio_stream::wrappers::BroadcastStream;\r\nuse tracing::{error, info, instrument, warn};\r\n\r\n#[instrument(skip(ws, state), fields(user_id))]\r\npub async fn handle_socket(ws: WebSocket, state: Arc\u003cAppState\u003e, user_id: i32) {\r\n    info!(\"WebSocket connection established\");\r\n\r\n    // Dividiamo il WebSocket in due metà: sender e receiver\r\n    let (ws_tx, ws_rx) = ws.split();\r\n\r\n    // Creiamo un canale unbounded per comunicazione interna\r\n    // considerare passaggio a unbounded channel per non perdere eventuali segnali\r\n    let (int_tx, int_rx) = unbounded_channel::\u003cInternalSignal\u003e();\r\n\r\n    // Salviamo nello stato il trasmettitore di watch associato all'utente\r\n    // Il ricevitore sarà usato dal task dedicato alla scrittura\r\n    state.users_online.register_online(user_id, int_tx.clone());\r\n    info!(\"User registered as online\");\r\n\r\n    // dobbiamo iniziare un task che stia in ascolto del websocket\r\n    tokio::spawn(listen_ws(user_id, ws_rx, int_tx.clone(), state.clone()));\r\n\r\n    // creare un task che sta in ascolto sull'insieme dei canali broadcast\r\n    tokio::spawn(write_ws(user_id, ws_tx, int_rx, state));\r\n}\r\n\r\n#[instrument(skip(websocket_tx, internal_rx, state), fields(user_id))]\r\npub async fn write_ws(\r\n    user_id: i32,\r\n    mut websocket_tx: SplitSink\u003cWebSocket, Message\u003e,\r\n    mut internal_rx: UnboundedReceiver\u003cInternalSignal\u003e,\r\n    state: Arc\u003cAppState\u003e,\r\n) {\r\n    info!(\"Write task started\");\r\n\r\n    let chat_vec: Vec\u003ci32\u003e = match state.meta.find_many_by_user_id(\u0026user_id).await {\r\n        Ok(chats) =\u003e {\r\n            info!(chat_count = chats.len(), \"User chats loaded\");\r\n            chats.iter().map(|m| m.chat_id).collect()\r\n        }\r\n        Err(e) =\u003e {\r\n            error!(\"Failed to load user chats: {:?}\", e);\r\n            return; // Termina se DB fallisce\r\n        }\r\n    };\r\n\r\n    let mut stream_map = StreamMap::new();\r\n\r\n    state\r\n        .chats_online\r\n        .subscribe_multiple(chat_vec.clone())\r\n        .into_iter()\r\n        .zip(chat_vec.iter())\r\n        .for_each(|(rx, \u0026chat_id)| {\r\n            stream_map.insert(chat_id, BroadcastStream::new(rx));\r\n        });\r\n\r\n    let mut batch: Vec\u003cArc\u003cMessageDTO\u003e\u003e = Vec::new();\r\n    let mut interval = tokio::time::interval(Duration::from_millis(BATCH_INTERVAL));\r\n    interval.tick().await; // Consuma primo tick immediato\r\n\r\n    'external: loop {\r\n        tokio::select! {\r\n            Some((_, result)) = tokio_stream::StreamExt::next(\u0026mut stream_map) =\u003e {\r\n                if let Ok(msg) = result {\r\n                    batch.push(msg);\r\n                    if batch.len() \u003e= BATCH_MAX_SIZE {\r\n                        if send_batch(\u0026mut websocket_tx, \u0026batch).await.is_err() {\r\n                            warn!(\"Failed to send batch, closing connection\");\r\n                            break 'external;\r\n                        }\r\n                        info!(batch_size = batch.len(), \"Batch sent\");\r\n                        batch.clear();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // serve per fare in modo di inviare dei messaggi anche se il batch non è arrivato a 10\r\n            // altrimenti aspetterei troppo\r\n            _ = interval.tick() =\u003e {\r\n                if !batch.is_empty() {\r\n                    if send_batch(\u0026mut websocket_tx, \u0026batch).await.is_err() {\r\n                        warn!(\"Failed to send batch on interval, closing connection\");\r\n                        break 'external;\r\n                    }\r\n                    info!(batch_size = batch.len(), \"Batch sent on interval\");\r\n                    batch.clear();\r\n                }\r\n            }\r\n\r\n            signal = internal_rx.recv() =\u003e {\r\n                match signal {\r\n                    Some(InternalSignal::Shutdown) =\u003e {\r\n                        info!(\"Shutdown signal received\");\r\n                        break 'external;\r\n                    }\r\n                    Some(InternalSignal::AddChat(chat_id)) =\u003e {\r\n                        info!(chat_id, \"Adding chat subscription\");\r\n                        let rx = state.chats_online.subscribe(\u0026chat_id);\r\n                        stream_map.insert(chat_id, BroadcastStream::new(rx));\r\n                    }\r\n                    Some(InternalSignal::RemoveChat(chat_id)) =\u003e {\r\n                        info!(chat_id, \"Removing chat subscription\");\r\n                        stream_map.remove(\u0026chat_id);\r\n                    }\r\n                    Some(InternalSignal::Error(err_msg)) =\u003e {\r\n                        warn!(error_message = err_msg, \"Sending error message to client\");\r\n                        if let Err(e) = websocket_tx.send(Message::Text(Utf8Bytes::from(err_msg))).await {\r\n                            error!(\"Failed to send error message: {:?}\", e);\r\n                            break;\r\n                        }\r\n                    }\r\n                    Some(InternalSignal::Invitation(invitation)) =\u003e {\r\n                        info!(invite_id = invitation.invite_id, \"Sending invitation to client\");\r\n                        if let Ok(json) = serde_json::to_string(\u0026invitation) {\r\n                            if let Err(e) = websocket_tx.send(Message::Text(Utf8Bytes::from(json))).await {\r\n                                error!(\"Failed to send invitation: {:?}\", e);\r\n                                break 'external;\r\n                            }\r\n                        } else {\r\n                            error!(\"Failed to serialize invitation\");\r\n                        }\r\n                    }\r\n                    None =\u003e {\r\n                        info!(\"Internal channel closed\");\r\n                        break 'external; // canale chiuso, quindi listener ws chius, quindi stacca tutto\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Invia batch finale prima di terminare\r\n    if !batch.is_empty() {\r\n        info!(\r\n            batch_size = batch.len(),\r\n            \"Sending final batch before shutdown\"\r\n        );\r\n        let _ = send_batch(\u0026mut websocket_tx, \u0026batch).await;\r\n    }\r\n\r\n    info!(\"Write task terminated\");\r\n}\r\n\r\n#[instrument(skip(websocket_tx, batch))]\r\nasync fn send_batch(\r\n    websocket_tx: \u0026mut SplitSink\u003cWebSocket, Message\u003e,\r\n    batch: \u0026[Arc\u003cMessageDTO\u003e],\r\n) -\u003e Result\u003c(), axum::Error\u003e {\r\n    let json = serde_json::to_string(\u0026batch).map_err(|e| {\r\n        error!(\"Failed to serialize batch: {:?}\", e);\r\n        axum::Error::new(e)\r\n    })?;\r\n    websocket_tx\r\n        .send(Message::Text(Utf8Bytes::from(json)))\r\n        .await\r\n        .map_err(|e| {\r\n            error!(\"Failed to send batch through WebSocket: {:?}\", e);\r\n            e\r\n        })\r\n}\r\n\r\n#[instrument(skip(websocket_rx, internal_tx, state), fields(user_id))]\r\npub async fn listen_ws(\r\n    user_id: i32,\r\n    mut websocket_rx: SplitStream\u003cWebSocket\u003e,\r\n    internal_tx: UnboundedSender\u003cInternalSignal\u003e,\r\n    state: Arc\u003cAppState\u003e,\r\n) {\r\n    info!(\"Listen task started\");\r\n\r\n    let mut rate_limiter = interval(Duration::from_millis(RATE_LIMITER_MILLIS));\r\n    let timeout_duration = Duration::from_secs(TIMEOUT_DURATION_SECONDS);\r\n\r\n    loop {\r\n        match timeout(timeout_duration, StreamExt::next(\u0026mut websocket_rx)).await {\r\n            Ok(Some(msg_result)) =\u003e {\r\n                rate_limiter.tick().await;\r\n\r\n                let msg = match msg_result {\r\n                    Ok(m) =\u003e m,\r\n                    Err(e) =\u003e {\r\n                        warn!(\"WebSocket error: {:?}\", e);\r\n                        break;\r\n                    }\r\n                };\r\n\r\n                match msg {\r\n                    Message::Text(text) =\u003e {\r\n                        if let Ok(event) = serde_json::from_str::\u003cMessageDTO\u003e(\u0026text) {\r\n                            info!(\"Message received from client\");\r\n                            process_message(\u0026state, user_id, event).await;\r\n                        } else {\r\n                            warn!(\"Failed to deserialize message\");\r\n                        }\r\n                    }\r\n                    Message::Close(_) =\u003e {\r\n                        info!(\"Close message received\");\r\n                        break;\r\n                    }\r\n                    _ =\u003e {}\r\n                }\r\n            }\r\n            Ok(None) =\u003e {\r\n                info!(\"WebSocket stream ended\");\r\n                break;\r\n            }\r\n            Err(_) =\u003e {\r\n                warn!(\r\n                    timeout_secs = TIMEOUT_DURATION_SECONDS,\r\n                    \"Connection timeout\"\r\n                );\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cleanup\r\n    info!(\"Cleaning up connection\");\r\n    let _ = internal_tx.send(InternalSignal::Shutdown);\r\n    state.users_online.remove_from_online(\u0026user_id);\r\n    info!(\"Listen task terminated\");\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","event_handlers.rs"],"content":"//! WebSocket Event Handlers - Handler per eventi WebSocket\r\n\r\nuse tracing::{error, info, instrument, warn};\r\nuse validator::Validate;\r\n\r\nuse crate::AppState;\r\nuse crate::dtos::{CreateMessageDTO, MessageDTO};\r\nuse crate::entities::MessageType;\r\nuse crate::repositories::{Create, Read};\r\nuse crate::ws::usermap::InternalSignal;\r\nuse std::sync::Arc;\r\n\r\n#[instrument(skip(state, msg), fields(user_id, chat_id = msg.chat_id))]\r\npub async fn process_message(state: \u0026Arc\u003cAppState\u003e, user_id: i32, msg: MessageDTO) {\r\n    info!(\"Processing message from user\");\r\n\r\n    let input_message = match CreateMessageDTO::try_from(msg.clone()) {\r\n        Ok(msg) =\u003e msg,\r\n        Err(e) =\u003e {\r\n            warn!(\"Malformed message received: {:?}\", e);\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"Malformed message.\"),\r\n            );\r\n            return;\r\n        }\r\n    };\r\n\r\n    if let Err(e) = input_message.validate() {\r\n        warn!(\"Message validation failed: {:?}\", e);\r\n        state\r\n            .users_online\r\n            .send_server_message_if_online(\u0026user_id, InternalSignal::Error(\"Malformed message.\"));\r\n        return;\r\n    };\r\n\r\n    if input_message.message_type == MessageType::SystemMessage {\r\n        warn!(\"User attempted to send system message\");\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\"You cannot send system type messages.\"),\r\n        );\r\n        return;\r\n    }\r\n\r\n    // se la chat non esistesse, allora non esisterebbe neanche il metadata, quindi non controllo l'esistenza della chat.\r\n    match state.meta.read(\u0026(user_id, input_message.chat_id)).await {\r\n        Ok(Some(val)) =\u003e val,\r\n        Ok(None) =\u003e {\r\n            warn!(\r\n                chat_id = input_message.chat_id,\r\n                \"User does not belong to chat\"\r\n            );\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"You don't belong to that group.\"),\r\n            );\r\n            return;\r\n        }\r\n        Err(e) =\u003e {\r\n            error!(\"Failed to read user metadata: {:?}\", e);\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"Internal server error.\"),\r\n            );\r\n            return;\r\n        }\r\n    };\r\n\r\n    // bene, l'utente appartiene alla chat, quindi può inviare il messaggio\r\n    // invio prima ad utenti online\r\n    if let Err(e) = state\r\n        .chats_online\r\n        .send(\u0026input_message.chat_id, Arc::from(msg))\r\n    {\r\n        error!(\r\n            chat_id = input_message.chat_id,\r\n            \"Failed to broadcast message to online users: {:?}\", e\r\n        );\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\"Internal server error.\"),\r\n        );\r\n    }\r\n\r\n    // salvo in db per utenti offline\r\n    if let Err(e) = state.msg.create(\u0026input_message).await {\r\n        error!(\"Failed to persist message to database: {:?}\", e);\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\r\n                \"Something went wrong and your message was not stored correctly!\",\r\n            ),\r\n        );\r\n    } else {\r\n        info!(\"Message processed and stored successfully\");\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","mod.rs"],"content":"//! WebSocket Module - Gestione WebSocket per comunicazione real-time\r\n//!\r\n//! Questo modulo gestisce le connessioni WebSocket per la comunicazione in tempo reale\r\n//! tra client e server. Include:\r\n//! - Gestione upgrade HTTP -\u003e WebSocket\r\n//! - Gestione connessioni (split sender/receiver)\r\n//! - Handler per eventi WebSocket (messaggi, inviti)\r\n//! - Utility per broadcasting e invio errori\r\n\r\npub mod chatmap;\r\npub mod connection;\r\npub mod event_handlers;\r\npub mod usermap;\r\n\r\n// Re-exports pubblici\r\npub use connection::handle_socket;\r\n\r\nuse crate::{AppState, entities::User};\r\nuse axum::{\r\n    Extension,\r\n    extract::{State, ws::WebSocketUpgrade},\r\n    response::Response,\r\n};\r\nuse std::sync::Arc;\r\nuse tracing::{info, instrument};\r\n\r\n// how many messages should the channel contain?\r\nconst BROADCAST_CHANNEL_CAPACITY: usize = 100;\r\n\r\n/// Intervallo massimo tra invii batch (ms)\r\nconst BATCH_INTERVAL: u64 = 1000;\r\n\r\n/// Numero massimo di messaggi per batch\r\nconst BATCH_MAX_SIZE: usize = 10;\r\n\r\n/// Delay minimo tra messaggi client (ms) - max 100 msg/sec\r\nconst RATE_LIMITER_MILLIS: u64 = 10;\r\n\r\n/// Timeout inattività prima di chiudere connessione (secondi)\r\nconst TIMEOUT_DURATION_SECONDS: u64 = 300;\r\n\r\n/// Entry point per gestire richieste di upgrade WebSocket\r\n/// Operazioni:\r\n/// 1. Estrarre user_id dall'autenticazione JWT\r\n/// 2. Eseguire upgrade HTTP -\u003e WebSocket\r\n/// 3. Passare la connessione ad handle_socket\r\n#[instrument(skip(ws, state, current_user), fields(user_id = current_user.user_id))]\r\npub async fn ws_handler(\r\n    ws: WebSocketUpgrade,\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione JWT\r\n) -\u003e Response {\r\n    let user_id = current_user.user_id;\r\n    info!(\"WebSocket upgrade requested\");\r\n\r\n    // Gestisce automaticamente l'upgrade a WebSocket.\r\n    // Se l'upgrade fallisce, ritorna un errore; altrimenti restituisce la nuova connessione al client.\r\n\r\n    ws\r\n        // Possibile limitazione dei buffer, default 128 KB\r\n        //.read_buffer_size(4*1024)\r\n        //.write_buffer_size(16*1024)\r\n        .on_upgrade(move |socket| handle_socket(socket, state, user_id))\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","usermap.rs"],"content":"use dashmap::DashMap;\nuse tokio::sync::mpsc::{UnboundedSender};\nuse tracing::{info, instrument, warn};\n\nuse crate::dtos::{InvitationDTO};\n\npub enum InternalSignal {\n    Shutdown,\n    AddChat(i32),\n    RemoveChat(i32),\n    Error(\u0026'static str),\n    Invitation(InvitationDTO),\n}\n\npub struct UserMap {\n    users_online: DashMap\u003ci32, UnboundedSender\u003cInternalSignal\u003e\u003e,\n}\n\nimpl UserMap {\n    pub fn new() -\u003e Self {\n        UserMap {\n            users_online: DashMap::new(),\n        }\n    }\n\n    #[instrument(skip(self, tx), fields(user_id))]\n    pub fn register_online(\u0026self, user_id: i32, tx: UnboundedSender\u003cInternalSignal\u003e) {\n        info!(\"Registering user as online\");\n        self.users_online.insert(user_id, tx);\n    }\n\n    #[instrument(skip(self), fields(user_id))]\n    pub fn remove_from_online(\u0026self, user_id: \u0026i32) {\n        info!(\"Removing user from online\");\n        self.users_online.remove(\u0026user_id);\n    }\n\n    #[instrument(skip(self, message), fields(user_id))]\n    pub fn send_server_message_if_online(\u0026self, user_id: \u0026i32, message: InternalSignal) {\n        if let Some(entry) = self.users_online.get(\u0026user_id) {\n            let tx = entry.value();\n            if let Err(e) = tx.send(message) {\n                warn!(\"Failed to send message to user: {:?}\", e);\n            } else {\n                info!(\"Message sent to online user\");\n            }\n        } else {\n            info!(\"User not online, message not sent\");\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_auth.rs"],"content":"//! Integration tests per gli endpoints di autenticazione\r\n//!\r\n//! Test per:\r\n//! - POST /auth/login\r\n//! - POST /auth/register\r\n//!\r\n//! Questi test usano `#[sqlx::test]` che:\r\n//! - Crea automaticamente un database di test isolato\r\n//! - Applica le migrations da `migrations/`\r\n//! - Applica i fixtures specificati da `fixtures/`\r\n//! - Pulisce il database al termine\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod auth_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures users.sql sono stati caricati (alice, bob, charlie disponibili)\r\n        // Implementa qui i tuoi test per gli endpoint di autenticazione\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_chats.rs"],"content":"//! Integration tests per gli endpoints delle chat\r\n//!\r\n//! Test per:\r\n//! - GET /chats\r\n//! - POST /chats\r\n//! - GET /chats/{chat_id}/messages\r\n//! - GET /chats/{chat_id}/members\r\n//! - POST /chats/{chat_id}/invite/{user_id}\r\n//! - PATCH /chats/{chat_id}/members/{user_id}/role\r\n//! - PATCH /chats/{chat_id}/transfer_ownership\r\n//! - DELETE /chats/{chat_id}/members/{user_id}\r\n//! - POST /chats/{chat_id}/leave\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod chat_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures sono stati caricati in ordine: users, chats, messages\r\n        // Implementa qui i tuoi test per gli endpoint delle chat\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_users.rs"],"content":"//! Integration tests per gli endpoints degli utenti\r\n//!\r\n//! Test per:\r\n//! - GET /users?search=username\r\n//! - GET /users/{user_id}\r\n//! - DELETE /users/me\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod user_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures users.sql sono stati caricati (alice, bob, charlie disponibili)\r\n        // Implementa qui i tuoi test per gli endpoint degli utenti\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","common","mod.rs"],"content":"//! Test helpers and utilities\r\n//!\r\n//! Questo modulo contiene funzioni helper condivise tra tutti i test.\r\n//!\r\n//! ## Setup Database\r\n//! I test usano il macro `#[sqlx::test]` che gestisce automaticamente:\r\n//! - Creazione di un database di test isolato per ogni test\r\n//! - Applicazione automatica delle migrations da `migrations/`\r\n//! - Applicazione opzionale di fixtures da `fixtures/`\r\n//! - Cleanup automatico del database al termine del test\r\n//!\r\n//! ## Environment Variables\r\n//! Richiede `DATABASE_URL` con credenziali superuser (root) per creare/distruggere database di test.\r\n//! Esempio: `DATABASE_URL=mysql://root:password@localhost:3306`\r\n\r\n/// Genera un JWT token per testing\r\n///\r\n/// # Arguments\r\n/// * `user_id` - ID dell'utente per cui generare il token\r\n/// * `jwt_secret` - Secret key per firmare il token\r\n///\r\n/// # Returns\r\n/// Token JWT valido per 24 ore\r\npub fn create_test_jwt(user_id: i32, jwt_secret: \u0026str) -\u003e String {\r\n    use chrono::{Duration, Utc};\r\n    use jsonwebtoken::{EncodingKey, Header, encode};\r\n    use serde::{Deserialize, Serialize};\r\n\r\n    #[derive(Debug, Serialize, Deserialize)]\r\n    struct Claims {\r\n        sub: String,\r\n        exp: i64,\r\n    }\r\n\r\n    let expiration = Utc::now()\r\n        .checked_add_signed(Duration::hours(24))\r\n        .expect(\"valid timestamp\")\r\n        .timestamp();\r\n\r\n    let claims = Claims {\r\n        sub: user_id.to_string(),\r\n        exp: expiration,\r\n    };\r\n\r\n    encode(\r\n        \u0026Header::default(),\r\n        \u0026claims,\r\n        \u0026EncodingKey::from_secret(jwt_secret.as_bytes()),\r\n    )\r\n    .expect(\"Failed to create JWT token\")\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","auth.rs"],"content":"use crate::core::{AppError, AppState};\r\nuse crate::entities::{User, UserChatMetadata, UserRole};\r\nuse crate::repositories::Read;\r\nuse axum::extract::State;\r\nuse axum::{Error, body::Body, extract::Request, http, http::Response, middleware::Next};\r\nuse chrono::{Duration, Utc};\r\nuse jsonwebtoken::{DecodingKey, EncodingKey, Header, TokenData, Validation, decode, encode};\r\nuse serde::{Deserialize, Serialize};\r\nuse std::sync::Arc;\r\nuse tracing::{debug, error, info, instrument, warn};\r\n\r\n// struct che codifica il contenuto del token jwt\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct Claims {\r\n    pub exp: usize, // Expiry time of the token\r\n    pub iat: usize, // Issued at time of the token\r\n    pub id: i32,\r\n    pub username: String,\r\n}\r\n\r\n#[instrument(skip(secret), fields(username = %username, id = %id))]\r\npub fn encode_jwt(username: String, id: i32, secret: \u0026String) -\u003e Result\u003cString, Error\u003e {\r\n    debug!(\"Encoding JWT token for user\");\r\n    let now = Utc::now();\r\n    let expire: chrono::TimeDelta = Duration::hours(24);\r\n    let exp: usize = (now + expire).timestamp() as usize;\r\n    let iat: usize = now.timestamp() as usize;\r\n    let claim = Claims {\r\n        iat,\r\n        exp,\r\n        username,\r\n        id,\r\n    };\r\n\r\n    encode(\r\n        \u0026Header::default(),\r\n        \u0026claim,\r\n        \u0026EncodingKey::from_secret(secret.as_ref()),\r\n    )\r\n    .map(|token| {\r\n        info!(\"JWT token encoded successfully\");\r\n        token\r\n    })\r\n    .map_err(|e| {\r\n        error!(\"Failed to encode JWT token: {:?}\", e);\r\n        Error::new(\"Error in encoding jwt token\")\r\n    })\r\n}\r\n\r\n#[instrument(skip(jwt_token, secret))]\r\npub fn decode_jwt(jwt_token: String, secret: \u0026String) -\u003e Result\u003cTokenData\u003cClaims\u003e, Error\u003e {\r\n    debug!(\"Decoding JWT token\");\r\n    decode(\r\n        \u0026jwt_token,\r\n        \u0026DecodingKey::from_secret(secret.as_ref()),\r\n        \u0026Validation::default(),\r\n    )\r\n    .map(|data: TokenData\u003cClaims\u003e| {\r\n        info!(\"JWT token decoded successfully for user: {}\", data.claims.username);\r\n        data\r\n    })\r\n    .map_err(|e| {\r\n        error!(\"Failed to decode JWT token: {:?}\", e);\r\n        Error::new(\"Error in decoding jwt token\")\r\n    })\r\n}\r\n\r\n#[instrument(skip(state, req, next))]\r\npub async fn authentication_middleware(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    mut req: Request,\r\n    next: Next,\r\n) -\u003e Result\u003cResponse\u003cBody\u003e, AppError\u003e {\r\n    debug!(\"Running authentication middleware\");\r\n    let auth_header = req.headers_mut().get(http::header::AUTHORIZATION);\r\n    let auth_header = match auth_header {\r\n        Some(header) =\u003e header\r\n            .to_str()\r\n            .map_err(|_| {\r\n                warn!(\"Invalid authorization header format\");\r\n                AppError::forbidden(\"Empty header is not allowed\")\r\n            })?,\r\n        None =\u003e {\r\n            warn!(\"Missing authorization header\");\r\n            return Err(AppError::forbidden(\r\n                \"Please add the JWT token to the header\",\r\n            ));\r\n        }\r\n    };\r\n    let mut header = auth_header.split_whitespace();\r\n    let (_bearer, token) = (header.next(), header.next());\r\n    let token_data = match decode_jwt(token.unwrap().to_string(), \u0026state.jwt_secret) {\r\n        Ok(data) =\u003e data,\r\n        Err(_) =\u003e {\r\n            warn!(\"Failed to decode JWT token\");\r\n            return Err(AppError::unauthorized(\"Unable to decode token\"));\r\n        }\r\n    };\r\n\r\n    // Fetch the user details from the database\r\n    let current_user = match state\r\n        .user\r\n        .find_by_username(\u0026token_data.claims.username)\r\n        .await?\r\n    {\r\n        Some(user) =\u003e {\r\n            info!(\"User authenticated: {}\", user.username);\r\n            user\r\n        }\r\n        None =\u003e {\r\n            warn!(\"User not found in database: {}\", token_data.claims.username);\r\n            return Err(AppError::unauthorized(\"You are not an authorized user\"));\r\n        }\r\n    };\r\n    req.extensions_mut().insert(current_user);\r\n    // voledo si può recuperare lo user da extension\r\n    Ok(next.run(req).await)\r\n}\r\n\r\n/// Middleware che verifica che l'utente corrente sia membro della chat specificata\r\n/// Estrae chat_id dal path, verifica la membership tramite metadata e inserisce il metadata nell'Extension\r\n#[instrument(skip(state, req, next))]\r\npub async fn chat_membership_middleware(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    mut req: Request,\r\n    next: Next,\r\n) -\u003e Result\u003cResponse\u003cBody\u003e, AppError\u003e {\r\n    debug!(\"Running chat membership middleware\");\r\n    // 1. Ottenere l'utente corrente dall'Extension (deve essere stato inserito dall'authentication_middleware)\r\n    let current_user = req\r\n        .extensions()\r\n        .get::\u003cUser\u003e()\r\n        .ok_or_else(|| {\r\n            warn!(\"User not found in request extensions\");\r\n            AppError::unauthorized(\"User not authenticated\")\r\n        })?\r\n        .clone();\r\n\r\n    // 2. Estrarre chat_id dal path\r\n    let chat_id: i32 = req\r\n        .uri()\r\n        .path()\r\n        .split('/')\r\n        .find_map(|segment| segment.parse::\u003ci32\u003e().ok())\r\n        .ok_or_else(|| {\r\n            warn!(\"Chat ID not found in path: {}\", req.uri().path());\r\n            AppError::bad_request(\"Chat ID not found in path\")\r\n        })?;\r\n\r\n    debug!(\"Checking membership for user {} in chat {}\", current_user.user_id, chat_id);\r\n    \r\n    // 3. Verificare che l'utente sia membro della chat tramite metadata\r\n    let metadata = state\r\n        .meta\r\n        .read(\u0026(current_user.user_id, chat_id))\r\n        .await?\r\n        .ok_or_else(|| {\r\n            warn!(\"User {} is not a member of chat {}\", current_user.user_id, chat_id);\r\n            AppError::forbidden(\"You are not a member of this chat\")\r\n        })?;\r\n\r\n    info!(\"User {} verified as member of chat {}\", current_user.user_id, chat_id);\r\n    \r\n    // 4. Inserire il metadata nell'Extension per uso successivo negli handler\r\n    req.extensions_mut().insert(metadata);\r\n\r\n    Ok(next.run(req).await)\r\n}\r\n\r\n/// Helper function per verificare che un utente abbia uno dei ruoli richiesti\r\n///\r\n/// # Arguments\r\n/// * `metadata` - Il metadata dell'utente da verificare\r\n/// * `allowed_roles` - Lista di ruoli permessi\r\n///\r\n/// # Returns\r\n/// * `Ok(())` se il ruolo è permesso\r\n/// * `Err(AppError)` se il ruolo non è tra quelli permessi\r\n#[instrument(skip(metadata))]\r\npub fn require_role(\r\n    metadata: \u0026UserChatMetadata,\r\n    allowed_roles: \u0026[UserRole],\r\n) -\u003e Result\u003c(), AppError\u003e {\r\n    debug!(\"Checking role requirements for user {} in chat {}\", metadata.user_id, metadata.chat_id);\r\n    let user_role = metadata\r\n        .user_role\r\n        .as_ref()\r\n        .ok_or_else(|| {\r\n            warn!(\"User role not found in metadata for user {}\", metadata.user_id);\r\n            AppError::forbidden(\"User role not found in metadata\")\r\n        })?;\r\n\r\n    if !allowed_roles.contains(user_role) {\r\n        warn!(\r\n            \"User {} has insufficient role {:?}, required one of: {:?}\",\r\n            metadata.user_id, user_role, allowed_roles\r\n        );\r\n        return Err(AppError::forbidden(\"Insufficient role\").with_details(format!(\r\n            \"This action requires one of the following roles: {:?}\",\r\n            allowed_roles\r\n        )));\r\n    }\r\n\r\n    info!(\"Role check passed for user {} with role {:?}\", metadata.user_id, user_role);\r\n    Ok(())\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","config.rs"],"content":"use dotenv::dotenv;\r\nuse std::env;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct Config {\r\n    pub database_url: String,\r\n    pub jwt_secret: String,\r\n    pub server_host: String,\r\n    pub server_port: u16,\r\n    pub max_connections: u32,\r\n    pub connection_lifetime_secs: u64,\r\n    pub app_env: String,\r\n    pub log_level: String,\r\n}\r\n\r\nimpl Config {\r\n    /// Carica la configurazione dalle variabili d'ambiente\r\n    /// Chiama dotenv() automaticamente\r\n    pub fn from_env() -\u003e Result\u003cSelf, String\u003e {\r\n        dotenv().ok();\r\n\r\n        let database_url = env::var(\"DATABASE_URL\")\r\n            .map_err(|_| \"DATABASE_URL must be set in .env file\".to_string())?;\r\n\r\n        let jwt_secret = env::var(\"JWT_SECRET\").unwrap_or_else(|_| {\r\n            eprintln!(\"WARNING: JWT_SECRET not set, using default (not secure for production!)\");\r\n            \"un segreto meno bello\".to_string()\r\n        });\r\n\r\n        let server_host = env::var(\"SERVER_HOST\").unwrap_or_else(|_| \"127.0.0.1\".to_string());\r\n\r\n        let server_port = env::var(\"SERVER_PORT\")\r\n            .unwrap_or_else(|_| \"3000\".to_string())\r\n            .parse::\u003cu16\u003e()\r\n            .map_err(|_| \"Invalid SERVER_PORT: must be a number between 0-65535\".to_string())?;\r\n\r\n        let max_connections = env::var(\"MAX_DB_CONNECTIONS\")\r\n            .unwrap_or_else(|_| \"1000\".to_string())\r\n            .parse::\u003cu32\u003e()\r\n            .map_err(|_| \"Invalid MAX_DB_CONNECTIONS: must be a positive number\".to_string())?;\r\n\r\n        let connection_lifetime_secs = env::var(\"DB_CONNECTION_LIFETIME_SECS\")\r\n            .unwrap_or_else(|_| \"1\".to_string())\r\n            .parse::\u003cu64\u003e()\r\n            .map_err(|_| {\r\n                \"Invalid DB_CONNECTION_LIFETIME_SECS: must be a positive number\".to_string()\r\n            })?;\r\n\r\n        let app_env = env::var(\"APP_ENV\").unwrap_or_else(|_| \"development\".to_string());\r\n\r\n        let log_level = env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\r\n\r\n        Ok(Config {\r\n            database_url,\r\n            jwt_secret,\r\n            server_host,\r\n            server_port,\r\n            max_connections,\r\n            connection_lifetime_secs,\r\n            app_env,\r\n            log_level,\r\n        })\r\n    }\r\n\r\n    /// Stampa la configurazione (nascondendo i segreti)\r\n    pub fn print_info(\u0026self) {\r\n        println!(\"   Server Configuration:\");\r\n        println!(\"   Environment: {}\", self.app_env);\r\n        println!(\"   Log Level: {}\", self.log_level);\r\n        println!(\r\n            \"   Server Address: {}:{}\",\r\n            self.server_host, self.server_port\r\n        );\r\n        println!(\"   Database: {}\", Self::mask_url(\u0026self.database_url));\r\n        println!(\"   Max DB Connections: {}\", self.max_connections);\r\n        println!(\"   Connection Lifetime: {}s\", self.connection_lifetime_secs);\r\n        println!(\r\n            \"   JWT Secret: {}\",\r\n            if self.jwt_secret == \"un segreto meno bello\" {\r\n                \"   USING DEFAULT (INSECURE!)\"\r\n            } else {\r\n                \"✓ Custom secret configured\"\r\n            }\r\n        );\r\n    }\r\n\r\n    /// Maschera l'URL del database per il logging\r\n    fn mask_url(url: \u0026str) -\u003e String {\r\n        if let Some(at_pos) = url.find('@') {\r\n            if let Some(scheme_end) = url.find(\"://\") {\r\n                let scheme = \u0026url[..scheme_end + 3];\r\n                let after_at = \u0026url[at_pos..];\r\n                return format!(\"{}***{}\", scheme, after_at);\r\n            }\r\n        }\r\n        \"***\".to_string()\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","error.rs"],"content":"use axum::{http::StatusCode, response::IntoResponse, Json};\r\nuse serde::Serialize;\r\n\r\n#[derive(Serialize)]\r\nstruct ErrorResponse {\r\n    error: \u0026'static str,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    details: Option\u003cString\u003e,\r\n}\r\n\r\npub struct AppError {\r\n    status: StatusCode,\r\n    message: \u0026'static str,\r\n    details: Option\u003cString\u003e,\r\n}\r\n\r\nimpl AppError {\r\n    pub fn new(status: StatusCode, message: \u0026'static str) -\u003e Self {\r\n        Self {\r\n            status,\r\n            message,\r\n            details: None,\r\n        }\r\n    }\r\n\r\n    pub fn with_details(mut self, details: impl Into\u003cString\u003e) -\u003e Self {\r\n        self.details = Some(details.into());\r\n        self\r\n    }\r\n\r\n    // Common error constructors\r\n    pub fn not_found(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::NOT_FOUND, message)\r\n    }\r\n\r\n    pub fn bad_request(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::BAD_REQUEST, message)\r\n    }\r\n\r\n    pub fn unauthorized(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::UNAUTHORIZED, message)\r\n    }\r\n\r\n    pub fn forbidden(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::FORBIDDEN, message)\r\n    }\r\n\r\n    pub fn conflict(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::CONFLICT, message)\r\n    }\r\n\r\n    pub fn internal_server_error(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::INTERNAL_SERVER_ERROR, message)\r\n    }\r\n\r\n    pub fn service_unavailable(message: \u0026'static str) -\u003e Self {\r\n        Self::new(StatusCode::SERVICE_UNAVAILABLE, message)\r\n    }\r\n}\r\n\r\nimpl From\u003csqlx::Error\u003e for AppError {\r\n    fn from(err: sqlx::Error) -\u003e Self {\r\n        match err {\r\n            sqlx::Error::RowNotFound =\u003e Self::not_found(\"Resource not found\"),\r\n\r\n            sqlx::Error::Database(_) =\u003e Self::bad_request(\"Database error\"),\r\n\r\n            sqlx::Error::PoolTimedOut | sqlx::Error::PoolClosed =\u003e {\r\n                Self::service_unavailable(\"Database unavailable\")\r\n            }\r\n\r\n            _ =\u003e Self::internal_server_error(\"Internal server error\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003caxum::Error\u003e for AppError {\r\n    fn from(err: axum::Error) -\u003e Self {\r\n        Self::internal_server_error(\"Internal server error\").with_details(err.to_string())\r\n    }\r\n}\r\n\r\nimpl From\u003cvalidator::ValidationErrors\u003e for AppError {\r\n    fn from(err: validator::ValidationErrors) -\u003e Self {\r\n        Self::bad_request(\"Validation error\").with_details(err.to_string())\r\n    }\r\n}\r\n\r\nimpl IntoResponse for AppError {\r\n    fn into_response(self) -\u003e axum::response::Response {\r\n        let body = Json(ErrorResponse {\r\n            error: self.message,\r\n            details: self.details,\r\n        });\r\n        (self.status, body).into_response()\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","mod.rs"],"content":"//! Core Module - Componenti infrastrutturali dell'applicazione\r\n//!\r\n//! Questo modulo contiene tutti i componenti \"core\" dell'applicazione:\r\n//! - Autenticazione e JWT\r\n//! - Configurazione\r\n//! - Gestione errori\r\n//! - Stato applicazione\r\n\r\npub mod auth;\r\npub mod config;\r\npub mod error;\r\npub mod state;\r\n\r\n// Re-exports per facilitare l'import\r\npub use auth::{authentication_middleware, chat_membership_middleware, encode_jwt, require_role};\r\npub use config::Config;\r\npub use error::AppError;\r\npub use state::AppState;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","core","state.rs"],"content":"//! Application State - Stato globale dell'applicazione\r\n//!\r\n//! Contiene tutti i repository, configurazioni e stato condiviso\r\n//! necessario per gestire l'applicazione.\r\n\r\nuse crate::repositories::{\r\n    ChatRepository, InvitationRepository, MessageRepository, UserChatMetadataRepository,\r\n    UserRepository,\r\n};\r\nuse crate::ws::chatmap::ChatMap;\r\nuse crate::ws::usermap::UserMap;\r\nuse sqlx::MySqlPool;\r\n\r\n/// Stato globale dell'applicazione condiviso tra tutte le route e middleware\r\npub struct AppState {\r\n    /// Repository per la gestione degli utenti\r\n    pub user: UserRepository,\r\n\r\n    /// Repository per la gestione delle chat\r\n    pub chat: ChatRepository,\r\n\r\n    /// Repository per la gestione dei messaggi\r\n    pub msg: MessageRepository,\r\n\r\n    /// Repository per la gestione degli inviti\r\n    pub invitation: InvitationRepository,\r\n\r\n    /// Repository per la gestione dei metadati utente-chat\r\n    pub meta: UserChatMetadataRepository,\r\n\r\n    /// Secret key per JWT token\r\n    pub jwt_secret: String,\r\n\r\n    /// Mappa concorrente degli utenti online con i loro canali WebSocket\r\n    /// Key: user_id, Value: Sender per inviare messaggi al WebSocket dell'utente\r\n    pub users_online: UserMap,\r\n\r\n    /// Struttura di gestione delle chat con almeno un utente online\r\n    pub chats_online: ChatMap,\r\n}\r\n\r\nimpl AppState {\r\n    /// Crea una nuova istanza di AppState inizializzando tutti i repository\r\n    /// con il pool di connessioni fornito e la JWT secret.\r\n    ///\r\n    /// # Arguments\r\n    /// * `pool` - Pool di connessioni MySQL condiviso\r\n    /// * `jwt_secret` - Chiave segreta per la firma dei token JWT\r\n    ///\r\n    /// # Returns\r\n    /// Nuova istanza di AppState con tutti i repository inizializzati\r\n    pub fn new(pool: MySqlPool, jwt_secret: String) -\u003e Self {\r\n        Self {\r\n            user: UserRepository::new(pool.clone()),\r\n            chat: ChatRepository::new(pool.clone()),\r\n            msg: MessageRepository::new(pool.clone()),\r\n            invitation: InvitationRepository::new(pool.clone()),\r\n            meta: UserChatMetadataRepository::new(pool),\r\n            jwt_secret,\r\n            users_online: UserMap::new(),\r\n            chats_online: ChatMap::new(),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","chat.rs"],"content":"//! Chat DTOs - Data Transfer Objects per chat\r\n\r\nuse crate::entities::{Chat, ChatType};\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct ChatDTO {\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub title: Option\u003cString\u003e,\r\n    pub description: Option\u003cString\u003e,\r\n    pub chat_type: Option\u003cChatType\u003e,\r\n    pub user_list: Option\u003cVec\u003ci32\u003e\u003e, // lista user_id per chat private/gruppo\r\n}\r\n\r\nimpl From\u003cChat\u003e for ChatDTO {\r\n    fn from(value: Chat) -\u003e Self {\r\n        Self {\r\n            chat_id: Some(value.chat_id),\r\n            title: value.title,\r\n            description: value.description,\r\n            chat_type: Some(value.chat_type),\r\n            user_list: None, // da popolare manualmente se necessario\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare una nuova chat (senza chat_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateChatDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 100,\r\n        message = \"Chat title must be between 1 and 100 characters\"\r\n    ))]\r\n    pub title: Option\u003cString\u003e,\r\n\r\n    #[validate(length(max = 500, message = \"Chat description must not exceed 500 characters\"))]\r\n    pub description: Option\u003cString\u003e,\r\n\r\n    pub chat_type: ChatType,\r\n}\r\n\r\n/// DTO per aggiornare una chat (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateChatDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 100,\r\n        message = \"Chat title must be between 1 and 100 characters\"\r\n    ))]\r\n    pub title: Option\u003cString\u003e,\r\n\r\n    #[validate(length(max = 500, message = \"Chat description must not exceed 500 characters\"))]\r\n    pub description: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","invitation.rs"],"content":"//! Invitation DTOs - Data Transfer Objects per inviti\r\n\r\nuse crate::entities::{Invitation, InvitationStatus};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct InvitationDTO {\r\n    pub invite_id: Option\u003ci32\u003e,\r\n    pub target_chat_id: Option\u003ci32\u003e,\r\n    pub invited_id: Option\u003ci32\u003e,\r\n    pub invitee_id: Option\u003ci32\u003e,\r\n    pub state: Option\u003cInvitationStatus\u003e,\r\n    pub created_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n\r\nimpl From\u003cInvitation\u003e for InvitationDTO {\r\n    fn from(value: Invitation) -\u003e Self {\r\n        Self {\r\n            invite_id: Some(value.invite_id),\r\n            target_chat_id: Some(value.target_chat_id),\r\n            invited_id: Some(value.invited_id),\r\n            invitee_id: Some(value.invitee_id),\r\n            state: Some(value.state),\r\n            created_at: Some(value.created_at),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo invito (senza invite_id, state e created_at)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct CreateInvitationDTO {\r\n    pub target_chat_id: i32,\r\n    pub invited_id: i32,\r\n    pub invitee_id: i32,\r\n}\r\n\r\n/// DTO per aggiornare un invito (solo lo stato è modificabile)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UpdateInvitationDTO {\r\n    pub state: Option\u003cInvitationStatus\u003e,\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","message.rs"],"content":"//! Message DTOs - Data Transfer Objects per messaggi\r\n\r\nuse crate::entities::{Message, MessageType};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n/// Struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct MessageDTO {\r\n    pub message_id: Option\u003ci32\u003e,\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub sender_id: Option\u003ci32\u003e,\r\n    pub content: Option\u003cString\u003e,\r\n    pub message_type: Option\u003cMessageType\u003e,\r\n    pub created_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n\r\nimpl From\u003cMessage\u003e for MessageDTO {\r\n    fn from(value: Message) -\u003e Self {\r\n        Self {\r\n            message_id: Some(value.message_id),\r\n            chat_id: Some(value.chat_id),\r\n            sender_id: Some(value.sender_id),\r\n            content: Some(value.content),\r\n            message_type: Some(value.message_type),\r\n            created_at: Some(value.created_at),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo messaggio (senza message_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateMessageDTO {\r\n    pub chat_id: i32,\r\n    pub sender_id: i32,\r\n\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 5000,\r\n        message = \"Message content must be between 1 and 5000 characters\"\r\n    ))]\r\n    pub content: String,\r\n    pub message_type: MessageType,\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n}\r\n\r\nimpl TryFrom\u003cMessageDTO\u003e for CreateMessageDTO {\r\n    type Error = \u0026'static str;\r\n    fn try_from(value: MessageDTO) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        Ok(Self {\r\n            chat_id: value.chat_id.ok_or(\"chat_id missing\")?,\r\n            sender_id: value.sender_id.ok_or(\"sender_id missing\")?,\r\n            content: value.content.ok_or(\"content missing\")?,\r\n            message_type: value.message_type.ok_or(\"message_type missing\")?,\r\n            created_at: value.created_at.unwrap_or_else(Utc::now),\r\n        })\r\n    }\r\n}\r\n\r\n/// DTO per aggiornare un messaggio (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateMessageDTO {\r\n    #[validate(length(\r\n        min = 1,\r\n        max = 5000,\r\n        message = \"Message content must be between 1 and 5000 characters\"\r\n    ))]\r\n    pub content: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","mod.rs"],"content":"//! DTOs module - Data Transfer Objects\r\n//!\r\n//! Questo modulo contiene tutti i DTOs usati per la comunicazione client-server.\r\n//! I DTOs separano la rappresentazione esterna (API) dalla rappresentazione interna (entities).\r\n\r\npub mod chat;\r\npub mod invitation;\r\npub mod message;\r\npub mod query;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-exports per mantenere la compatibilità con il codice esistente\r\npub use chat::{ChatDTO, CreateChatDTO, UpdateChatDTO};\r\npub use invitation::{CreateInvitationDTO, InvitationDTO, UpdateInvitationDTO};\r\npub use message::{CreateMessageDTO, MessageDTO, UpdateMessageDTO};\r\npub use query::{MessagesQuery, UserSearchQuery};\r\npub use user::{CreateUserDTO, UpdateUserDTO, UserDTO};\r\npub use user_chat_metadata::{CreateUserChatMetadataDTO, UpdateUserChatMetadataDTO, UserInChatDTO};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","query.rs"],"content":"//! Query DTOs - Data Transfer Objects per query di ricerca\r\n\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// DTO per query parameters di ricerca utenti\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserSearchQuery {\r\n    pub search: String,\r\n}\r\n\r\n/// DTO per query parameters di paginazione messaggi\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct MessagesQuery {\r\n    #[serde(default)]\r\n    pub before_date: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","user.rs"],"content":"//! User DTOs - Data Transfer Objects per utenti\r\n\r\nuse crate::entities::User;\r\nuse serde::{Deserialize, Serialize};\r\nuse validator::Validate;\r\n\r\n// struct per gestire io col client\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserDTO {\r\n    pub id: Option\u003ci32\u003e,\r\n    pub username: Option\u003cString\u003e,\r\n}\r\n\r\nimpl From\u003cUser\u003e for UserDTO {\r\n    fn from(value: User) -\u003e Self {\r\n        Self {\r\n            id: Some(value.user_id),\r\n            username: Some(value.username)\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare un nuovo utente (senza user_id)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct CreateUserDTO {\r\n    #[validate(length(\r\n        min = 3,\r\n        max = 50,\r\n        message = \"Username must be between 3 and 50 characters\"\r\n    ))]\r\n    #[validate(custom(\r\n        function = \"validate_username\",\r\n        message = \"Username can only contain letters, numbers, and underscores\"\r\n    ))]\r\n    pub username: String,\r\n\r\n    #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\r\n    #[validate(custom(\r\n        function = \"validate_password_strength\",\r\n        message = \"Password must contain at least one uppercase, one lowercase, and one number\"\r\n    ))]\r\n    pub password: String,\r\n}\r\n\r\nfn validate_username(username: \u0026str) -\u003e Result\u003c(), validator::ValidationError\u003e {\r\n    lazy_static::lazy_static! {\r\n        static ref USERNAME_REGEX: regex::Regex = regex::Regex::new(r\"^[a-zA-Z0-9_]+$\").unwrap();\r\n    }\r\n\r\n    // Bloccare \"Deleted User\" - username riservato dal sistema\r\n    if username == \"Deleted User\" {\r\n        return Err(validator::ValidationError::new(\"reserved_username\"));\r\n    }\r\n\r\n    if USERNAME_REGEX.is_match(username) {\r\n        Ok(())\r\n    } else {\r\n        Err(validator::ValidationError::new(\"invalid_username\"))\r\n    }\r\n}\r\n\r\nfn validate_password_strength(password: \u0026str) -\u003e Result\u003c(), validator::ValidationError\u003e {\r\n    let has_uppercase = password.chars().any(|c| c.is_uppercase());\r\n    let has_lowercase = password.chars().any(|c| c.is_lowercase());\r\n    let has_digit = password.chars().any(|c| c.is_numeric());\r\n\r\n    if has_uppercase \u0026\u0026 has_lowercase \u0026\u0026 has_digit {\r\n        Ok(())\r\n    } else {\r\n        Err(validator::ValidationError::new(\"weak_password\"))\r\n    }\r\n}\r\n\r\n/// DTO per aggiornare un utente esistente (solo password modificabile)\r\n#[derive(Serialize, Deserialize, Debug, Clone, Validate)]\r\npub struct UpdateUserDTO {\r\n    #[validate(length(min = 8, message = \"Password must be at least 8 characters\"))]\r\n    #[validate(custom(\r\n        function = \"validate_password_strength\",\r\n        message = \"Password must contain at least one uppercase, one lowercase, and one number\"\r\n    ))]\r\n    pub password: Option\u003cString\u003e,\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","dtos","user_chat_metadata.rs"],"content":"//! UserChatMetadata DTOs - Data Transfer Objects per metadati utente-chat\r\n\r\nuse crate::entities::{UserChatMetadata, UserRole};\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Struct per restituire info più semplici per le liste\r\n/// (nome = UserInChatDTO nell'originale, rappresenta un utente in una chat con il suo ruolo)\r\n#[derive(Serialize, Deserialize, Debug)]\r\npub struct UserInChatDTO {\r\n    pub user_id: Option\u003ci32\u003e,\r\n    pub chat_id: Option\u003ci32\u003e,\r\n    pub username: Option\u003cString\u003e,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n    //pub messages_visible_from: Option\u003cDateTime\u003cUtc\u003e\u003e,         // superfluo per il tipo di operazione\r\n    //pub messages_received_until: Option\u003cDateTime\u003cUtc\u003e\u003e,       // superfluo per il tipo di operazione\r\n}\r\n\r\nimpl From\u003cUserChatMetadata\u003e for UserInChatDTO {\r\n    fn from(value: UserChatMetadata) -\u003e Self {\r\n        Self {\r\n            user_id: Some(value.user_id),\r\n            chat_id: Some(value.chat_id),\r\n            username: None, // Non è presente in UserChatMetadata, va popolato altrove\r\n            user_role: value.user_role,\r\n            member_since: Some(value.member_since),\r\n            // messages_visible_from: Some(value.messages_visible_from),\r\n            // messages_received_until: Some(value.messages_received_until),\r\n        }\r\n    }\r\n}\r\n\r\n/// DTO per creare nuovi metadati utente-chat (senza member_since, messages_visible_from, messages_received_until - gestiti dal DB)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct CreateUserChatMetadataDTO {\r\n    pub user_id: i32,\r\n    pub chat_id: i32,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: DateTime\u003cUtc\u003e,\r\n    pub messages_visible_from: DateTime\u003cUtc\u003e,\r\n    pub messages_received_until: DateTime\u003cUtc\u003e,\r\n}\r\n\r\n/// DTO per aggiornare metadati utente-chat (solo campi modificabili)\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UpdateUserChatMetadataDTO {\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub messages_visible_from: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n    pub messages_received_until: Option\u003cDateTime\u003cUtc\u003e\u003e,\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","chat.rs"],"content":"//! Chat entity - Entità chat\r\n\r\nuse super::enums::ChatType;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Chat {\r\n    pub chat_id: i32,\r\n    pub title: Option\u003cString\u003e,\r\n    pub description: Option\u003cString\u003e,\r\n    pub chat_type: ChatType,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","enums.rs"],"content":"//! Enumerazioni - Tipi enumerati utilizzati nelle entità\r\n\r\nuse serde::{Deserialize, Serialize};\r\n\r\n// ********************* ENUMERAZIONI UTILI **********************//\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, sqlx::Type)]\r\n#[sqlx(type_name = \"message_type\", rename_all = \"UPPERCASE\")]\r\npub enum MessageType {\r\n    UserMessage,\r\n    SystemMessage,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, sqlx::Type)]\r\n#[sqlx(type_name = \"user_role\", rename_all = \"UPPERCASE\")]\r\npub enum UserRole {\r\n    Owner,\r\n    Admin,\r\n    Member,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, sqlx::Type, PartialEq)]\r\n#[sqlx(type_name = \"invitation_status\", rename_all = \"UPPERCASE\")]\r\npub enum InvitationStatus {\r\n    Pending,\r\n    Accepted,\r\n    Rejected,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone, sqlx::Type, PartialEq)]\r\n#[sqlx(type_name = \"chat_type\", rename_all = \"UPPERCASE\")]\r\npub enum ChatType {\r\n    Group,\r\n    Private,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","invitation.rs"],"content":"//! Invitation entity - Entità invito\r\n\r\nuse super::enums::InvitationStatus;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Invitation {\r\n    pub invite_id: i32,\r\n    pub target_chat_id: i32, // chat ( di gruppo ) in cui si viene invitati\r\n    pub invited_id: i32,     // utente invitato\r\n    pub invitee_id: i32,     // utente che invita\r\n    pub state: InvitationStatus,\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","message.rs"],"content":"//! Message entity - Entità messaggio\r\n\r\nuse super::enums::MessageType;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct Message {\r\n    pub message_id: i32,\r\n    pub chat_id: i32,\r\n    pub sender_id: i32, // rendere opzionale per i messaggi di sistema visto che il sistema non ha tipo ?\r\n    pub content: String,\r\n    // il server si aspetta una stringa litterale iso8601 che viene parsata in oggetto DateTime di tipo UTC\r\n    // la conversione viene fatta in automatico da serde, la feature è stata abilitata\r\n    pub created_at: DateTime\u003cUtc\u003e,\r\n    // campo rinominato rispetto a uml perchè type è una parola protetta\r\n    pub message_type: MessageType,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","mod.rs"],"content":"//! Entities module - Entità del dominio applicativo\r\n//!\r\n//! Questo modulo contiene tutte le entità (models) che rappresentano i dati persistiti nel database.\r\n//! Ogni entity corrisponde a una tabella nel database.\r\n\r\npub mod chat;\r\npub mod enums;\r\npub mod invitation;\r\npub mod message;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-exports per facilitare l'import\r\npub use chat::Chat;\r\npub use enums::{ChatType, InvitationStatus, MessageType, UserRole};\r\npub use invitation::Invitation;\r\npub use message::Message;\r\npub use user::User;\r\npub use user_chat_metadata::UserChatMetadata;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","user.rs"],"content":"//! User entity - Entità utente con metodi per gestione password\r\n\r\nuse bcrypt::{DEFAULT_COST, hash, verify};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct User {\r\n    /* se vogliamo rinominare campi usiamo la macro\r\n     * #[serde(rename = \"userId\")]\r\n     */\r\n    pub user_id: i32,\r\n    pub username: String,\r\n    pub password: String,\r\n}\r\n\r\nimpl User {\r\n    /// Verify if target_password matches the stored hashed password\r\n    pub fn verify_password(\u0026self, target_password: \u0026String) -\u003e bool {\r\n        verify(target_password, \u0026self.password).unwrap_or(false)\r\n    }\r\n\r\n    /// Hash a password using bcrypt with default cost\r\n    pub fn hash_password(password: \u0026str) -\u003e Result\u003cString, bcrypt::BcryptError\u003e {\r\n        let hash = hash(password, DEFAULT_COST)?;\r\n        Ok(hash)\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","entities","user_chat_metadata.rs"],"content":"//! UserChatMetadata entity - Entità metadata utente-chat\r\n\r\nuse super::enums::UserRole;\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Debug, Clone)]\r\npub struct UserChatMetadata {\r\n    pub user_id: i32,\r\n    pub chat_id: i32,\r\n    pub user_role: Option\u003cUserRole\u003e,\r\n    pub member_since: DateTime\u003cUtc\u003e,\r\n    // sostituisce deliver_from con un nome più esplicativo\r\n    // sostituito al posto dell'id del messaggio il datetime, è da intendersi come\r\n    // \"visualizza i messaggi da questo istante in poi, questo istante ESCLUSO\"\r\n    pub messages_visible_from: DateTime\u003cUtc\u003e,\r\n    // sostituisce last delivered con un nume più esplicativo\r\n    // sostituito al posto dell'id del messaggio il date time, è da intendersi come\r\n    // \"ho ricevuto i messaggi fino a questo istante, istante INCLUSO\"\r\n    pub messages_received_until: DateTime\u003cUtc\u003e,\r\n    //per ora non esludo i due campi dalla deserializzazione\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","main.rs"],"content":"mod core;\nmod dtos;\nmod entities;\nmod repositories;\nmod services;\nmod ws;\n\nuse crate::core::{AppState, Config, authentication_middleware, chat_membership_middleware};\nuse crate::services::*;\nuse crate::ws::ws_handler;\nuse axum::{\n    Router, middleware,\n    routing::{any, delete, get, patch, post},\n};\nuse sqlx::mysql::MySqlPoolOptions;\nuse std::{net::SocketAddr, sync::Arc, time::Duration};\nuse tokio::net::TcpListener;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n/// Configura le routes di autenticazione (login, register)\nfn configure_auth_routes() -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/login\", post(login_user))\n        .route(\"/register\", post(register_user))\n}\n\n/// Configura le routes per la gestione degli utenti\nfn configure_user_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/\", get(search_user_with_username))\n        .route(\"/{user_id}\", get(get_user_by_id))\n        .route(\"/me\", delete(delete_my_account))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ))\n}\n\n/// Configura le routes per la gestione delle chat\nfn configure_chat_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    // Rotte che NON richiedono membership (solo autenticazione)\n    let public_routes = Router::new()\n        .route(\"/\", get(list_chats).post(create_chat))\n        .layer(middleware::from_fn_with_state(\n            state.clone(),\n            authentication_middleware,\n        ));\n\n    // Rotte che richiedono membership (autenticazione + membership middleware)\n    let member_routes = Router::new()\n        .route(\"/{chat_id}/messages\", get(get_chat_messages))\n        .route(\"/{chat_id}/members\", get(list_chat_members))\n        .route(\"/{chat_id}/invite/{user_id}\", post(invite_to_chat))\n        .route(\n            \"/{chat_id}/members/{user_id}/role\",\n            patch(update_member_role),\n        )\n        .route(\"/{chat_id}/transfer_ownership\", patch(transfer_ownership))\n        .route(\"/{chat_id}/members/{user_id}\", delete(remove_member))\n        .route(\"/{chat_id}/leave\", post(leave_chat))\n        .layer(middleware::from_fn_with_state(\n            state.clone(),\n            chat_membership_middleware,\n        ))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ));\n\n    public_routes.merge(member_routes)\n}\n\n/// Configura le routes per la gestione degli inviti\nfn configure_invitation_routes(state: Arc\u003cAppState\u003e) -\u003e Router\u003cArc\u003cAppState\u003e\u003e {\n    Router::new()\n        .route(\"/pending\", get(list_pending_invitations))\n        .route(\"/{invite_id}/{action}\", post(respond_to_invitation))\n        .layer(middleware::from_fn_with_state(\n            state,\n            authentication_middleware,\n        ))\n}\n\n#[tokio::main]\nasync fn main() {\n    // Carica la configurazione dalle variabili d'ambiente\n    let config = Config::from_env().expect(\"Failed to load configuration. Check your .env file.\");\n\n    // Inizializza il tracing subscriber con il log level dalla configurazione\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| format!(\"server={},tower_http=debug\", config.log_level).into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    // Stampa info sulla configurazione\n    config.print_info();\n\n    // Builder per configurare le connessioni al database con retry automatico\n    let pool_options = MySqlPoolOptions::new()\n        .max_connections(config.max_connections)\n        .max_lifetime(Duration::from_secs(config.connection_lifetime_secs))\n        .acquire_timeout(Duration::from_secs(2)) // Timeout per l'acquisizione di una connessione dal pool\n        .test_before_acquire(true);\n\n    // Avvio il pool di connessioni al database con retry automatico ogni 2 secondi\n    println!(\"Attempting to connect to database...\");\n    let connection_pool = loop {\n        match pool_options.clone().connect(\u0026config.database_url).await {\n            Ok(pool) =\u003e {\n                println!(\"✓ Database connection established successfully!\");\n                break pool;\n            }\n            Err(e) =\u003e {\n                eprintln!(\"✗ Failed to connect to database: {}\", e);\n                eprintln!(\"  Retrying in 2 seconds...\");\n                tokio::time::sleep(Duration::from_secs(2)).await;\n            }\n        }\n    };\n\n    // Creiamo lo stato dell'applicazione con i repository e la configurazione\n    let state = Arc::new(AppState::new(connection_pool, config.jwt_secret.clone()));\n\n    // Definizione indirizzo del server\n    let addr = SocketAddr::from((\n        config\n            .server_host\n            .parse::\u003cstd::net::IpAddr\u003e()\n            .expect(\"Invalid SERVER_HOST format\"),\n        config.server_port,\n    ));\n    println!(\"Server listening on http://{}\", addr);\n\n    // Creazione del listener TCP per ascoltare l'indirizzo\n    let listener = TcpListener::bind(addr)\n        .await\n        .expect(\"Unable to start TCP listener.\");\n\n    // Costruzione del router principale con tutte le routes\n    let app = Router::new()\n        .route(\"/\", get(root))\n        .nest(\"/auth\", configure_auth_routes())\n        .nest(\"/users\", configure_user_routes(state.clone()))\n        .nest(\"/chats\", configure_chat_routes(state.clone()))\n        .nest(\"/invitations\", configure_invitation_routes(state.clone()))\n        .route(\n            \"/ws\",\n            any(ws_handler).layer(middleware::from_fn_with_state(\n                state.clone(),\n                authentication_middleware,\n            )),\n        )\n        .with_state(state);\n\n    // Avvia il server\n    axum::serve(listener, app)\n        .await\n        .expect(\"Error serving the application\");\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","chat.rs"],"content":"//! ChatRepository - Repository per la gestione delle chat\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateChatDTO, UpdateChatDTO};\r\nuse crate::entities::{Chat, ChatType};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// CHAT REPOSITORY\r\npub struct ChatRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl ChatRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get private chat between two users (if exists)\r\n    /// Optimized query: uses GROUP BY + HAVING instead of multiple JOINs for better performance\r\n    #[instrument(skip(self), fields(user1 = %user1_id, user2 = %user2_id))]\r\n    pub async fn get_private_chat_between_users(\r\n        \u0026self,\r\n        user1_id: \u0026i32,\r\n        user2_id: \u0026i32,\r\n    ) -\u003e Result\u003cOption\u003cChat\u003e, Error\u003e {\r\n        debug!(\"Finding private chat between two users\");\r\n        let chat = sqlx::query_as!(\r\n            Chat,\r\n            r#\"\r\n            SELECT \r\n                c.chat_id,\r\n                c.title,\r\n                c.description,\r\n                c.chat_type as \"chat_type: ChatType\"\r\n            FROM chats c\r\n            INNER JOIN userchatmetadata ucm ON c.chat_id = ucm.chat_id\r\n            WHERE c.chat_type = 'PRIVATE' \r\n            AND ucm.user_id IN (?, ?)\r\n            GROUP BY c.chat_id, c.title, c.description, c.chat_type\r\n            HAVING COUNT(DISTINCT ucm.user_id) = 2\r\n            \"#,\r\n            user1_id,\r\n            user2_id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if chat.is_some() {\r\n            info!(\"Private chat found\");\r\n        } else {\r\n            debug!(\"No private chat found\");\r\n        }\r\n\r\n        Ok(chat)\r\n    }\r\n}\r\n\r\nimpl Create\u003cChat, CreateChatDTO\u003e for ChatRepository {\r\n    #[instrument(skip(self, data), fields(chat_type = ?data.chat_type))]\r\n    async fn create(\u0026self, data: \u0026CreateChatDTO) -\u003e Result\u003cChat, Error\u003e {\r\n        debug!(\"Creating new chat\");\r\n        // Insert chat using MySQL syntax\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO chats (title, description, chat_type) \r\n            VALUES (?, ?, ?)\r\n            \"#,\r\n            data.title,\r\n            data.description,\r\n            data.chat_type\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Chat created with id {}\", new_id);\r\n\r\n        // Return the created chat with the new ID\r\n        Ok(Chat {\r\n            chat_id: new_id,\r\n            title: data.title.clone(),\r\n            description: data.description.clone(),\r\n            chat_type: data.chat_type.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cChat, i32\u003e for ChatRepository {\r\n    #[instrument(skip(self), fields(chat_id = %id))]\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cChat\u003e, Error\u003e {\r\n        debug!(\"Reading chat by id\");\r\n        let chat = sqlx::query_as!(\r\n            Chat,\r\n            r#\"\r\n            SELECT \r\n                chat_id,\r\n                title,\r\n                description,\r\n                chat_type as \"chat_type: ChatType\"\r\n            FROM chats \r\n            WHERE chat_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if chat.is_some() {\r\n            debug!(\"Chat found\");\r\n        } else {\r\n            debug!(\"Chat not found\");\r\n        }\r\n\r\n        Ok(chat)\r\n    }\r\n}\r\n\r\nimpl Update\u003cChat, UpdateChatDTO, i32\u003e for ChatRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %id))]\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateChatDTO) -\u003e Result\u003cChat, Error\u003e {\r\n        debug!(\"Updating chat\");\r\n        // First, get the current chat to ensure it exists\r\n        let current_chat = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no fields to update, return current chat\r\n        if data.title.is_none() \u0026\u0026 data.description.is_none() {\r\n            debug!(\"No fields to update, returning current chat\");\r\n            return Ok(current_chat);\r\n        }\r\n\r\n        // Build dynamic UPDATE query using QueryBuilder (idiomatic SQLx way)\r\n        let mut query_builder = sqlx::QueryBuilder::new(\"UPDATE chats SET \");\r\n\r\n        let mut separated = query_builder.separated(\", \");\r\n        if let Some(ref title) = data.title {\r\n            separated.push(\"title = \");\r\n            separated.push_bind_unseparated(title);\r\n        }\r\n        if let Some(ref description) = data.description {\r\n            separated.push(\"description = \");\r\n            separated.push_bind_unseparated(description);\r\n        }\r\n\r\n        query_builder.push(\" WHERE chat_id = \");\r\n        query_builder.push_bind(id);\r\n\r\n        query_builder.build().execute(\u0026self.connection_pool).await?;\r\n\r\n        info!(\"Chat updated successfully\");\r\n\r\n        // Fetch and return the updated chat\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for ChatRepository {\r\n    #[instrument(skip(self), fields(chat_id = %id))]\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        debug!(\"Deleting chat\");\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        info!(\"Chat deleted successfully\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::entities::ChatType;\r\n    use sqlx::MySqlPool;\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: get_private_chat_between_users */\r\n    /*------------------------------------------- */\r\n\r\n    /// Test: trova una chat privata esistente tra due utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) e Bob (user_id=2) hanno una chat privata (chat_id=2)\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        assert!(result.is_some());\r\n        let chat = result.unwrap();\r\n        assert_eq!(chat.chat_id, 2);\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: l'ordine degli utenti non influisce sul risultato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_order_independent(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca prima con (alice, bob)\r\n        let result1 = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        // Cerca poi con (bob, alice)\r\n        let result2 = repo.get_private_chat_between_users(\u00262, \u00261).await?;\r\n        \r\n        assert!(result1.is_some());\r\n        assert!(result2.is_some());\r\n        assert_eq!(result1.unwrap().chat_id, result2.unwrap().chat_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat quando non esiste tra i due utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) e Charlie (user_id=3) non hanno chat privata\r\n        let result = repo.get_private_chat_between_users(\u00262, \u00263).await?;\r\n        \r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat GROUP quando si cerca PRIVATE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_ignores_group_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) e Bob (user_id=2) sono entrambi nella \"General Chat\" (GROUP)\r\n        // Ma questo metodo deve trovare solo chat PRIVATE\r\n        // Hanno già una chat privata (chat_id=2), quindi il test verifica che restituisca quella\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        \r\n        assert!(result.is_some());\r\n        let chat = result.unwrap();\r\n        // Deve essere la chat privata, non la group chat\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        assert_eq!(chat.chat_id, 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: non trova chat con utenti inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_invalid_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca con user_id inesistenti\r\n        let result = repo.get_private_chat_between_users(\u0026999, \u00261000).await?;\r\n        \r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: gestione con stesso user_id per entrambi i parametri\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_between_users_same_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Cerca chat privata tra lo stesso utente\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00261).await?;\r\n        \r\n        // Non dovrebbe trovare nulla (una chat privata richiede 2 utenti distinti)\r\n        assert!(result.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina userchatmetadata\r\n    /// La chat rimane ma non è più trovabile con questo metodo\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Verifica che la chat esista\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        \r\n        // Elimina Alice (user_id=1)\r\n        // CASCADE DELETE eliminerà le righe in userchatmetadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // Ora la chat non dovrebbe più essere trovabile\r\n        // perché manca un record in userchatmetadata\r\n        let result_after = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_after.is_none());\r\n        \r\n        // Verifica che la chat esista ancora nel database\r\n        let chat_exists = sqlx::query!(\r\n            \"SELECT chat_id FROM chats WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_optional(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert!(chat_exists.is_some(), \"La chat dovrebbe esistere ancora\");\r\n        \r\n        // Verifica che userchatmetadata sia stato eliminato per user_id=1\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            1\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 0, \"Metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat elimina userchatmetadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Verifica che la chat esista\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        let chat_id = result_before.unwrap().chat_id;\r\n        \r\n        // Elimina la chat\r\n        // CASCADE DELETE eliminerà anche userchatmetadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // La chat non dovrebbe più essere trovabile\r\n        let result_after = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_after.is_none());\r\n        \r\n        // Verifica che userchatmetadata sia stato eliminato\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 0, \"Metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: verifica che l'eliminazione di un solo utente\r\n    /// non rompa la query (dovrebbe restituire None)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_partial_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Elimina Bob (user_id=2) - CASCADE elimina il suo userchatmetadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // La chat privata ha ora solo 1 membro invece di 2\r\n        // La query HAVING COUNT(DISTINCT ucm.user_id) = 2 non dovrebbe trovare nulla\r\n        let result = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result.is_none());\r\n        \r\n        // Verifica che rimanga solo 1 record in userchatmetadata per questa chat\r\n        let metadata_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(metadata_count.count, 1, \"Dovrebbe rimanere solo 1 membro\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: verifica comportamento con chat che ha messaggi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_get_private_chat_cascade_with_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Inserisci un messaggio nella chat privata\r\n        sqlx::query!(\r\n            \"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, ?, ?, NOW())\",\r\n            2, 1, \"Test message\"\r\n        )\r\n        .execute(\u0026repo.connection_pool)\r\n        .await?;\r\n        \r\n        // La chat dovrebbe essere trovabile normalmente\r\n        let result_before = repo.get_private_chat_between_users(\u00261, \u00262).await?;\r\n        assert!(result_before.is_some());\r\n        \r\n        // Elimina la chat - CASCADE elimina anche i messaggi\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 2)\r\n            .execute(\u0026repo.connection_pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi siano stati eliminati\r\n        let message_count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026repo.connection_pool)\r\n        .await?;\r\n        assert_eq!(message_count.count, 0, \"Messaggi dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures sono stati caricati in ordine: users, chats\r\n        // Implementa qui i tuoi test per ChatRepository\r\n        Ok(())\r\n    }\r\n\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: create                         */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_create_group_chat_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per una chat di gruppo\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Test Group Chat\".to_string()),\r\n            description: Some(\"A test group chat for testing\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        // Testa la creazione\r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che la chat sia stata creata correttamente\r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, Some(\"Test Group Chat\".to_string()));\r\n        assert_eq!(created_chat.description, Some(\"A test group chat for testing\".to_string()));\r\n        assert_eq!(created_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_private_chat_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per una chat privata (senza title/description)\r\n        let create_dto = CreateChatDTO {\r\n            title: None,\r\n            description: None,\r\n            chat_type: ChatType::Private,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, None);\r\n        assert_eq!(created_chat.description, None);\r\n        assert_eq!(created_chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_chat_with_minimal_data(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea chat con solo il campo obbligatorio\r\n        let create_dto = CreateChatDTO {\r\n            title: None,\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created_chat.chat_id \u003e 0);\r\n        assert_eq!(created_chat.title, None);\r\n        assert_eq!(created_chat.description, None);\r\n        assert_eq!(created_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests: read                           */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_read_existing_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat direttamente nel database\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Test Chat', 'Test Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la lettura\r\n        let chat = repo.read(\u00261).await?;\r\n        \r\n        assert!(chat.is_some());\r\n        let chat = chat.unwrap();\r\n        assert_eq!(chat.chat_id, 1);\r\n        assert_eq!(chat.title, Some(\"Test Chat\".to_string()));\r\n        assert_eq!(chat.description, Some(\"Test Description\".to_string()));\r\n        assert_eq!(chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la lettura di una chat inesistente\r\n        let chat = repo.read(\u0026999).await?;\r\n        \r\n        assert!(chat.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat privata\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, NULL, NULL, 'PRIVATE')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        let chat = repo.read(\u00261).await?;\r\n        \r\n        assert!(chat.is_some());\r\n        let chat = chat.unwrap();\r\n        assert_eq!(chat.chat_id, 1);\r\n        assert_eq!(chat.title, None);\r\n        assert_eq!(chat.description, None);\r\n        assert_eq!(chat.chat_type, ChatType::Private);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n/*------------------------------------------- */\r\n/* Unit tests: update                         */\r\n/*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_update_chat_title_and_description(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Crea DTO per l'aggiornamento\r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"Updated Title\".to_string()),        \r\n            description: Some(\"Updated Description\".to_string()), \r\n        };\r\n        \r\n        // Testa l'aggiornamento\r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.chat_id, 1);\r\n        assert_eq!(updated_chat.title, Some(\"Updated Title\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Updated Description\".to_string()));\r\n        assert_eq!(updated_chat.chat_type, ChatType::Group);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_chat_only_title(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Aggiorna solo il titolo\r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"New Title Only\".to_string()),  \r\n            description: None, // Non aggiornare la description\r\n        };\r\n        \r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.title, Some(\"New Title Only\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Original Description\".to_string())); // Rimasta invariata\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_chat_with_no_changes(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Original Title', 'Original Description', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // DTO senza cambiamenti (tutti i campi None)\r\n        let update_dto = UpdateChatDTO {\r\n            title: None,\r\n            description: None,\r\n        };\r\n        \r\n        // Dovrebbe restituire la chat invariata\r\n        let updated_chat = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_chat.title, Some(\"Original Title\".to_string()));\r\n        assert_eq!(updated_chat.description, Some(\"Original Description\".to_string()));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        let update_dto = UpdateChatDTO {\r\n            title: Some(\"New Title\".to_string()),  \r\n            description: None,\r\n        };\r\n        \r\n        // Testa l'aggiornamento di una chat inesistente\r\n        let result = repo.update(\u0026999, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err());\r\n        match result {\r\n            Err(sqlx::Error::RowNotFound) =\u003e {}, // Comportamento atteso\r\n            _ =\u003e panic!(\"Expected RowNotFound error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n    /*------------------------------------------- */\r\n    /* Unit tests: delete                         */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_delete_existing_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, description, chat_type) VALUES (1, 'Chat to Delete', 'Will be deleted', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Verifica che la chat esista prima della cancellazione\r\n        let chat_before = repo.read(\u00261).await?;\r\n        assert!(chat_before.is_some());\r\n        \r\n        // Testa la cancellazione\r\n        let result = repo.delete(\u00261).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che la chat sia stata eliminata\r\n        let chat_after = repo.read(\u00261).await?;\r\n        assert!(chat_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_delete_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = ChatRepository::new(pool);\r\n        \r\n        // Testa la cancellazione di una chat inesistente\r\n        // Dovrebbe completarsi senza errori (operazione idempotente)\r\n        let result = repo.delete(\u0026999).await;\r\n        assert!(result.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------------- */\r\n    /* Unit tests:  cascade deletions behavior    */\r\n    /*------------------------------------------- */\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea utenti e chat\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat tramite CRUD\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Test Chat\".to_string()),\r\n            description: Some(\"Test Description\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi metadata utenti alla chat\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW()), (2, ?, NOW(), NOW(), 'MEMBER', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata esistano\r\n        let metadata_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(metadata_count_before.count, 2);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sui metadata)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che i metadata siano stati eliminati automaticamente\r\n        let metadata_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(metadata_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Chat with Messages\".to_string()),\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi metadata utente\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi messaggi alla chat\r\n        sqlx::query!(\"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, 1, 'Message 1', NOW()), (?, 1, 'Message 2', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi esistano\r\n        let message_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(message_count_before.count, 2);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sui messaggi)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che i messaggi siano stati eliminati automaticamente\r\n        let message_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(message_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_delete_chat_removes_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Chat with Invitations\".to_string()),\r\n            description: None,\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi inviti per la chat\r\n        sqlx::query!(\"INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) VALUES (?, 2, 1, 'PENDING', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti esistano\r\n        let invitation_count_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(invitation_count_before.count, 1);\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE sugli inviti)\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che gli inviti siano stati eliminati automaticamente\r\n        let invitation_count_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\",\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(invitation_count_after.count, 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_complete_chat_lifecycle(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Test completo del ciclo di vita di una chat con tutti gli elementi collegati\r\n        \r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = ChatRepository::new(pool.clone());\r\n        \r\n        // Crea una chat\r\n        let create_dto = CreateChatDTO {\r\n            title: Some(\"Complete Lifecycle Chat\".to_string()),\r\n            description: Some(\"Testing complete CASCADE behavior\".to_string()),\r\n            chat_type: ChatType::Group,\r\n        };\r\n        \r\n        let created_chat = repo.create(\u0026create_dto).await?;\r\n        let chat_id = created_chat.chat_id;\r\n        \r\n        // Aggiungi membri\r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, ?, NOW(), NOW(), 'OWNER', NOW()), (2, ?, NOW(), NOW(), 'MEMBER', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi messaggi\r\n        sqlx::query!(\"INSERT INTO messages (chat_id, sender_id, content, created_at) VALUES (?, 1, 'Hello!', NOW()), (?, 2, 'Hi there!', NOW())\", chat_id, chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Aggiungi inviti\r\n        sqlx::query!(\"INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) VALUES (?, 3, 1, 'PENDING', NOW())\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutto esista\r\n        let metadata_count = sqlx::query!(\"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let message_count = sqlx::query!(\"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let invitation_count = sqlx::query!(\"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        \r\n        assert_eq!(metadata_count, 2);\r\n        assert_eq!(message_count, 2);\r\n        assert_eq!(invitation_count, 1);\r\n        \r\n        // Elimina la chat\r\n        let result = repo.delete(\u0026chat_id).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che tutto sia stato eliminato (CASCADE)\r\n        let metadata_after = sqlx::query!(\"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let message_after = sqlx::query!(\"SELECT COUNT(*) as count FROM messages WHERE chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        let invitation_after = sqlx::query!(\"SELECT COUNT(*) as count FROM invitations WHERE target_chat_id = ?\", chat_id).fetch_one(\u0026pool).await?.count;\r\n        \r\n        assert_eq!(metadata_after, 0);\r\n        assert_eq!(message_after, 0);\r\n        assert_eq!(invitation_after, 0);\r\n        \r\n        // Verifica che gli utenti esistano ancora\r\n        let user_count = sqlx::query!(\"SELECT COUNT(*) as count FROM users\").fetch_one(\u0026pool).await?.count;\r\n        assert_eq!(user_count, 3, \"Gli utenti non dovrebbero essere eliminati\");\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":22,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":93,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":123,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":8,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","invitation.rs"],"content":"//! InvitationRepository - Repository per la gestione degli inviti\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateInvitationDTO, UpdateInvitationDTO};\r\nuse crate::entities::{Invitation, InvitationStatus};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n//INVITATION REPOSITORY\r\npub struct InvitationRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl InvitationRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get all pending invitations for a specific user\r\n    pub async fn find_many_by_user_id(\u0026self, user_id: \u0026i32) -\u003e Result\u003cVec\u003cInvitation\u003e, Error\u003e {\r\n        let invitations = sqlx::query_as!(\r\n            Invitation,\r\n            r#\"\r\n            SELECT \r\n                invite_id,\r\n                target_chat_id,\r\n                invited_id,\r\n                invitee_id,\r\n                state as \"state: InvitationStatus\",\r\n                created_at\r\n            FROM invitations \r\n            WHERE invited_id = ? AND state = 'PENDING'\r\n            \"#,\r\n            user_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(invitations)\r\n    }\r\n\r\n    /// Check if there's already a pending invitation for user to chat\r\n    pub async fn has_pending_invitation(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003cbool, Error\u003e {\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ? AND target_chat_id = ? AND state = 'PENDING'\",\r\n            user_id,\r\n            chat_id\r\n        )\r\n        .fetch_one(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(count.count \u003e 0)\r\n    }\r\n}\r\n\r\nimpl Create\u003cInvitation, CreateInvitationDTO\u003e for InvitationRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %data.target_chat_id, inviter = %data.invitee_id, invited = %data.invited_id))]\r\n    async fn create(\u0026self, data: \u0026CreateInvitationDTO) -\u003e Result\u003cInvitation, Error\u003e {\r\n        debug!(\"Creating new invitation\");\r\n        // Insert invitation using MySQL syntax\r\n        // state e created_at vengono gestiti dal database (default: Pending e NOW())\r\n        let now = chrono::Utc::now();\r\n        let state = InvitationStatus::Pending; // default state\r\n\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO invitations (target_chat_id, invited_id, invitee_id, state, created_at) \r\n            VALUES (?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.target_chat_id,\r\n            data.invited_id,\r\n            data.invitee_id,\r\n            state,\r\n            now\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Invitation created with id {}\", new_id);\r\n\r\n        // Return the created invitation with the new ID\r\n        Ok(Invitation {\r\n            invite_id: new_id,\r\n            target_chat_id: data.target_chat_id,\r\n            invited_id: data.invited_id,\r\n            invitee_id: data.invitee_id,\r\n            state,\r\n            created_at: now,\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cInvitation, i32\u003e for InvitationRepository {\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cInvitation\u003e, Error\u003e {\r\n        let invitation = sqlx::query_as!(\r\n            Invitation,\r\n            r#\"\r\n            SELECT \r\n                invite_id,\r\n                target_chat_id,\r\n                invited_id,\r\n                invitee_id,\r\n                state as \"state: InvitationStatus\",\r\n                created_at\r\n            FROM invitations \r\n            WHERE invite_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(invitation)\r\n    }\r\n}\r\n\r\nimpl Update\u003cInvitation, UpdateInvitationDTO, i32\u003e for InvitationRepository {\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateInvitationDTO) -\u003e Result\u003cInvitation, Error\u003e {\r\n        // First, get the current invitation to ensure it exists\r\n        let current_invitation = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no state to update, return current invitation\r\n        if data.state.is_none() {\r\n            return Ok(current_invitation);\r\n        }\r\n\r\n        // Update invitation state\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = ? WHERE invite_id = ?\",\r\n            data.state,\r\n            id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Fetch and return the updated invitation\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for InvitationRepository {\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\"DELETE FROM invitations WHERE invite_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use sqlx::MySqlPool;\r\n\r\n    // ============================================================================\r\n    // Tests for find_many_by_user_id method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che find_many_by_user_id restituisca solo inviti PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_returns_only_pending(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Assumendo che il fixture \"invitations\" contenga inviti con invited_id = 1\r\n        let user_id = 1;\r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        // Verifica che tutti gli inviti restituiti siano PENDING\r\n        for inv in \u0026invitations {\r\n            assert_eq!(inv.state, InvitationStatus::Pending);\r\n            assert_eq!(inv.invited_id, user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che restituisca un array vuoto per utenti senza inviti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_returns_empty_when_no_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 999; // utente senza inviti\r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        assert!(invitations.is_empty());\r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che gli inviti ACCEPTED/REJECTED siano esclusi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_excludes_non_pending_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Crea un invito PENDING\r\n        let user_id = 2;\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: user_id,\r\n            invitee_id: 3,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito PENDING venga restituito\r\n        let invitations_pending = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(invitations_pending.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Aggiorna lo stato ad ACCEPTED\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = 'ACCEPTED' WHERE invite_id = ?\",\r\n            created.invite_id\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Verifica che l'invito ACCEPTED non venga restituito\r\n        let invitations_after = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminata una chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_chat_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let chat_id = 1;\r\n        \r\n        // Crea un invito per la chat\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 2,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito esista\r\n        let invitations_before = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(invitations_before.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Elimina la chat (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti per quella chat siano stati eliminati in cascata\r\n        let invitations_after = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.target_chat_id == chat_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitante (invitee)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_inviter_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let inviter_id = 1;\r\n        let invited_id = 2;\r\n        \r\n        // Crea un invito dove user 1 invita user 2\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id,\r\n            invitee_id: inviter_id,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che l'invito esista\r\n        let invitations_before = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(invitations_before.iter().any(|inv| inv.invite_id == created.invite_id));\r\n        \r\n        // Elimina l'utente invitante (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti da quell'utente siano stati eliminati in cascata\r\n        let invitations_after = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(!invitations_after.iter().any(|inv| inv.invitee_id == inviter_id));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitato (invited)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_cascade_on_invited_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let inviter_id = 1;\r\n        let invited_id = 2;\r\n        \r\n        // Crea un invito dove user 1 invita user 2\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id,\r\n            invitee_id: inviter_id,\r\n        };\r\n        \r\n        repo.create(\u0026invite).await?;\r\n        \r\n        // Elimina l'utente invitato (se configurato CASCADE DELETE nella FK)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", invited_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti per quell'utente siano stati eliminati in cascata\r\n        // (non dovrebbe esserci nessun invito restituito)\r\n        let invitations_after = repo.find_many_by_user_id(\u0026invited_id).await?;\r\n        assert!(invitations_after.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che restituisca correttamente più inviti PENDING per lo stesso utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_find_many_by_user_id_multiple_pending_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let mut created_ids = Vec::new();\r\n        \r\n        // Crea più inviti PENDING per lo stesso utente\r\n        for chat_id in 2..=3 {\r\n            let invite = CreateInvitationDTO {\r\n                target_chat_id: chat_id,\r\n                invited_id: user_id,\r\n                invitee_id: 1,\r\n            };\r\n            let created = repo.create(\u0026invite).await?;\r\n            created_ids.push(created.invite_id);\r\n        }\r\n        \r\n        let invitations = repo.find_many_by_user_id(\u0026user_id).await?;\r\n        \r\n        // Verifica che tutti gli inviti creati siano restituiti\r\n        for created_id in \u0026created_ids {\r\n            assert!(invitations.iter().any(|inv| inv.invite_id == *created_id));\r\n        }\r\n        \r\n        // Verifica che tutti siano PENDING e per l'utente corretto\r\n        for inv in invitations.iter().filter(|inv| created_ids.contains(\u0026inv.invite_id)) {\r\n            assert_eq!(inv.invited_id, user_id);\r\n            assert_eq!(inv.state, InvitationStatus::Pending);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for has_pending_invitation method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che has_pending_invitation ritorni true per inviti PENDING esistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_returns_true_when_pending_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Bob invita Charlie (user_id=3) al General Chat (chat_id=1) con stato PENDING\r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(has_pending, \"Expected pending invitation to exist\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation ritorni false quando non ci sono inviti PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_returns_false_when_no_pending(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // User e chat che non hanno inviti PENDING\r\n        let user_id = 1;\r\n        let chat_id = 2;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation escluda inviti ACCEPTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_excludes_accepted_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Alice invita Bob (user_id=2) al Dev Team (chat_id=3) con stato ACCEPTED\r\n        let user_id = 2;\r\n        let chat_id = 3;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation (only ACCEPTED exists)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation escluda inviti REJECTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_excludes_rejected_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: Charlie invita Alice (user_id=1) al General Chat (chat_id=1) con stato REJECTED\r\n        let user_id = 1;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation (only REJECTED exists)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation passi da true a false quando l'invito viene accettato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_changes_after_state_update(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        let chat_id = 1;\r\n        \r\n        // Crea un invito PENDING\r\n        let invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite).await?;\r\n        \r\n        // Verifica che sia PENDING\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation after creation\");\r\n        \r\n        // Aggiorna lo stato ad ACCEPTED\r\n        sqlx::query!(\r\n            \"UPDATE invitations SET state = 'ACCEPTED' WHERE invite_id = ?\",\r\n            created.invite_id\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Verifica che non ci sia più un invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after acceptance\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminata la chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_chat_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before chat deletion\");\r\n        \r\n        // Elimina la chat (CASCADE DELETE dovrebbe eliminare gli inviti)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after chat deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_invited_user_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture\r\n        let has_pending_before = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before user deletion\");\r\n        \r\n        // Elimina l'utente invitato (CASCADE DELETE dovrebbe eliminare gli inviti)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after user deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica il comportamento CASCADE quando viene eliminato l'utente invitante\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_cascade_on_inviter_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invited_user_id = 3;\r\n        let inviter_user_id = 2; // Bob è l'invitante\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING dal fixture (Bob invita Charlie)\r\n        let has_pending_before = repo.has_pending_invitation(\u0026invited_user_id, \u0026chat_id).await?;\r\n        assert!(has_pending_before, \"Expected pending invitation before inviter deletion\");\r\n        \r\n        // Elimina l'utente invitante (CASCADE DELETE dovrebbe eliminare gli inviti creati da lui)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che non ci sia più l'invito PENDING\r\n        let has_pending_after = repo.has_pending_invitation(\u0026invited_user_id, \u0026chat_id).await?;\r\n        assert!(!has_pending_after, \"Expected no pending invitation after inviter deletion\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation gestisca correttamente utenti inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_has_pending_invitation_with_nonexistent_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_user_id = 9999;\r\n        let chat_id = 1;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026nonexistent_user_id, \u0026chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation gestisca correttamente chat inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_has_pending_invitation_with_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let nonexistent_chat_id = 9999;\r\n        \r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026nonexistent_chat_id).await?;\r\n        \r\n        assert!(!has_pending, \"Expected no pending invitation for nonexistent chat\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che has_pending_invitation rispetti la UNIQUE constraint (non duplicati PENDING)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_has_pending_invitation_unique_constraint(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 3;\r\n        let chat_id = 1;\r\n        \r\n        // Verifica che esista un invito PENDING\r\n        let has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(has_pending);\r\n        \r\n        // Prova a creare un duplicato (dovrebbe fallire per la UNIQUE constraint)\r\n        let duplicate_invite = CreateInvitationDTO {\r\n            target_chat_id: chat_id,\r\n            invited_id: user_id,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_invite).await;\r\n        \r\n        // Verifica che l'inserimento fallisca\r\n        assert!(result.is_err(), \"Expected duplicate invitation to fail\");\r\n        \r\n        // Verifica che ci sia ancora solo un invito PENDING\r\n        let still_has_pending = repo.has_pending_invitation(\u0026user_id, \u0026chat_id).await?;\r\n        assert!(still_has_pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for CREATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che create crei correttamente un nuovo invito PENDING\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        \r\n        // Verifica che l'invito sia stato creato con i dati corretti\r\n        assert!(created.invite_id \u003e 0);\r\n        assert_eq!(created.target_chat_id, invite_dto.target_chat_id);\r\n        assert_eq!(created.invited_id, invite_dto.invited_id);\r\n        assert_eq!(created.invitee_id, invite_dto.invitee_id);\r\n        assert_eq!(created.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 9999, // chat inesistente\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid chat_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per invited_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_invited_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 9999, // utente inesistente\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid invited_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con FK violation per invitee_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_invitation_fails_with_invalid_inviter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 9999, // utente inesistente\r\n        };\r\n        \r\n        let result = repo.create(\u0026invite_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected FK constraint violation for invalid invitee_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create rispetti la UNIQUE constraint (target_chat_id, invited_id, state)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_create_invitation_fails_with_duplicate(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture esiste già: (target_chat_id=1, invited_id=3, state=PENDING)\r\n        let duplicate_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 3,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected unique constraint violation for duplicate invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possano creare più inviti PENDING per lo stesso utente in chat diverse\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_multiple_invitations_different_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        \r\n        // Crea inviti per chat diverse\r\n        for chat_id in 1..=3 {\r\n            let invite_dto = CreateInvitationDTO {\r\n                target_chat_id: chat_id,\r\n                invited_id: user_id,\r\n                invitee_id: 1,\r\n            };\r\n            \r\n            let created = repo.create(\u0026invite_dto).await?;\r\n            assert_eq!(created.target_chat_id, chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possa creare un invito PENDING se già esiste un invito con stato diverso\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_create_invitation_different_state_allowed(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste (1, 3, PENDING)\r\n        // Prima aggiorna lo stato esistente a REJECTED\r\n        sqlx::query!(\"UPDATE invitations SET state = 'REJECTED' WHERE target_chat_id = 1 AND invited_id = 3\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Ora possiamo creare un nuovo PENDING (perché la UNIQUE è su chat+user+state)\r\n        let new_invite = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 3,\r\n            invitee_id: 2,\r\n        };\r\n        \r\n        let created = repo.create(\u0026new_invite).await?;\r\n        assert_eq!(created.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for READ method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che read restituisca un invito esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id = 1\r\n        let invite_id = 1;\r\n        \r\n        let invitation = repo.read(\u0026invite_id).await?;\r\n        \r\n        assert!(invitation.is_some());\r\n        let inv = invitation.unwrap();\r\n        assert_eq!(inv.invite_id, invite_id);\r\n        assert_eq!(inv.target_chat_id, 1);\r\n        assert_eq!(inv.invited_id, 3);\r\n        assert_eq!(inv.invitee_id, 2);\r\n        assert_eq!(inv.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca None per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let invitation = repo.read(\u0026nonexistent_id).await?;\r\n        \r\n        assert!(invitation.is_none(), \"Expected None for nonexistent invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca l'invito dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 1,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        \r\n        let read_invitation = repo.read(\u0026created.invite_id).await?;\r\n        \r\n        assert!(read_invitation.is_some());\r\n        let inv = read_invitation.unwrap();\r\n        assert_eq!(inv.invite_id, created.invite_id);\r\n        assert_eq!(inv.target_chat_id, created.target_chat_id);\r\n        assert_eq!(inv.invited_id, created.invited_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminata la chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_chat_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è associato a chat_id=1\r\n        let invite_id = 1;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la chat (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 1\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminato l'utente invitato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_invited_user_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 ha invited_id=3\r\n        let invite_id = 1;\r\n        let invited_user_id = 3;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina l'utente invitato (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", invited_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica CASCADE DELETE quando viene eliminato l'utente invitante\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_read_after_inviter_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 ha invitee_id=2 (Bob)\r\n        let invite_id = 1;\r\n        let inviter_user_id = 2;\r\n        \r\n        // Verifica che l'invito esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina l'utente invitante (CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", inviter_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che l'invito sia stato eliminato in cascata\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for UPDATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che update aggiorni correttamente lo stato da PENDING ad ACCEPTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_to_accepted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.invite_id, invite_id);\r\n        assert_eq!(updated.state, InvitationStatus::Accepted);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update aggiorni correttamente lo stato da PENDING a REJECTED\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_to_rejected(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Rejected),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.invite_id, invite_id);\r\n        assert_eq!(updated.state, InvitationStatus::Rejected);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update con state=None non modifichi l'invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_with_no_state_change(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        let before = repo.read(\u0026invite_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        // Lo stato dovrebbe rimanere invariato\r\n        assert_eq!(updated.state, before.state);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update fallisca per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let result = repo.update(\u0026nonexistent_id, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected error for nonexistent invitation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa cambiare stato più volte\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_invitation_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 è PENDING\r\n        let invite_id = 1;\r\n        \r\n        // Prima update: PENDING -\u003e ACCEPTED\r\n        let update1 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        let result1 = repo.update(\u0026invite_id, \u0026update1).await?;\r\n        assert_eq!(result1.state, InvitationStatus::Accepted);\r\n        \r\n        // Seconda update: ACCEPTED -\u003e REJECTED\r\n        let update2 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Rejected),\r\n        };\r\n        let result2 = repo.update(\u0026invite_id, \u0026update2).await?;\r\n        assert_eq!(result2.state, InvitationStatus::Rejected);\r\n        \r\n        // Terza update: REJECTED -\u003e PENDING\r\n        let update3 = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Pending),\r\n        };\r\n        let result3 = repo.update(\u0026invite_id, \u0026update3).await?;\r\n        assert_eq!(result3.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update preservi gli altri campi dell'invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_update_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1\r\n        let invite_id = 1;\r\n        \r\n        let before = repo.read(\u0026invite_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateInvitationDTO {\r\n            state: Some(InvitationStatus::Accepted),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026invite_id, \u0026update_dto).await?;\r\n        \r\n        // Verifica che solo lo stato sia cambiato\r\n        assert_eq!(updated.invite_id, before.invite_id);\r\n        assert_eq!(updated.target_chat_id, before.target_chat_id);\r\n        assert_eq!(updated.invited_id, before.invited_id);\r\n        assert_eq!(updated.invitee_id, before.invitee_id);\r\n        assert_eq!(updated.created_at, before.created_at);\r\n        assert_ne!(updated.state, before.state); // solo lo stato cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for DELETE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che delete elimini correttamente un invito\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_invitation_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: invite_id=1 esiste\r\n        let invite_id = 1;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026invite_id).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina\r\n        repo.delete(\u0026invite_id).await?;\r\n        \r\n        // Verifica che non esista più\r\n        let after = repo.read(\u0026invite_id).await?;\r\n        assert!(after.is_none(), \"Expected invitation to be deleted\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non fallisca per invito inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_invitation_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        // DELETE su id inesistente non dovrebbe dare errore (affected rows = 0 è ok)\r\n        let result = repo.delete(\u0026nonexistent_id).await;\r\n        \r\n        assert!(result.is_ok(), \"Expected delete to succeed even for nonexistent id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete rimuova l'invito dal database\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_removes_from_database(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo invito\r\n        let invite_dto = CreateInvitationDTO {\r\n            target_chat_id: 2,\r\n            invited_id: 2,\r\n            invitee_id: 1,\r\n        };\r\n        \r\n        let created = repo.create(\u0026invite_dto).await?;\r\n        let invite_id = created.invite_id;\r\n        \r\n        // Verifica che esista\r\n        assert!(repo.read(\u0026invite_id).await?.is_some());\r\n        \r\n        // Elimina\r\n        repo.delete(\u0026invite_id).await?;\r\n        \r\n        // Verifica che non sia più recuperabile\r\n        assert!(repo.read(\u0026invite_id).await?.is_none());\r\n        \r\n        // Verifica che non compaia in has_pending_invitation\r\n        let has_pending = repo.has_pending_invitation(\u0026invite_dto.invited_id, \u0026invite_dto.target_chat_id).await?;\r\n        assert!(!has_pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete multipli funzionino correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_multiple_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esistono inviti 1, 2, 3\r\n        let invite_ids = vec![1, 2, 3];\r\n        \r\n        // Elimina tutti\r\n        for id in \u0026invite_ids {\r\n            repo.delete(id).await?;\r\n        }\r\n        \r\n        // Verifica che nessuno esista più\r\n        for id in \u0026invite_ids {\r\n            let result = repo.read(id).await?;\r\n            assert!(result.is_none(), \"Expected invitation {} to be deleted\", id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non influenzi altri inviti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_delete_does_not_affect_other_invitations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esistono inviti 1, 2, 3\r\n        let delete_id = 1;\r\n        let keep_ids = vec![2, 3];\r\n        \r\n        // Elimina solo l'invito 1\r\n        repo.delete(\u0026delete_id).await?;\r\n        \r\n        // Verifica che 1 sia eliminato\r\n        assert!(repo.read(\u0026delete_id).await?.is_none());\r\n        \r\n        // Verifica che 2 e 3 esistano ancora\r\n        for id in keep_ids {\r\n            let result = repo.read(\u0026id).await?;\r\n            assert!(result.is_some(), \"Expected invitation {} to still exist\", id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che si possa ricreare un invito dopo delete\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_recreate_after_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = InvitationRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste (1, 3, PENDING)\r\n        let original = repo.read(\u00261).await?.unwrap();\r\n        \r\n        // Elimina\r\n        repo.delete(\u00261).await?;\r\n        \r\n        // Ricrea con gli stessi dati\r\n        let recreate_dto = CreateInvitationDTO {\r\n            target_chat_id: original.target_chat_id,\r\n            invited_id: original.invited_id,\r\n            invitee_id: original.invitee_id,\r\n        };\r\n        \r\n        let recreated = repo.create(\u0026recreate_dto).await?;\r\n        \r\n        // Verifica che sia stato ricreato (avrà un ID diverso)\r\n        assert_ne!(recreated.invite_id, original.invite_id);\r\n        assert_eq!(recreated.target_chat_id, original.target_chat_id);\r\n        assert_eq!(recreated.invited_id, original.invited_id);\r\n        assert_eq!(recreated.invitee_id, original.invitee_id);\r\n        assert_eq!(recreated.state, InvitationStatus::Pending);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":20,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":21,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":22,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":34,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":37,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":39,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":43,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":48,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":50,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":51,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":53,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":54,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":56,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":62,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":101,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":102,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":103,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":115,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":117,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":118,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":120,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":125,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":127,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":128,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":129,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":130,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":133,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":138,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":140,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":143,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":144,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":152,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":153,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":154,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":155,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":157,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":41,"coverable":41},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","message.rs"],"content":"//! MessageRepository - Repository per la gestione dei messaggi\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateMessageDTO, UpdateMessageDTO};\r\nuse crate::entities::{Message, MessageType};\r\nuse chrono::{DateTime, Utc};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// MESSAGE REPO\r\npub struct MessageRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl MessageRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get paginated messages for a chat within a time range\r\n    ///\r\n    /// Retrieves messages visible to a user based on their `messages_visible_from` timestamp\r\n    /// (from UserChatMetadata). Supports both:\r\n    /// - Loading recent messages (when `before_date` is None): gets the most recent `limit` messages\r\n    /// - Loading older messages (when `before_date` is Some): gets `limit` messages before that date\r\n    ///\r\n    /// # Arguments\r\n    /// * `chat_id` - The chat ID\r\n    /// * `messages_visible_from` - Lower bound timestamp (from UserChatMetadata.messages_visible_from)\r\n    /// * `before_date` - Optional upper bound timestamp for pagination\r\n    /// * `limit` - Maximum number of messages to return\r\n    ///\r\n    /// # Returns\r\n    /// Messages ordered from newest to oldest (DESC), limited to `limit` count\r\n    pub async fn find_many_paginated(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n        messages_visible_from: \u0026DateTime\u003cUtc\u003e,\r\n        before_date: Option\u003c\u0026DateTime\u003cUtc\u003e\u003e,\r\n        limit: i64,\r\n    ) -\u003e Result\u003cVec\u003cMessage\u003e, Error\u003e {\r\n        let messages = if let Some(before) = before_date {\r\n            sqlx::query_as!(\r\n                Message,\r\n                r#\"\r\n                SELECT \r\n                    message_id, \r\n                    chat_id, \r\n                    sender_id, \r\n                    content, \r\n                    created_at,\r\n                    message_type as \"message_type: MessageType\"\r\n                FROM messages \r\n                WHERE chat_id = ? \r\n                  AND created_at \u003e= ? \r\n                  AND created_at \u003c ?\r\n                ORDER BY created_at DESC\r\n                LIMIT ?\r\n                \"#,\r\n                chat_id,\r\n                messages_visible_from,\r\n                before,\r\n                limit\r\n            )\r\n            .fetch_all(\u0026self.connection_pool)\r\n            .await?\r\n        } else {\r\n            sqlx::query_as!(\r\n                Message,\r\n                r#\"\r\n                SELECT \r\n                    message_id, \r\n                    chat_id, \r\n                    sender_id, \r\n                    content, \r\n                    created_at,\r\n                    message_type as \"message_type: MessageType\"\r\n                FROM messages \r\n                WHERE chat_id = ? \r\n                  AND created_at \u003e= ?\r\n                ORDER BY created_at DESC\r\n                LIMIT ?\r\n                \"#,\r\n                chat_id,\r\n                messages_visible_from,\r\n                limit\r\n            )\r\n            .fetch_all(\u0026self.connection_pool)\r\n            .await?\r\n        };\r\n\r\n        Ok(messages)\r\n    }\r\n}\r\n\r\nimpl Create\u003cMessage, CreateMessageDTO\u003e for MessageRepository {\r\n    #[instrument(skip(self, data), fields(chat_id = %data.chat_id, sender_id = %data.sender_id))]\r\n    async fn create(\u0026self, data: \u0026CreateMessageDTO) -\u003e Result\u003cMessage, Error\u003e {\r\n        debug!(\"Creating new message\");\r\n        // Insert message using MySQL syntax\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            INSERT INTO messages (chat_id, sender_id, content, message_type, created_at) \r\n            VALUES (?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.chat_id,\r\n            data.sender_id,\r\n            data.content,\r\n            \u0026data.message_type,\r\n            data.created_at\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"Message created with id {}\", new_id);\r\n\r\n        // Return the created message with the new ID\r\n        Ok(Message {\r\n            message_id: new_id,\r\n            chat_id: data.chat_id,\r\n            sender_id: data.sender_id,\r\n            content: data.content.clone(),\r\n            created_at: data.created_at,\r\n            message_type: data.message_type.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cMessage, i32\u003e for MessageRepository {\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cMessage\u003e, Error\u003e {\r\n        let message = sqlx::query_as!(\r\n            Message,\r\n            r#\"\r\n            SELECT \r\n                message_id, \r\n                chat_id, \r\n                sender_id, \r\n                content, \r\n                created_at,\r\n                message_type as \"message_type: MessageType\"\r\n            FROM messages \r\n            WHERE message_id = ?\r\n            \"#,\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(message)\r\n    }\r\n}\r\n\r\nimpl Update\u003cMessage, UpdateMessageDTO, i32\u003e for MessageRepository {\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateMessageDTO) -\u003e Result\u003cMessage, Error\u003e {\r\n        // First, get the current message to ensure it exists\r\n        let current_message = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no content to update, return current message\r\n        if data.content.is_none() {\r\n            return Ok(current_message);\r\n        }\r\n\r\n        // Update message content\r\n        sqlx::query!(\r\n            \"UPDATE messages SET content = ? WHERE message_id = ?\",\r\n            data.content,\r\n            id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Fetch and return the updated message\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for MessageRepository {\r\n    async fn delete(\u0026self, id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\"DELETE FROM messages WHERE message_id = ?\", id)\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    \r\n    use sqlx::{MySqlPool};\r\n    use super::*;\r\n    use crate::entities::MessageType;\r\n    use chrono::{DateTime, Utc};\r\n\r\n    //------------------------------\r\n    //TESTS FOR find_many_paginated\r\n    //------------------------------\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_recent_messages_without_before_date(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa il recupero dei messaggi più recenti senza before_date\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap(); // Epoca Unix per vedere tutti i messaggi\r\n        let limit = 10;\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, limit).await?;\r\n        \r\n        // Verifica che ci siano 3 messaggi\r\n        assert_eq!(messages.len(), 3);\r\n        \r\n        // Verifica che tutti appartengano alla chat corretta\r\n        for message in \u0026messages {\r\n            assert_eq!(message.chat_id, 1);\r\n        }\r\n        \r\n        // Verifica l'ordinamento (il più recente dovrebbe essere primo)\r\n        // I messaggi con created_at più alta dovrebbero venire prima\r\n        if messages.len() \u003e= 2 {\r\n            assert!(messages[0].created_at \u003e= messages[1].created_at);\r\n        }\r\n        if messages.len() \u003e= 3 {\r\n            assert!(messages[1].created_at \u003e= messages[2].created_at);\r\n        }\r\n        \r\n        // Il messaggio più recente dovrebbe essere quello con INTERVAL 8 MINUTE (più vicino a NOW)\r\n        assert_eq!(messages[0].content, \"Good morning!\");\r\n        assert_eq!(messages[1].content, \"Hi Alice!\");\r\n        assert_eq!(messages[2].content, \"Hello everyone!\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_before_date_filter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Prima recupera tutti i messaggi per ottenere una data di riferimento\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let all_messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Usa la data del secondo messaggio più recente come before_date\r\n        let before_date = all_messages[1].created_at;\r\n        \r\n        let filtered_messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, Some(\u0026before_date), 10).await?;\r\n        \r\n        // Dovrebbe restituire solo i messaggi precedenti alla data specificata (1 messaggio)\r\n        assert_eq!(filtered_messages.len(), 1);\r\n        assert_eq!(filtered_messages[0].content, \"Hello everyone!\");\r\n        \r\n        // Verifica che tutti i messaggi siano anteriori alla data specificata\r\n        for message in \u0026filtered_messages {\r\n            assert!(message.created_at \u003c before_date);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_messages_visible_from_filter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Usa una data nel futuro come messages_visible_from per simulare un utente\r\n        // che è entrato nella chat dopo tutti i messaggi\r\n        let future_date = Utc::now() + chrono::Duration::minutes(5);\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026future_date, None, 10).await?;\r\n        \r\n        // Non dovrebbe restituire alcun messaggio perché tutti sono precedenti a messages_visible_from\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_with_limit(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Hello everyone!', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Hi Alice!', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Good morning!', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let limit = 2; // Limita a 2 messaggi\r\n        \r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, limit).await?;\r\n        \r\n        // Verifica che il limite sia rispettato\r\n        assert_eq!(messages.len(), 2);\r\n        \r\n        // Verifica che siano i 2 più recenti\r\n        assert_eq!(messages[0].content, \"Good morning!\");\r\n        assert_eq!(messages[1].content, \"Hi Alice!\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_nonexistent_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let nonexistent_chat_id = 999;\r\n        \r\n        let messages = repo.find_many_paginated(\u0026nonexistent_chat_id, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Non dovrebbe restituire alcun messaggio per una chat inesistente\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_empty_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea una chat senza messaggi\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (999, 'Empty Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 999, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        \r\n        let messages = repo.find_many_paginated(\u0026999, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        // Chat vuota dovrebbe restituire array vuoto\r\n        assert_eq!(messages.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_message_type_preservation(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Inserisci messaggi di diversi tipi\r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'User message', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 1, 'System message test', 'SYSTEMMESSAGE', NOW() - INTERVAL 5 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let messages = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        \r\n        assert_eq!(messages.len(), 2);\r\n        \r\n        // Verifica che ci sia almeno un messaggio di sistema e uno utente\r\n        let system_messages: Vec\u003c_\u003e = messages.iter()\r\n            .filter(|m| m.message_type == MessageType::SystemMessage)\r\n            .collect();\r\n        let user_messages: Vec\u003c_\u003e = messages.iter()\r\n            .filter(|m| m.message_type == MessageType::UserMessage)\r\n            .collect();\r\n        \r\n        assert_eq!(system_messages.len(), 1);\r\n        assert_eq!(user_messages.len(), 1);\r\n        assert_eq!(system_messages[0].content, \"System message test\");\r\n        assert_eq!(user_messages[0].content, \"User message\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_cascade_behavior_on_chat_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (2, 'Test Chat', 'PRIVATE')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 2, NOW(), NOW(), 'OWNER', NOW()), (2, 2, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (4, 2, 1, 'Test message 1', 'USERMESSAGE', NOW() - INTERVAL 5 MINUTE),\r\n            (5, 2, 2, 'Test message 2', 'USERMESSAGE', NOW() - INTERVAL 4 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Clona il pool prima di passarlo al repository\r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Prima verifica che ci siano messaggi per la chat 2\r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let messages_before = repo.find_many_paginated(\u00262, \u0026messages_visible_from, None, 10).await?;\r\n        assert_eq!(messages_before.len(), 2);\r\n        \r\n        // Elimina la chat 2\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi siano stati eliminati automaticamente\r\n        let messages_after = repo.find_many_paginated(\u00262, \u0026messages_visible_from, None, 10).await?;\r\n        assert_eq!(messages_after.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_find_many_paginated_cascade_behavior_on_user_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test manualmente\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password'), (3, 'charlie', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'General Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW()), (3, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES \r\n            (1, 1, 1, 'Alice message', 'USERMESSAGE', NOW() - INTERVAL 10 MINUTE),\r\n            (2, 1, 2, 'Bob message', 'USERMESSAGE', NOW() - INTERVAL 9 MINUTE),\r\n            (3, 1, 3, 'Charlie message', 'USERMESSAGE', NOW() - INTERVAL 8 MINUTE)\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new((pool).clone());\r\n        \r\n        // Prima verifica che ci siano messaggi dell'utente 2 \r\n        let messages_visible_from = DateTime::from_timestamp(0, 0).unwrap();\r\n        let all_messages_before = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        let bob_messages_before: Vec\u003c_\u003e = all_messages_before.iter()\r\n            .filter(|m| m.sender_id == 2)\r\n            .collect();\r\n        assert_eq!(bob_messages_before.len(), 1);\r\n        assert_eq!(bob_messages_before[0].content, \"Bob message\");\r\n        \r\n        // Elimina l'utente bob \r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i messaggi di bob siano stati eliminati automaticamente\r\n        let all_messages_after = repo.find_many_paginated(\u00261, \u0026messages_visible_from, None, 10).await?;\r\n        let bob_messages_after: Vec\u003c_\u003e = all_messages_after.iter()\r\n            .filter(|m| m.sender_id == 2)\r\n            .collect();\r\n        assert_eq!(bob_messages_after.len(), 0);\r\n        \r\n        // Verifica che gli altri messaggi siano ancora presenti\r\n        assert_eq!(all_messages_after.len(), 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR create\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_create_message_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup: Crea i dati di test necessari\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Crea un DTO per il nuovo messaggio\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Test message content\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        // Testa la creazione\r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che il messaggio sia stato creato correttamente\r\n        assert!(created_message.message_id \u003e 0);\r\n        assert_eq!(created_message.chat_id, create_dto.chat_id);\r\n        assert_eq!(created_message.sender_id, create_dto.sender_id);\r\n        assert_eq!(created_message.content, create_dto.content);\r\n        assert_eq!(created_message.message_type, create_dto.message_type);\r\n        assert_eq!(created_message.created_at, create_dto.created_at);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_system_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'system', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"User joined the chat\".to_string(),\r\n            message_type: MessageType::SystemMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created_message.message_type, MessageType::SystemMessage);\r\n        assert_eq!(created_message.content, \"User joined the chat\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR read\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_read_existing_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Inserisci un messaggio direttamente\r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Test message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la lettura\r\n        let message = repo.read(\u00261).await?;\r\n        \r\n        assert!(message.is_some());\r\n        let message = message.unwrap();\r\n        assert_eq!(message.message_id, 1);\r\n        assert_eq!(message.chat_id, 1);\r\n        assert_eq!(message.sender_id, 1);\r\n        assert_eq!(message.content, \"Test message\");\r\n        assert_eq!(message.message_type, MessageType::UserMessage);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_read_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la lettura di un messaggio inesistente\r\n        let message = repo.read(\u0026999).await?;\r\n        \r\n        assert!(message.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    //------------------------------\r\n    //TESTS FOR update\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_update_message_content(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Original message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Crea DTO per l'aggiornamento\r\n        let update_dto = UpdateMessageDTO {\r\n            content: Some(\"Updated message content\".to_string()),\r\n        };\r\n        \r\n        // Testa l'aggiornamento\r\n        let updated_message = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated_message.message_id, 1);\r\n        assert_eq!(updated_message.content, \"Updated message content\");\r\n        assert_eq!(updated_message.chat_id, 1);\r\n        assert_eq!(updated_message.sender_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_message_with_none_content(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Original message', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // DTO con content = None (nessun aggiornamento)\r\n        let update_dto = UpdateMessageDTO {\r\n            content: None,\r\n        };\r\n        \r\n        // Testa l'aggiornamento con None\r\n        let updated_message = repo.update(\u00261, \u0026update_dto).await?;\r\n        \r\n        // Il messaggio dovrebbe rimanere invariato\r\n        assert_eq!(updated_message.content, \"Original message\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_update_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        let update_dto = UpdateMessageDTO {\r\n            content: Some(\"New content\".to_string()),\r\n        };\r\n        \r\n        // Testa l'aggiornamento di un messaggio inesistente\r\n        let result = repo.update(\u0026999, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err());\r\n        match result {\r\n            Err(sqlx::Error::RowNotFound) =\u003e {}, // Comportamento atteso\r\n            _ =\u003e panic!(\"Expected RowNotFound error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    //------------------------------\r\n    //TESTS FOR delete\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_delete_existing_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        sqlx::query!(\"INSERT INTO messages (message_id, chat_id, sender_id, content, message_type, created_at) VALUES (1, 1, 1, 'Message to delete', 'USERMESSAGE', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Verifica che il messaggio esista prima della cancellazione\r\n        let message_before = repo.read(\u00261).await?;\r\n        assert!(message_before.is_some());\r\n        \r\n        // Testa la cancellazione\r\n        let result = repo.delete(\u00261).await;\r\n        assert!(result.is_ok());\r\n        \r\n        // Verifica che il messaggio sia stato eliminato\r\n        let message_after = repo.read(\u00261).await?;\r\n        assert!(message_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_delete_nonexistent_message(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Testa la cancellazione di un messaggio inesistente\r\n        // Dovrebbe completarsi senza errori (operazione idempotente)\r\n        let result = repo.delete(\u0026999).await;\r\n        assert!(result.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n\r\n    //------------------------------\r\n    //TESTS FOR cascade deletions behavior\r\n    //------------------------------\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_behavior_on_chat_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Crea un messaggio tramite CRUD\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Test message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let created_message = repo.create(\u0026create_dto).await?;\r\n        \r\n        // Verifica che il messaggio esista\r\n        let message_before = repo.read(\u0026created_message.message_id).await?;\r\n        assert!(message_before.is_some());\r\n        \r\n        // Elimina la chat (dovrebbe attivare CASCADE DELETE)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = 1\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il messaggio sia stato eliminato automaticamente\r\n        let message_after = repo.read(\u0026created_message.message_id).await?;\r\n        assert!(message_after.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_crud_cascade_behavior_on_user_deletion(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Setup\r\n        sqlx::query!(\"INSERT INTO users (user_id, username, password) VALUES (1, 'alice', 'password'), (2, 'bob', 'password')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO chats (chat_id, title, chat_type) VALUES (1, 'Test Chat', 'GROUP')\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n            \r\n        sqlx::query!(\"INSERT INTO userchatmetadata (user_id, chat_id, messages_visible_from, messages_received_until, user_role, member_since) VALUES (1, 1, NOW(), NOW(), 'OWNER', NOW()), (2, 1, NOW(), NOW(), 'MEMBER', NOW())\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let repo = MessageRepository::new(pool.clone());\r\n        \r\n        // Crea messaggi per entrambi gli utenti\r\n        let alice_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 1,\r\n            content: \"Alice message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let bob_dto = CreateMessageDTO {\r\n            chat_id: 1,\r\n            sender_id: 2,\r\n            content: \"Bob message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        let alice_message = repo.create(\u0026alice_dto).await?;\r\n        let bob_message = repo.create(\u0026bob_dto).await?;\r\n        \r\n        // Verifica che entrambi i messaggi esistano\r\n        assert!(repo.read(\u0026alice_message.message_id).await?.is_some());\r\n        assert!(repo.read(\u0026bob_message.message_id).await?.is_some());\r\n        \r\n        // Elimina l'utente Bob (dovrebbe attivare CASCADE DELETE sui suoi messaggi)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = 2\")\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il messaggio di Bob sia stato eliminato\r\n        assert!(repo.read(\u0026bob_message.message_id).await?.is_none());\r\n        \r\n        // Verifica che il messaggio di Alice sia ancora presente\r\n        assert!(repo.read(\u0026alice_message.message_id).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    #[sqlx::test]\r\n    async fn test_create_message_with_invalid_foreign_keys(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = MessageRepository::new(pool);\r\n        \r\n        // Tenta di creare un messaggio con chat_id e sender_id inesistenti\r\n        let create_dto = CreateMessageDTO {\r\n            chat_id: 999, // Chat inesistente\r\n            sender_id: 999, // Utente inesistente\r\n            content: \"Test message\".to_string(),\r\n            message_type: MessageType::UserMessage,\r\n            created_at: Utc::now(),\r\n        };\r\n        \r\n        // Dovrebbe fallire a causa dei vincoli di foreign key\r\n        let result = repo.create(\u0026create_dto).await;\r\n        assert!(result.is_err());\r\n        \r\n        // Verifica che sia un errore di foreign key constraint\r\n        match result {\r\n            Err(sqlx::Error::Database(db_err)) =\u003e {\r\n                // MySQL error code per foreign key constraint violation\r\n                assert!(db_err.message().contains(\"foreign key constraint\") || \r\n                    db_err.message().contains(\"Cannot add or update\"));\r\n            },\r\n            _ =\u003e panic!(\"Expected foreign key constraint error\"),\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":35,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":42,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":69,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":85,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":86,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":88,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":89,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":92,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":98,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":133,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":134,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":135,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":147,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":149,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":150,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":152,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":159,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":160,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":165,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":179,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":185,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":186,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":187,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":189,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":45,"coverable":45},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","mod.rs"],"content":"//! Repositories module - Coordinatore per tutti i repository del progetto\r\n//!\r\n//! Questo modulo organizza i repository in sotto-moduli separati per una migliore manutenibilità.\r\n//! Ogni repository gestisce le operazioni di database per una specifica entità.\r\n\r\n// ************************* NOTA IMPORTANTE SU SQLX ************************* //\r\n\r\n/*\r\n   hey tu!\r\n   Leggimi :D\r\n   Ti risparmio un po' di dolore ( non vedere https://docs.rs/sqlx/latest/sqlx/macro.query.html )\r\n   Quando devi fare query con sqlx, ci sono due modi: uno che permette di controllare staticamente\r\n   che la query sia corretta nel senso che lo schema che abbiamo scritto coincida con quello del db\r\n   (ovvero, in fase di compilazione, quella che ci piace perchè vogliamo essere sicuri che vada tutto bene)\r\n   e uno che fa questo check in run-time (che ci fa schifo, quindi evito proprio di parlarne).\r\n   Quindi, come si scrive una query? con la bellissima macro:\r\n   sqlx::query!(\"SELECT id, name FROM users WHERE id = ?\", 1)\r\n   Per evitare di diventare scemi con le maiuscole, si possono scrivere anche in minusolo le keyword\r\n   e si possono scrivere query anche complesse, tipo quelle annidate se serve!\r\n   Ci sarebbe anche un altro modo in realtà di scrivere la query:\r\n   sqlx::query!(\r\n       \"select * from (select (1) as id, 'Herp Derpinson' as name) accounts where id = ?\",\r\n       1i32\r\n   )\r\n   Ovvero inserendo direttamente dentro la stringa il valore, ma non si fam, anche se un valore sappiamo\r\n   Rimanere sempre quello, comunque lo mettiamo con la sintassi che abbiamo visto prima.\r\n   Ovviamente non è finita qui, la query segue il builder pattern con lazy execution -\u003e concateniamo con la dot notation\r\n   le varie operazioni supplementari, tipo: quanti risultati vogliamo ? uno solo, uno o più, almeno uno ...\r\n   ecco le opzioni:\r\n   Number of Rows\tMethod to Call*\tReturns\tNotes\r\n   None†\t        .execute(...).await\t        sqlx::Result\u003cDB::QueryResult\u003e\t            For INSERT/UPDATE/DELETE without RETURNING.\r\n   Zero or One\t    .fetch_optional(...).await\tsqlx::Result\u003cOption\u003c{adhoc struct}\u003e\u003e\t    Extra rows are ignored.\r\n   Exactly One\t    .fetch_one(...).await\t    sqlx::Result\u003c{adhoc struct}\u003e\t            Errors if no rows were returned. Extra rows are ignored. Aggregate queries, use this.\r\n   At Least One\t.fetch(...)\t                impl Stream\u003cItem = sqlx::Result\u003c{adhoc struct}\u003e\u003e\tCall .try_next().await to get each row result.\r\n   Multiple\t    .fetch_all(...)\t            sqlx::Result\u003cVec\u003c{adhoc struct}\u003e\u003e\r\n   abbiamo scritto la query, ma ricordiamoci che è un metodo async quindi dobbiamo concludere con\r\n   await e visto che abbiamo progettato bene le firme, addirittura con await? in modo che l'errore viene propagato al service\r\n   o alla route che poi lo va a gestire restituendo al client l'adeguato codice errore.\r\n   AH! Volevi fosse così semplice! E invece no, perchè si ritorniamo un result, ma questo result deve essere o l'oggetto\r\n   GIA' parsato, oppure l'errore di sqlx :D\r\n\r\n   In questi casi (quindi nella create, update, o nella read) dobbiamo usare al posto di query! -\u003e query_as!\r\n   Questa funzione magica ci fa già il parsing in automatico di quello che ci serve\r\n   Sintassi ( molto simile ) :\r\n   sqlx::query_as!(\r\n       User, // tipo in output\r\n       \"SELECT id, name, email FROM users WHERE id = ?\", //query con placeholder\r\n       1 //valori\r\n   )\r\n   .fetch_one(\u0026pool) //prendi esattamente uno da cosa? dal pool di connessioni della repo!\r\n   .await?;\r\n\r\n   Nota : visto che la compilazione è statica a compile time, se il database non è connesso correttamente o il server\r\n   che contiene mysql non è attivo, il riusltaot è che query_as! e query! danno errore\r\n\r\n\r\n*/\r\n\r\n// ************************* MODULI REPOSITORY ************************* //\r\n\r\n// Dichiarazione dei sotto-moduli\r\npub mod chat;\r\npub mod invitation;\r\npub mod message;\r\npub mod traits;\r\npub mod user;\r\npub mod user_chat_metadata;\r\n\r\n// Re-esportazione dei trait per facilitare l'import\r\npub use traits::{Create, Delete, Read, Update};\r\n\r\n// Note: ReadMany is exported but not yet used. It will be available when needed.\r\n\r\n// Re-esportazione delle struct dei repository per facilitare l'import\r\npub use chat::ChatRepository;\r\npub use invitation::InvitationRepository;\r\npub use message::MessageRepository;\r\npub use user::UserRepository;\r\npub use user_chat_metadata::UserChatMetadataRepository;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","traits.rs"],"content":"//! Common repository traits\r\n//!\r\n//! This module defines generic interfaces for database operations.\r\n\r\n/// Trait for creating new entities in the database\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the returned entity (with ID assigned by the database)\r\n/// * `CreateDTO` - DTO for creation (without ID, will be automatically generated)\r\npub trait Create\u003cEntity, CreateDTO\u003e {\r\n    /// Creates a new entity in the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `data` - DTO containing the data for creation (without ID)\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Entity)` - Created entity with ID assigned by the database\r\n    /// * `Err(sqlx::Error)` - Error during insertion\r\n    async fn create(\u0026self, data: \u0026CreateDTO) -\u003e Result\u003cEntity, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for reading a single entity by primary key\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the entity to read\r\n/// * `Id` - Type of the primary key (e.g. `i32`, `String`, `(i32, i32)`)\r\npub trait Read\u003cEntity, Id\u003e {\r\n    /// Reads an entity from the database by its primary key\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to read\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Some(Entity))` - Entity found\r\n    /// * `Ok(None)` - No entity with that ID\r\n    /// * `Err(sqlx::Error)` - Error during reading\r\n    async fn read(\u0026self, id: \u0026Id) -\u003e Result\u003cOption\u003cEntity\u003e, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for updating existing entities\r\n///\r\n/// # Type Parameters\r\n/// * `Entity` - Type of the updated entity\r\n/// * `UpdateDTO` - DTO for updating (optional fields for partial updates)\r\n/// * `Id` - Type of the primary key\r\npub trait Update\u003cEntity, UpdateDTO, Id\u003e {\r\n    /// Updates an existing entity in the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to update\r\n    /// * `data` - DTO containing the fields to update (only `Some(_)` fields are modified)\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(Entity)` - Updated entity\r\n    /// * `Err(sqlx::Error)` - Error during update (e.g. entity not found)\r\n    async fn update(\u0026self, id: \u0026Id, data: \u0026UpdateDTO) -\u003e Result\u003cEntity, sqlx::Error\u003e;\r\n}\r\n\r\n/// Trait for deleting entities\r\n///\r\n/// # Type Parameters\r\n/// * `Id` - Type of the primary key\r\npub trait Delete\u003cId\u003e {\r\n    /// Deletes an entity from the database\r\n    ///\r\n    /// # Arguments\r\n    /// * `id` - Primary key of the entity to delete\r\n    ///\r\n    /// # Returns\r\n    /// * `Ok(())` - Deletion successful\r\n    /// * `Err(sqlx::Error)` - Error during deletion\r\n    async fn delete(\u0026self, id: \u0026Id) -\u003e Result\u003c(), sqlx::Error\u003e;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","user.rs"],"content":"//! UserRepository - Repository per la gestione degli utenti\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateUserDTO, UpdateUserDTO};\r\nuse crate::entities::User;\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// USER REPO\r\npub struct UserRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl UserRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e UserRepository {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    ///considero l'username univoco\r\n    /// Find user by exact username match\r\n    /// For partial username search, use search_by_username_partial\r\n    #[instrument(skip(self), fields(username = %username))]\r\n    pub async fn find_by_username(\u0026self, username: \u0026String) -\u003e Result\u003cOption\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Finding user by username\");\r\n        let user = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE username = ?\",\r\n            username\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if user.is_some() {\r\n            info!(\"User found\");\r\n        } else {\r\n            debug!(\"User not found\");\r\n        }\r\n\r\n        Ok(user)\r\n    }\r\n\r\n    /// Search users by partial username match (for search functionality)\r\n    #[instrument(skip(self), fields(pattern = %username_pattern))]\r\n    pub async fn search_by_username_partial(\r\n        \u0026self,\r\n        username_pattern: \u0026String,\r\n    ) -\u003e Result\u003cVec\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Searching users with partial username match\");\r\n        let pattern = format!(\"{}%\", username_pattern);\r\n        let users = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE username LIKE ? LIMIT 10\",\r\n            pattern\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"Found {} users matching pattern\", users.len());\r\n        Ok(users)\r\n    }\r\n}\r\n\r\nimpl Create\u003cUser, CreateUserDTO\u003e for UserRepository {\r\n    #[instrument(skip(self, data), fields(username = %data.username))]\r\n    async fn create(\u0026self, data: \u0026CreateUserDTO) -\u003e Result\u003cUser, Error\u003e {\r\n        debug!(\"Creating new user\");\r\n        // Insert user and get the ID using MySQL syntax\r\n        let result = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            data.username,\r\n            data.password\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Get the last inserted ID\r\n        let new_id = result.last_insert_id() as i32;\r\n\r\n        info!(\"User created with id {}\", new_id);\r\n\r\n        // Return the created user with the new ID\r\n        Ok(User {\r\n            user_id: new_id,\r\n            username: data.username.clone(),\r\n            password: data.password.clone(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl Read\u003cUser, i32\u003e for UserRepository {\r\n    #[instrument(skip(self), fields(user_id = %id))]\r\n    async fn read(\u0026self, id: \u0026i32) -\u003e Result\u003cOption\u003cUser\u003e, Error\u003e {\r\n        debug!(\"Reading user by id\");\r\n        let user = sqlx::query_as!(\r\n            User,\r\n            \"SELECT user_id, username, password FROM users WHERE user_id = ?\",\r\n            id\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        if user.is_some() {\r\n            debug!(\"User found\");\r\n        } else {\r\n            debug!(\"User not found\");\r\n        }\r\n\r\n        Ok(user)\r\n    }\r\n}\r\n\r\nimpl Update\u003cUser, UpdateUserDTO, i32\u003e for UserRepository {\r\n    #[instrument(skip(self, data), fields(user_id = %id))]\r\n    async fn update(\u0026self, id: \u0026i32, data: \u0026UpdateUserDTO) -\u003e Result\u003cUser, Error\u003e {\r\n        debug!(\"Updating user\");\r\n        // First, get the current user to ensure it exists\r\n        let current_user = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // Only password can be updated\r\n        if let Some(ref password) = data.password {\r\n            debug!(\"Updating user password\");\r\n            sqlx::query!(\r\n                \"UPDATE users SET password = ? WHERE user_id = ?\",\r\n                password,\r\n                id\r\n            )\r\n            .execute(\u0026self.connection_pool)\r\n            .await?;\r\n\r\n            info!(\"User password updated\");\r\n\r\n            // Fetch and return the updated user\r\n            self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n        } else {\r\n            // If no password provided, return current user unchanged\r\n            debug!(\"No password update provided, returning current user\");\r\n            Ok(current_user)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Delete\u003ci32\u003e for UserRepository {\r\n    /// Soft delete user by setting username to \"Deleted User\" and clearing password \"\"\r\n    /// This preserves message history while anonymizing the user\r\n    #[instrument(skip(self), fields(user_id = %user_id))]\r\n    async fn delete(\u0026self, user_id: \u0026i32) -\u003e Result\u003c(), Error\u003e {\r\n        debug!(\"Soft deleting user\");\r\n        sqlx::query!(\r\n            \"UPDATE users SET username = 'Deleted User', password = '' WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"User soft deleted successfully\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use sqlx::MySqlPool;\r\n\r\n    // ============================================================================\r\n    // Tests for CREATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che create crei correttamente un nuovo utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"new_user\".to_string(),\r\n            password: \"hashed_password_123\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert!(created.user_id \u003e 0);\r\n        assert_eq!(created.username, create_dto.username);\r\n        assert_eq!(created.password, create_dto.password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create fallisca con UNIQUE constraint violation per username duplicato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_fails_with_duplicate_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice esiste già\r\n        let duplicate_dto = CreateUserDTO {\r\n            username: \"alice\".to_string(),\r\n            password: \"some_password\".to_string(),\r\n        };\r\n        \r\n        let result = repo.create(\u0026duplicate_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected unique constraint violation for duplicate username\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create permetta username case-sensitive differenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_case_sensitive_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: \"alice\" esiste (lowercase)\r\n        let uppercase_dto = CreateUserDTO {\r\n            username: \"ALICE\".to_string(),\r\n            password: \"password\".to_string(),\r\n        };\r\n        \r\n        // Questo dovrebbe avere successo se il DB è case-sensitive, altrimenti fallisce\r\n        let result = repo.create(\u0026uppercase_dto).await;\r\n        \r\n        // In MySQL con utf8mb4_unicode_ci (case-insensitive), questo fallisce\r\n        // Se si usa utf8mb4_bin (case-sensitive), avrebbe successo\r\n        // Verifichiamo solo che non ci sia panic\r\n        let _ = result;\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create gestisca password vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_with_empty_password(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"user_empty_pass\".to_string(),\r\n            password: \"\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che create gestisca username e password lunghi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_create_user_with_long_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let long_username = \"a\".repeat(200); // Assumendo che il DB accetti 255 chars\r\n        let long_password = \"b\".repeat(500);\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: long_username.clone(),\r\n            password: long_password.clone(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        assert_eq!(created.username, long_username);\r\n        assert_eq!(created.password, long_password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for READ method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che read restituisca un utente esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_user_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: user_id=1 è alice\r\n        let user_id = 1;\r\n        \r\n        let user = repo.read(\u0026user_id).await?;\r\n        \r\n        assert!(user.is_some());\r\n        let u = user.unwrap();\r\n        assert_eq!(u.user_id, user_id);\r\n        assert_eq!(u.username, \"alice\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca None per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let user = repo.read(\u0026nonexistent_id).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca l'utente dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"test_read\".to_string(),\r\n            password: \"password123\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        let read_user = repo.read(\u0026created.user_id).await?;\r\n        \r\n        assert!(read_user.is_some());\r\n        let u = read_user.unwrap();\r\n        assert_eq!(u.user_id, created.user_id);\r\n        assert_eq!(u.username, created.username);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che read restituisca tutti i campi correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_read_returns_all_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: user_id=2 è bob\r\n        let user_id = 2;\r\n        \r\n        let user = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        assert_eq!(user.user_id, 2);\r\n        assert_eq!(user.username, \"bob\");\r\n        assert!(!user.password.is_empty()); // password esiste\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for UPDATE method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che update aggiorni correttamente la password\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_password_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        let new_password = \"new_hashed_password_456\".to_string();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(new_password.clone()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.user_id, user_id);\r\n        assert_eq!(updated.password, new_password);\r\n        assert_eq!(updated.username, \"alice\"); // username non cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update con password=None non modifichi l'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_with_no_password_change(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        let before = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.user_id, before.user_id);\r\n        assert_eq!(updated.username, before.username);\r\n        assert_eq!(updated.password, before.password);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update fallisca per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"new_password\".to_string()),\r\n        };\r\n        \r\n        let result = repo.update(\u0026nonexistent_id, \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"Expected error for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update preservi username\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_preserves_username(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        let original_username = \"bob\".to_string();\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"totally_new_password\".to_string()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.username, original_username);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa cambiare password a stringa vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_to_empty_password(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        let update_dto = UpdateUserDTO {\r\n            password: Some(\"\".to_string()),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026user_id, \u0026update_dto).await?;\r\n        \r\n        assert_eq!(updated.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update possa essere chiamato più volte\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_update_user_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Primo update\r\n        let update1 = UpdateUserDTO {\r\n            password: Some(\"password1\".to_string()),\r\n        };\r\n        let result1 = repo.update(\u0026user_id, \u0026update1).await?;\r\n        assert_eq!(result1.password, \"password1\");\r\n        \r\n        // Secondo update\r\n        let update2 = UpdateUserDTO {\r\n            password: Some(\"password2\".to_string()),\r\n        };\r\n        let result2 = repo.update(\u0026user_id, \u0026update2).await?;\r\n        assert_eq!(result2.password, \"password2\");\r\n        \r\n        // Terzo update\r\n        let update3 = UpdateUserDTO {\r\n            password: Some(\"password3\".to_string()),\r\n        };\r\n        let result3 = repo.update(\u0026user_id, \u0026update3).await?;\r\n        assert_eq!(result3.password, \"password3\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for DELETE method (Soft Delete)\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che delete esegua soft delete correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_soft_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Verifica stato iniziale\r\n        let before = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(before.username, \"alice\");\r\n        assert!(!before.password.is_empty());\r\n        \r\n        // Soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Verifica che l'utente esista ancora ma sia anonimizzato\r\n        let after = repo.read(\u0026user_id).await?;\r\n        assert!(after.is_some(), \"User should still exist after soft delete\");\r\n        \r\n        let deleted_user = after.unwrap();\r\n        assert_eq!(deleted_user.user_id, user_id);\r\n        assert_eq!(deleted_user.username, \"Deleted User\");\r\n        assert_eq!(deleted_user.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete non fallisca per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_id = 9999;\r\n        \r\n        // Soft delete su utente inesistente non dovrebbe dare errore\r\n        let result = repo.delete(\u0026nonexistent_id).await;\r\n        \r\n        assert!(result.is_ok(), \"Expected soft delete to succeed even for nonexistent user\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete preservi user_id\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_preserves_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 2;\r\n        \r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        let deleted_user = repo.read(\u0026user_id).await?.unwrap();\r\n        \r\n        assert_eq!(deleted_user.user_id, user_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete possa essere chiamato più volte (idempotente)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_delete_user_multiple_times(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Primo soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        let after_first = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(after_first.username, \"Deleted User\");\r\n        \r\n        // Secondo soft delete (dovrebbe essere idempotente)\r\n        repo.delete(\u0026user_id).await?;\r\n        let after_second = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(after_second.username, \"Deleted User\");\r\n        assert_eq!(after_second.password, \"\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che delete mantenga la cronologia dei messaggi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_delete_preserves_message_history(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1; // Alice ha messaggi nei fixtures\r\n        \r\n        // Conta i messaggi prima del soft delete\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // Soft delete\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Conta i messaggi dopo il soft delete\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // I messaggi dovrebbero essere preservati\r\n        assert_eq!(messages_before.count, messages_after.count);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for find_by_username method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che find_by_username trovi un utente esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let username = \"alice\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026username).await?;\r\n        \r\n        assert!(user.is_some());\r\n        let u = user.unwrap();\r\n        assert_eq!(u.username, username);\r\n        assert_eq!(u.user_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username restituisca None per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let nonexistent_username = \"nonexistent_user\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026nonexistent_username).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for nonexistent username\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username sia exact match (non parziale)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_exact_match_only(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: esiste \"alice\", cerco \"alic\" (parziale)\r\n        let partial_username = \"alic\".to_string();\r\n        \r\n        let user = repo.find_by_username(\u0026partial_username).await?;\r\n        \r\n        assert!(user.is_none(), \"Expected None for partial match\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username trovi utente dopo create\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_after_create(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let create_dto = CreateUserDTO {\r\n            username: \"findme\".to_string(),\r\n            password: \"password\".to_string(),\r\n        };\r\n        \r\n        let created = repo.create(\u0026create_dto).await?;\r\n        \r\n        let found = repo.find_by_username(\u0026create_dto.username).await?;\r\n        \r\n        assert!(found.is_some());\r\n        assert_eq!(found.unwrap().user_id, created.user_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che find_by_username trovi utente soft-deleted\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_find_by_username_after_soft_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1;\r\n        \r\n        // Soft delete alice\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Cerca \"Deleted User\"\r\n        let deleted_user = repo.find_by_username(\u0026\"Deleted User\".to_string()).await?;\r\n        \r\n        // Dovrebbe trovare almeno un utente con \"Deleted User\"\r\n        assert!(deleted_user.is_some());\r\n        \r\n        // Non dovrebbe più trovare \"alice\"\r\n        let alice = repo.find_by_username(\u0026\"alice\".to_string()).await?;\r\n        assert!(alice.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for search_by_username_partial method\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che search_by_username_partial trovi utenti con pattern\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice, bob, charlie\r\n        let pattern = \"a\".to_string(); // dovrebbe trovare alice e charlie\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(!users.is_empty());\r\n        // Verifica che tutti i risultati inizino con \"a\"\r\n        for user in users {\r\n            assert!(user.username.starts_with(\"a\"));\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial restituisca array vuoto per nessun match\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_no_match(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let pattern = \"xyz\".to_string(); // nessun utente inizia con xyz\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(users.is_empty(), \"Expected empty array for no matches\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial limiti i risultati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_limit(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Crea 15 utenti che iniziano con \"test\"\r\n        for i in 0..15 {\r\n            let create_dto = CreateUserDTO {\r\n                username: format!(\"test_user_{}\", i),\r\n                password: \"password\".to_string(),\r\n            };\r\n            repo.create(\u0026create_dto).await?;\r\n        }\r\n        \r\n        let pattern = \"test\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        // Dovrebbe restituire al massimo 10 risultati (LIMIT 10)\r\n        assert!(users.len() \u003c= 10, \"Expected at most 10 results\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial trovi tutti i match\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_finds_all_matches(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: bob inizia con \"b\"\r\n        let pattern = \"b\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026pattern).await?;\r\n        \r\n        assert!(users.iter().any(|u| u.username == \"bob\"));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che search_by_username_partial sia case-insensitive\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\")))]\r\n    async fn test_search_by_username_partial_case_insensitive(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        // Dal fixture: alice esiste (lowercase)\r\n        let uppercase_pattern = \"A\".to_string();\r\n        \r\n        let users = repo.search_by_username_partial(\u0026uppercase_pattern).await?;\r\n        \r\n        // Con utf8mb4_unicode_ci (case-insensitive), dovrebbe trovare alice\r\n        // Se non trova nulla, il DB potrebbe essere case-sensitive\r\n        let found_alice = users.iter().any(|u| u.username.to_lowercase() == \"alice\");\r\n        \r\n        // Questo test potrebbe passare o fallire a seconda del collation del DB\r\n        // Lo lasciamo per documentazione\r\n        let _ = found_alice;\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    // ============================================================================\r\n    // Tests for CASCADE behaviors with related tables\r\n    // ============================================================================\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su invitations (invited_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_hard_delete_user_cascades_to_invitations_invited(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Note: questo test usa HARD DELETE invece di soft delete per verificare CASCADE\r\n        \r\n        let user_id = 3; // Charlie è invited_id in alcuni inviti\r\n        \r\n        // Conta inviti per Charlie prima\r\n        let invitations_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(invitations_before.count \u003e 0, \"Charlie should have invitations\");\r\n        \r\n        // HARD DELETE (non soft delete)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che gli inviti siano stati eliminati per CASCADE\r\n        let invitations_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invited_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(invitations_after.count, 0, \"Invitations should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su invitations (invitee_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"invitations\")))]\r\n    async fn test_hard_delete_user_cascades_to_invitations_inviter(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 2; // Bob è invitee_id in alcuni inviti\r\n        \r\n        // Conta inviti creati da Bob prima\r\n        let invitations_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invitee_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(invitations_before.count \u003e 0, \"Bob should have created invitations\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let invitations_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM invitations WHERE invitee_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(invitations_after.count, 0, \"Invitations should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su messages\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_hard_delete_user_cascades_to_messages(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 1; // Alice ha messaggi\r\n        \r\n        // Conta messaggi prima\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(messages_before.count \u003e 0, \"Alice should have messages\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(messages_after.count, 0, \"Messages should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che HARD delete di user causi CASCADE DELETE su userchatmetadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_hard_delete_user_cascades_to_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let user_id = 1; // Alice è membro di varie chat\r\n        \r\n        // Conta metadata prima\r\n        let metadata_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert!(metadata_before.count \u003e 0, \"Alice should have chat metadata\");\r\n        \r\n        // HARD DELETE\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica CASCADE\r\n        let metadata_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(metadata_after.count, 0, \"Metadata should be deleted via CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che soft delete NON causi CASCADE (preserva relazioni)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_soft_delete_preserves_relations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserRepository::new(pool.clone());\r\n        \r\n        let user_id = 1; // Alice\r\n        \r\n        // Conta messaggi prima\r\n        let messages_before = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        // SOFT DELETE tramite repository\r\n        repo.delete(\u0026user_id).await?;\r\n        \r\n        // Verifica che i messaggi siano ancora presenti\r\n        let messages_after = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM messages WHERE sender_id = ?\",\r\n            user_id\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        \r\n        assert_eq!(messages_before.count, messages_after.count, \"Messages should be preserved with soft delete\");\r\n        \r\n        // Verifica che l'utente sia anonimizzato ma esista\r\n        let user = repo.read(\u0026user_id).await?.unwrap();\r\n        assert_eq!(user.username, \"Deleted User\");\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":23,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":92,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":114,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":123,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":149,"address":[],"length":0,"stats":{"Line":1152921504606846976}}],"covered":8,"coverable":8},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","repositories","user_chat_metadata.rs"],"content":"//! UserChatMetadataRepository - Repository per la gestione dei metadati utente-chat\r\n\r\nuse super::{Create, Delete, Read, Update};\r\nuse crate::dtos::{CreateUserChatMetadataDTO, UpdateUserChatMetadataDTO};\r\nuse crate::entities::{UserChatMetadata, UserRole};\r\nuse sqlx::{Error, MySqlPool};\r\nuse tracing::{debug, info, instrument};\r\n\r\n// USERCHATMETADATA REPO\r\npub struct UserChatMetadataRepository {\r\n    connection_pool: MySqlPool,\r\n}\r\n\r\nimpl UserChatMetadataRepository {\r\n    pub fn new(connection_pool: MySqlPool) -\u003e Self {\r\n        Self { connection_pool }\r\n    }\r\n\r\n    /// Get all members of a specific chat\r\n    pub async fn find_many_by_chat_id(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let metadata_list = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n            SELECT \r\n                user_id,\r\n                chat_id,\r\n                user_role as \"user_role: UserRole\",\r\n                member_since,\r\n                messages_visible_from,\r\n                messages_received_until\r\n            FROM userchatmetadata \r\n            WHERE chat_id = ?\r\n            \"#,\r\n            chat_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(metadata_list)\r\n    }\r\n\r\n    /// Transfer ownership from one user to another in a chat\r\n    pub async fn transfer_ownership(\r\n        \u0026self,\r\n        from_user_id: \u0026i32,\r\n        to_user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n    ) -\u003e Result\u003c(), Error\u003e {\r\n        // Start a transaction for atomicity\r\n        let mut tx = self.connection_pool.begin().await?;\r\n\r\n        // Update the old owner to admin\r\n        sqlx::query!(\r\n            \"UPDATE userchatmetadata SET user_role = 'ADMIN' WHERE user_id = ? AND chat_id = ?\",\r\n            from_user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026mut *tx)\r\n        .await?;\r\n\r\n        // Update the new owner\r\n        sqlx::query!(\r\n            \"UPDATE userchatmetadata SET user_role = 'OWNER' WHERE user_id = ? AND chat_id = ?\",\r\n            to_user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026mut *tx)\r\n        .await?;\r\n\r\n        // Commit the transaction\r\n        tx.commit().await?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Get all chats for a specific user\r\n    pub async fn find_many_by_user_id(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let result = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n        SELECT\r\n            user_id,\r\n            chat_id,\r\n            user_role as \"user_role: UserRole\",\r\n            member_since,\r\n            messages_visible_from,\r\n            messages_received_until\r\n        FROM userchatmetadata\r\n        WHERE user_id = ?\r\n        \"#,\r\n            user_id\r\n        )\r\n        .fetch_all(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(result)\r\n    }\r\n\r\n    /// Create multiple metadata entries in a single transaction\r\n    /// Ensures atomicity: either all are created or none\r\n    pub async fn create_many(\r\n        \u0026self,\r\n        metadata_list: \u0026[CreateUserChatMetadataDTO],\r\n    ) -\u003e Result\u003cVec\u003cUserChatMetadata\u003e, Error\u003e {\r\n        if metadata_list.is_empty() {\r\n            return Ok(Vec::new());\r\n        }\r\n\r\n        let mut tx = self.connection_pool.begin().await?;\r\n\r\n        let mut created = Vec::with_capacity(metadata_list.len());\r\n\r\n        for data in metadata_list {\r\n            sqlx::query!(\r\n                r#\"\r\n                INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until) \r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n                \"#,\r\n                data.user_id,\r\n                data.chat_id,\r\n                data.user_role,\r\n                data.member_since,\r\n                data.messages_visible_from,\r\n                data.messages_received_until\r\n            )\r\n            .execute(\u0026mut *tx)\r\n            .await?;\r\n\r\n            created.push(UserChatMetadata {\r\n                user_id: data.user_id,\r\n                chat_id: data.chat_id,\r\n                user_role: data.user_role.clone(),\r\n                member_since: data.member_since,\r\n                messages_visible_from: data.messages_visible_from,\r\n                messages_received_until: data.messages_received_until,\r\n            });\r\n        }\r\n\r\n        tx.commit().await?;\r\n\r\n        Ok(created)\r\n    }\r\n\r\n    pub async fn update_user_role(\r\n        \u0026self,\r\n        user_id: \u0026i32,\r\n        chat_id: \u0026i32,\r\n        new_role: \u0026UserRole,\r\n    ) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        // Mappo l'enum sul valore testuale usato in DB\r\n        let role_str = match new_role {\r\n            UserRole::Owner =\u003e \"OWNER\",\r\n            UserRole::Admin =\u003e \"ADMIN\",\r\n            UserRole::Member =\u003e \"MEMBER\",\r\n        };\r\n\r\n        // UPDATE mirato su chiave composta (user_id, chat_id)\r\n        let result = sqlx::query!(\r\n            r#\"\r\n            UPDATE userchatmetadata\r\n            SET user_role = ?\r\n            WHERE user_id = ? AND chat_id = ?\r\n            \"#,\r\n            role_str,\r\n            user_id,\r\n            chat_id\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        // Se nessuna riga è stata toccata, la coppia (user_id, chat_id) non esiste\r\n        if result.rows_affected() == 0 {\r\n            return Err(sqlx::Error::RowNotFound);\r\n        }\r\n\r\n        // Ritorno il record aggiornato\r\n        self.read(\u0026(*user_id, *chat_id))\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Create\u003cUserChatMetadata, CreateUserChatMetadataDTO\u003e for UserChatMetadataRepository {\r\n    #[instrument(skip(self, data), fields(user_id = %data.user_id, chat_id = %data.chat_id))]\r\n    async fn create(\u0026self, data: \u0026CreateUserChatMetadataDTO) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        debug!(\"Creating new user chat metadata\");\r\n        // Insert metadata using MySQL syntax\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata \r\n            (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until) \r\n            VALUES (?, ?, ?, ?, ?, ?)\r\n            \"#,\r\n            data.user_id,\r\n            data.chat_id,\r\n            data.user_role,\r\n            data.member_since,\r\n            data.messages_visible_from,\r\n            data.messages_received_until\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        info!(\"User chat metadata created for user {} in chat {}\", data.user_id, data.chat_id);\r\n\r\n        // Return the created metadata\r\n        Ok(UserChatMetadata {\r\n            user_id: data.user_id,\r\n            chat_id: data.chat_id,\r\n            user_role: data.user_role.clone(),\r\n            member_since: data.member_since,\r\n            messages_visible_from: data.messages_visible_from,\r\n            messages_received_until: data.messages_received_until,\r\n        })\r\n    }\r\n}\r\n\r\n/// Alias per chiarezza: tipo usato come 'ID' composto per le operazioni\r\n/// su `UserChatMetadata`.\r\n/// Convenzione:\r\n/// - `UserChatKey.0` =\u003e `user_id`\r\n/// - `UserChatKey.1` =\u003e `chat_id`\r\n///\r\n/// Usare questo alias nelle firme di `read`, `update`, `delete` aiuta\r\n/// l'IDE a mostrare la documentazione quando si richiama quelle funzioni.\r\npub type UserChatKey = (i32, i32);\r\n\r\nimpl Read\u003cUserChatMetadata, UserChatKey\u003e for UserChatMetadataRepository {\r\n    async fn read(\u0026self, id: \u0026UserChatKey) -\u003e Result\u003cOption\u003cUserChatMetadata\u003e, Error\u003e {\r\n        let metadata = sqlx::query_as!(\r\n            UserChatMetadata,\r\n            r#\"\r\n            SELECT \r\n                user_id,\r\n                chat_id,\r\n                user_role as \"user_role: UserRole\",\r\n                member_since,\r\n                messages_visible_from,\r\n                messages_received_until\r\n            FROM userchatmetadata \r\n            WHERE user_id = ? \r\n            AND chat_id = ?\r\n            \"#,\r\n            id.0,\r\n            id.1\r\n        )\r\n        .fetch_optional(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(metadata)\r\n    }\r\n}\r\n\r\nimpl Update\u003cUserChatMetadata, UpdateUserChatMetadataDTO, UserChatKey\u003e\r\n    for UserChatMetadataRepository\r\n{\r\n    async fn update(\r\n        \u0026self,\r\n        id: \u0026UserChatKey,\r\n        data: \u0026UpdateUserChatMetadataDTO,\r\n    ) -\u003e Result\u003cUserChatMetadata, Error\u003e {\r\n        // First, get the current metadata to ensure it exists\r\n        let current_metadata = self\r\n            .read(id)\r\n            .await?\r\n            .ok_or_else(|| sqlx::Error::RowNotFound)?;\r\n\r\n        // If no fields to update, return current metadata\r\n        if data.user_role.is_none()\r\n            \u0026\u0026 data.messages_visible_from.is_none()\r\n            \u0026\u0026 data.messages_received_until.is_none()\r\n        {\r\n            return Ok(current_metadata);\r\n        }\r\n\r\n        // Build dynamic UPDATE query using QueryBuilder (idiomatic SQLx way)\r\n        let mut query_builder = sqlx::QueryBuilder::new(\"UPDATE userchatmetadata SET \");\r\n\r\n        let mut separated = query_builder.separated(\", \");\r\n        if let Some(ref role) = data.user_role {\r\n            separated.push(\"user_role = \");\r\n            separated.push_bind_unseparated(role);\r\n        }\r\n        if let Some(ref visible_from) = data.messages_visible_from {\r\n            separated.push(\"messages_visible_from = \");\r\n            separated.push_bind_unseparated(visible_from);\r\n        }\r\n        if let Some(ref received_until) = data.messages_received_until {\r\n            separated.push(\"messages_received_until = \");\r\n            separated.push_bind_unseparated(received_until);\r\n        }\r\n\r\n        query_builder.push(\" WHERE user_id = \");\r\n        query_builder.push_bind(id.0);\r\n\r\n        query_builder.push(\" AND chat_id = \");\r\n        query_builder.push_bind(id.1);\r\n\r\n        query_builder.build().execute(\u0026self.connection_pool).await?;\r\n\r\n        // Fetch and return the updated metadata\r\n        self.read(id).await?.ok_or_else(|| sqlx::Error::RowNotFound)\r\n    }\r\n}\r\n\r\nimpl Delete\u003cUserChatKey\u003e for UserChatMetadataRepository {\r\n    async fn delete(\u0026self, id: \u0026UserChatKey) -\u003e Result\u003c(), Error\u003e {\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id=?\",\r\n            id.0,\r\n            id.1\r\n        )\r\n        .execute(\u0026self.connection_pool)\r\n        .await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::entities::UserRole;\r\n    use sqlx::MySqlPool;\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: find_many_by_chat_id */\r\n    /*----------------------------------*/\r\n\r\n    /// Test: trova tutti i membri di una chat esistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // La \"General Chat\" (chat_id=1) ha 3 membri: alice, bob, charlie\r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti gli user_id siano presenti\r\n        let user_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.user_id).collect();\r\n        assert!(user_ids.contains(\u00261)); // alice\r\n        assert!(user_ids.contains(\u00262)); // bob\r\n        assert!(user_ids.contains(\u00263)); // charlie\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trova i membri di una chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // La chat privata Alice-Bob (chat_id=2) ha 2 membri\r\n        let result = repo.find_many_by_chat_id(\u00262).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let user_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.user_id).collect();\r\n        assert!(user_ids.contains(\u00261)); // alice\r\n        assert!(user_ids.contains(\u00262)); // bob\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: restituisce lista vuota per chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Chat inesistente\r\n        let result = repo.find_many_by_chat_id(\u0026999).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i ruoli siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_with_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // General Chat (chat_id=1): alice=OWNER, bob=MEMBER, charlie=MEMBER\r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        // Trova alice (user_id=1)\r\n        let alice_metadata = result.iter().find(|m| m.user_id == 1).unwrap();\r\n        assert_eq!(alice_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        // Trova bob (user_id=2)\r\n        let bob_metadata = result.iter().find(|m| m.user_id == 2).unwrap();\r\n        assert_eq!(bob_metadata.user_role, Some(UserRole::Member));\r\n        \r\n        // Trova charlie (user_id=3)\r\n        let charlie_metadata = result.iter().find(|m| m.user_id == 3).unwrap();\r\n        assert_eq!(charlie_metadata.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica i diversi ruoli in una chat (OWNER, ADMIN, MEMBER)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_different_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Dev Team (chat_id=3): alice=OWNER, charlie=ADMIN\r\n        let result = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let alice = result.iter().find(|m| m.user_id == 1).unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Owner));\r\n        \r\n        let charlie = result.iter().find(|m| m.user_id == 3).unwrap();\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina i suoi metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: General Chat ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina Bob (user_id=2)\r\n        // CASCADE DELETE eliminerà i suoi metadata in tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: General Chat dovrebbe avere solo 2 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che Bob non sia più presente\r\n        let user_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.user_id).collect();\r\n        assert!(!user_ids.contains(\u00262)); // bob non c'è più\r\n        assert!(user_ids.contains(\u00261)); // alice c'è ancora\r\n        assert!(user_ids.contains(\u00263)); // charlie c'è ancora\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat elimina tutti i metadata associati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina la chat\r\n        // CASCADE DELETE eliminerà tutti i metadata associati\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: nessun metadata dovrebbe esistere per quella chat\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Verifica nel database che i metadata siano stati eliminati\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE chat_id = ?\",\r\n            1\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(count.count, 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di utente che è OWNER in più chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER in chat 1, 2 e 3\r\n        // Verifica stato iniziale\r\n        let chat1_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        let chat2_before = repo.find_many_by_chat_id(\u00262).await?;\r\n        let chat3_before = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(chat1_before.len(), 3); // General Chat\r\n        assert_eq!(chat2_before.len(), 2); // Private Alice-Bob\r\n        assert_eq!(chat3_before.len(), 2); // Dev Team\r\n        \r\n        // Elimina Alice\r\n        // CASCADE eliminerà i suoi metadata da tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che Alice sia stata rimossa da tutte le chat\r\n        let chat1_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        let chat2_after = repo.find_many_by_chat_id(\u00262).await?;\r\n        let chat3_after = repo.find_many_by_chat_id(\u00263).await?;\r\n        \r\n        assert_eq!(chat1_after.len(), 2); // bob e charlie rimangono\r\n        assert_eq!(chat2_after.len(), 1); // solo bob rimane\r\n        assert_eq!(chat3_after.len(), 1); // solo charlie rimane\r\n        \r\n        // Verifica che Alice non sia in nessuna chat\r\n        assert!(!chat1_after.iter().any(|m| m.user_id == 1));\r\n        assert!(!chat2_after.iter().any(|m| m.user_id == 1));\r\n        assert!(!chat3_after.iter().any(|m| m.user_id == 1));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiunta di un nuovo membro e verifica che sia trovato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_after_adding_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Dev Team (chat_id=3) inizialmente ha 2 membri: alice e charlie\r\n        let result_before = repo.find_many_by_chat_id(\u00263).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Aggiungi Bob al Dev Team\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until)\r\n            VALUES (?, ?, 'MEMBER', NOW(), NOW(), NOW())\r\n            \"#,\r\n            2, 3\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora dovrebbe avere 3 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00263).await?;\r\n        assert_eq!(result_after.len(), 3);\r\n        \r\n        // Verifica che Bob sia presente\r\n        let bob = result_after.iter().find(|m| m.user_id == 2);\r\n        assert!(bob.is_some());\r\n        assert_eq!(bob.unwrap().user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: rimozione di un membro specifico\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_after_removing_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Rimuovi Charlie dalla General Chat\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id = ?\",\r\n            3, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora dovrebbe avere 2 membri\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che Charlie non ci sia più\r\n        assert!(!result_after.iter().any(|m| m.user_id == 3));\r\n        \r\n        // Ma alice e bob dovrebbero essere ancora presenti\r\n        assert!(result_after.iter().any(|m| m.user_id == 1));\r\n        assert!(result_after.iter().any(|m| m.user_id == 2));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i timestamp siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_with_timestamps(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.find_many_by_chat_id(\u00261).await?;\r\n        \r\n        // Verifica che tutti i membri abbiano timestamp validi\r\n        for metadata in result {\r\n            assert!(metadata.member_since \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_visible_from \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_received_until \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di più utenti contemporaneamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_chat_id_cascade_delete_multiple_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat (chat_id=1) ha 3 membri\r\n        let result_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina Bob e Charlie\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id IN (?, ?)\", 2, 3)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dovrebbe rimanere solo Alice\r\n        let result_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 1);\r\n        assert_eq!(result_after[0].user_id, 1);\r\n        assert_eq!(result_after[0].user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*--------------------------------*/\r\n    /* Unit tests: transfer_ownership */\r\n    /*--------------------------------*/\r\n\r\n    /// Test: trasferimento di ownership da un utente ad un altro\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER della General Chat (chat_id=1)\r\n        // Bob (user_id=2) è MEMBER della General Chat\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        assert_eq!(bob_before.user_role, Some(UserRole::Member));\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Dopo il trasferimento:\r\n        // Alice dovrebbe essere ADMIN\r\n        // Bob dovrebbe essere OWNER\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership da OWNER ad ADMIN\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_owner_to_admin(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Dev Team (chat_id=3): alice=OWNER, charlie=ADMIN\r\n        let alice_before = repo.read(\u0026(1, 3)).await?.unwrap();\r\n        let charlie_before = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        assert_eq!(charlie_before.user_role, Some(UserRole::Admin));\r\n        \r\n        // Trasferisci ownership da Alice a Charlie\r\n        repo.transfer_ownership(\u00261, \u00263, \u00263).await?;\r\n        \r\n        // Alice dovrebbe diventare ADMIN\r\n        // Charlie dovrebbe diventare OWNER\r\n        let alice_after = repo.read(\u0026(1, 3)).await?.unwrap();\r\n        let charlie_after = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership in chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Private Alice-Bob (chat_id=2): alice=OWNER, bob=MEMBER\r\n        repo.transfer_ownership(\u00261, \u00262, \u00262).await?;\r\n        \r\n        let alice = repo.read(\u0026(1, 2)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 2)).await?.unwrap();\r\n        \r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità della transazione - entrambe le operazioni devono avere successo\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_atomicity(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Verifica stato iniziale\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Trasferimento valido\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica che entrambe le modifiche siano state applicate\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento con utente non esistente nel database\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_nonexistent_target(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato prima del tentativo\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Tentativo di trasferire ownership a un utente inesistente (999)\r\n        // Il database non dovrebbe avere un utente con id 999 in questa chat\r\n        let result = repo.transfer_ownership(\u00261, \u0026999, \u00261).await;\r\n        \r\n        // L'operazione dovrebbe completarsi senza errori anche se l'utente target non esiste\r\n        // perché MySQL UPDATE su righe inesistenti non genera errore\r\n        assert!(result.is_ok());\r\n        \r\n        // Alice dovrebbe essere diventata ADMIN (prima parte dell'operazione)\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione del vecchio owner dopo trasferimento\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_old_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob nella General Chat\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina Alice (ex-owner, ora admin)\r\n        // CASCADE eliminerà i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice non dovrebbe più esistere nei metadata\r\n        let alice = repo.read(\u0026(1, 1)).await?;\r\n        assert!(alice.is_none());\r\n        \r\n        // Bob dovrebbe essere ancora owner\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        // La chat dovrebbe avere 2 membri invece di 3\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione del nuovo owner dopo trasferimento\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_new_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina Bob (nuovo owner)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe più esistere\r\n        let bob_after = repo.read(\u0026(2, 1)).await?;\r\n        assert!(bob_after.is_none());\r\n        \r\n        // Alice (ora admin) dovrebbe essere ancora presente\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione della chat dopo trasferimento ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // Elimina la chat\r\n        // CASCADE eliminerà tutti i metadata associati\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessun metadata dovrebbe esistere per questa chat\r\n        let alice_after = repo.read(\u0026(1, 1)).await?;\r\n        let bob_after = repo.read(\u0026(2, 1)).await?;\r\n        \r\n        assert!(alice_after.is_none());\r\n        assert!(bob_after.is_none());\r\n        \r\n        // Verifica che la chat non abbia membri\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: doppio trasferimento di ownership (A-\u003eB-\u003eC)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_chain(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale: alice=OWNER, bob=MEMBER, charlie=MEMBER\r\n        // Primo trasferimento: Alice -\u003e Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        let alice_after_first = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after_first = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_after_first.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after_first.user_role, Some(UserRole::Owner));\r\n        \r\n        // Secondo trasferimento: Bob -\u003e Charlie\r\n        repo.transfer_ownership(\u00262, \u00263, \u00261).await?;\r\n        \r\n        let bob_after_second = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie_after_second = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(bob_after_second.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie_after_second.user_role, Some(UserRole::Owner));\r\n        \r\n        // Alice dovrebbe essere ancora admin (non modificata nel secondo trasferimento)\r\n        let alice_final = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_final.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trasferimento ownership e poi rollback manuale\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_and_rollback(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica il trasferimento\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        // \"Rollback\" manuale: ritrasferisci ownership da Bob ad Alice\r\n        repo.transfer_ownership(\u00262, \u00261, \u00261).await?;\r\n        \r\n        // Verifica che siamo tornati allo stato originale (quasi)\r\n        let alice_final = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_final = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(alice_final.user_role, Some(UserRole::Owner));\r\n        assert_eq!(bob_final.user_role, Some(UserRole::Admin)); // Bob era MEMBER, ora è ADMIN\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che il trasferimento non modifichi altri campi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_transfer_ownership_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Salva i valori iniziali\r\n        let alice_before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        let alice_member_since = alice_before.member_since;\r\n        let alice_visible_from = alice_before.messages_visible_from;\r\n        let bob_member_since = bob_before.member_since;\r\n        let bob_visible_from = bob_before.messages_visible_from;\r\n        \r\n        // Trasferisci ownership\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Verifica che solo user_role sia cambiato\r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        let bob_after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        \r\n        // Verifica che i timestamp non siano cambiati\r\n        assert_eq!(alice_after.member_since, alice_member_since);\r\n        assert_eq!(alice_after.messages_visible_from, alice_visible_from);\r\n        assert_eq!(bob_after.member_since, bob_member_since);\r\n        assert_eq!(bob_after.messages_visible_from, bob_visible_from);\r\n        \r\n        // Solo i ruoli dovrebbero essere cambiati\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Admin));\r\n        assert_eq!(bob_after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: find_many_by_user_id */\r\n    /*----------------------------------*/\r\n\r\n    /// Test: trova tutte le chat di un utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) è in 3 chat: General Chat (1), Private Alice-Bob (2), Dev Team (3)\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti i chat_id siano presenti\r\n        let chat_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261)); // General Chat\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob\r\n        assert!(chat_ids.contains(\u00263)); // Dev Team\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: trova le chat di un utente che è in meno chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_fewer_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) è in 2 chat: General Chat (1), Private Alice-Bob (2)\r\n        let result = repo.find_many_by_user_id(\u00262).await?;\r\n        \r\n        assert_eq!(result.len(), 2);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261)); // General Chat\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob\r\n        assert!(!chat_ids.contains(\u00263)); // NON è in Dev Team\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: restituisce lista vuota per utente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Utente inesistente\r\n        let result = repo.find_many_by_user_id(\u0026999).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica i ruoli dell'utente nelle varie chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_with_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è OWNER in tutte e 3 le sue chat\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        for metadata in \u0026result {\r\n            assert_eq!(metadata.user_role, Some(UserRole::Owner));\r\n        }\r\n        \r\n        // Charlie (user_id=3): MEMBER in General Chat, ADMIN in Dev Team\r\n        let charlie_result = repo.find_many_by_user_id(\u00263).await?;\r\n        \r\n        let general_chat = charlie_result.iter().find(|m| m.chat_id == 1).unwrap();\r\n        assert_eq!(general_chat.user_role, Some(UserRole::Member));\r\n        \r\n        let dev_team = charlie_result.iter().find(|m| m.chat_id == 3).unwrap();\r\n        assert_eq!(dev_team.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che i timestamp siano caricati correttamente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_with_timestamps(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        \r\n        // Verifica che tutti i metadata abbiano timestamp validi\r\n        for metadata in result {\r\n            assert!(metadata.member_since \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_visible_from \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n            assert!(metadata.messages_received_until \u003e chrono::DateTime::\u003cchrono::Utc\u003e::default());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di un utente elimina tutti i suoi metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: Bob è in 2 chat\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Elimina Bob\r\n        // CASCADE DELETE eliminerà tutti i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: Bob non dovrebbe avere metadata\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Verifica nel database\r\n        let count = sqlx::query!(\r\n            \"SELECT COUNT(*) as count FROM userchatmetadata WHERE user_id = ?\",\r\n            2\r\n        )\r\n        .fetch_one(\u0026pool)\r\n        .await?;\r\n        assert_eq!(count.count, 0, \"Tutti i metadata dell'utente dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di una chat rimuove il metadata per quell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Prima: Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina General Chat (chat_id=1)\r\n        // CASCADE eliminerà i metadata di tutti gli utenti per quella chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Dopo: Alice dovrebbe essere in 2 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        // Verifica che la chat eliminata non sia più presente\r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(!chat_ids.contains(\u00261)); // General Chat eliminata\r\n        assert!(chat_ids.contains(\u00262)); // Private Alice-Bob ancora presente\r\n        assert!(chat_ids.contains(\u00263)); // Dev Team ancora presente\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di più chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_multiple_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Elimina 2 chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id IN (?, ?)\", 1, 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice dovrebbe essere solo in 1 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 1);\r\n        assert_eq!(result_after[0].chat_id, 3); // Solo Dev Team rimane\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di utente con molte chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_user_with_multiple_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è OWNER in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Verifica che sia presente in tutte e 3\r\n        let chat_ids_before: Vec\u003ci32\u003e = result_before.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids_before.contains(\u00261));\r\n        assert!(chat_ids_before.contains(\u00262));\r\n        assert!(chat_ids_before.contains(\u00263));\r\n        \r\n        // Elimina Alice\r\n        // CASCADE eliminerà tutti i suoi metadata in tutte le chat\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Alice non dovrebbe avere più metadata\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        \r\n        // Le chat dovrebbero esistere ancora (non sono state eliminate)\r\n        let chat1_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 1)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        let chat2_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 2)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        let chat3_exists = sqlx::query!(\"SELECT chat_id FROM chats WHERE chat_id = ?\", 3)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(chat1_exists.is_some(), \"Chat 1 dovrebbe esistere ancora\");\r\n        assert!(chat2_exists.is_some(), \"Chat 2 dovrebbe esistere ancora\");\r\n        assert!(chat3_exists.is_some(), \"Chat 3 dovrebbe esistere ancora\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiunta di un utente a una nuova chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_adding_to_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob inizialmente è in 2 chat\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Aggiungi Bob al Dev Team (chat_id=3)\r\n        sqlx::query!(\r\n            r#\"\r\n            INSERT INTO userchatmetadata (user_id, chat_id, user_role, member_since, messages_visible_from, messages_received_until)\r\n            VALUES (?, ?, 'MEMBER', NOW(), NOW(), NOW())\r\n            \"#,\r\n            2, 3\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora Bob dovrebbe essere in 3 chat\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 3);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(chat_ids.contains(\u00261));\r\n        assert!(chat_ids.contains(\u00262));\r\n        assert!(chat_ids.contains(\u00263)); // Nuovo\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: rimozione di un utente da una chat specifica\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_leaving_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let result_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_before.len(), 3);\r\n        \r\n        // Alice lascia General Chat (chat_id=1)\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id = ?\",\r\n            1, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Ora Alice dovrebbe essere in 2 chat\r\n        let result_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result_after.len(), 2);\r\n        \r\n        let chat_ids: Vec\u003ci32\u003e = result_after.iter().map(|m| m.chat_id).collect();\r\n        assert!(!chat_ids.contains(\u00261)); // Non più in General Chat\r\n        assert!(chat_ids.contains(\u00262));\r\n        assert!(chat_ids.contains(\u00263));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica risultati dopo trasferimento ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_after_ownership_transfer(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale\r\n        let alice_before = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_before.len(), 3);\r\n        \r\n        // Verifica che Alice sia OWNER in tutte le sue chat\r\n        for metadata in \u0026alice_before {\r\n            assert_eq!(metadata.user_role, Some(UserRole::Owner));\r\n        }\r\n        \r\n        // Trasferisci ownership da Alice a Bob nella General Chat\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Alice dovrebbe essere ancora in 3 chat\r\n        let alice_after = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_after.len(), 3);\r\n        \r\n        // Ma il suo ruolo in General Chat dovrebbe essere ADMIN\r\n        let general_chat_metadata = alice_after.iter().find(|m| m.chat_id == 1).unwrap();\r\n        assert_eq!(general_chat_metadata.user_role, Some(UserRole::Admin));\r\n        \r\n        // I suoi ruoli nelle altre chat dovrebbero essere ancora OWNER\r\n        let private_chat_metadata = alice_after.iter().find(|m| m.chat_id == 2).unwrap();\r\n        assert_eq!(private_chat_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        let dev_team_metadata = alice_after.iter().find(|m| m.chat_id == 3).unwrap();\r\n        assert_eq!(dev_team_metadata.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: utente in solo una chat (caso minimo)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_single_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Rimuovi Bob da tutte le chat tranne una\r\n        sqlx::query!(\r\n            \"DELETE FROM userchatmetadata WHERE user_id = ? AND chat_id != ?\",\r\n            2, 1\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?;\r\n        \r\n        // Bob dovrebbe essere solo in 1 chat\r\n        let result = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result.len(), 1);\r\n        assert_eq!(result[0].chat_id, 1);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: eliminazione di tutte le chat di un utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_delete_all_user_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è in 2 chat (chat_id=1, chat_id=2)\r\n        let result_before = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_before.len(), 2);\r\n        \r\n        // Elimina entrambe le chat di Bob\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id IN (?, ?)\", 1, 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe avere più chat\r\n        let result_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(result_after.len(), 0);\r\n        assert!(result_after.is_empty());\r\n        \r\n        // Ma Bob (l'utente) dovrebbe esistere ancora\r\n        let user_exists = sqlx::query!(\"SELECT user_id FROM users WHERE user_id = ?\", 2)\r\n            .fetch_optional(\u0026pool)\r\n            .await?;\r\n        assert!(user_exists.is_some(), \"L'utente Bob dovrebbe esistere ancora\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica ordinamento dei risultati (se presente)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_result_order(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è in 3 chat\r\n        let result = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica che tutti i risultati siano validi e abbiano lo stesso user_id\r\n        for metadata in \u0026result {\r\n            assert_eq!(metadata.user_id, 1);\r\n            assert!(metadata.chat_id \u003e 0);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: interazione tra eliminazione utente e chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_find_many_by_user_id_cascade_mixed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Stato iniziale: Bob in 2 chat, Charlie in 2 chat\r\n        let bob_before = repo.find_many_by_user_id(\u00262).await?;\r\n        let charlie_before = repo.find_many_by_user_id(\u00263).await?;\r\n        assert_eq!(bob_before.len(), 2);\r\n        assert_eq!(charlie_before.len(), 2);\r\n        \r\n        // Elimina Bob (utente)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Elimina una chat dove Charlie è membro\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Bob non dovrebbe avere metadata\r\n        let bob_after = repo.find_many_by_user_id(\u00262).await?;\r\n        assert_eq!(bob_after.len(), 0);\r\n        \r\n        // Charlie dovrebbe essere in 1 sola chat (Dev Team)\r\n        let charlie_after = repo.find_many_by_user_id(\u00263).await?;\r\n        assert_eq!(charlie_after.len(), 1);\r\n        assert_eq!(charlie_after[0].chat_id, 3);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*-------------------------*/\r\n    /* Unit tests: create_many */\r\n    /*-------------------------*/\r\n\r\n    /// Test: creazione di più metadata in una singola transazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_success(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            \"Test Description\",\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Prepara i dati per creare 3 membri contemporaneamente\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // Crea tutti i metadata\r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica che siano stati creati tutti e 3\r\n        assert_eq!(result.len(), 3);\r\n        \r\n        // Verifica i ruoli\r\n        assert_eq!(result[0].user_role, Some(UserRole::Owner));\r\n        assert_eq!(result[1].user_role, Some(UserRole::Admin));\r\n        assert_eq!(result[2].user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica che siano stati effettivamente inseriti nel database\r\n        let chat_members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(chat_members.len(), 3);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione con lista vuota restituisce lista vuota\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_empty_list(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let empty_list: Vec\u003cCreateUserChatMetadataDTO\u003e = vec![];\r\n        let result = repo.create_many(\u0026empty_list).await?;\r\n        \r\n        assert_eq!(result.len(), 0);\r\n        assert!(result.is_empty());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione di un singolo metadata (caso minimo)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_single_item(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Single Member Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        assert_eq!(result.len(), 1);\r\n        assert_eq!(result[0].user_id, 1);\r\n        assert_eq!(result[0].chat_id, new_chat_id);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità della transazione - se uno fallisce, falliscono tutti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_atomicity_user_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 999, // Utente inesistente\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // La creazione dovrebbe fallire\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        // Verifica che nessun metadata sia stato creato (rollback automatico)\r\n        let chat_members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(chat_members.len(), 0, \"Nessun metadata dovrebbe essere creato (transazione rollback)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: atomicità - chat inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_atomicity_chat_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: 999, // Chat inesistente\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // La creazione dovrebbe fallire\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: violazione di chiave primaria (user_id, chat_id duplicati)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_duplicate_key_violation(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: 1, // Alice è già nella General Chat\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        // Dovrebbe fallire perché Alice è già nella chat\r\n        let result = repo.create_many(\u0026metadata_list).await;\r\n        assert!(result.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"newuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata per il nuovo utente\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id: 1,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 1);\r\n        \r\n        // Verifica che il metadata esista\r\n        let metadata_exists = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(metadata_exists.is_some());\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let metadata_after = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(metadata_after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Aggiungi membri\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 2);\r\n        \r\n        // Verifica che i metadata esistano\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 2);\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata siano stati eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione di molti metadata (stress test)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_large_batch(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea più utenti per il test\r\n        for i in 4..=10 {\r\n            sqlx::query!(\r\n                \"INSERT INTO users (user_id, username, password) VALUES (?, ?, ?)\",\r\n                i,\r\n                format!(\"user{}\", i),\r\n                \"password\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        }\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Large Group Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Prepara metadata per 10 utenti (user_id 1-10)\r\n        let now = chrono::Utc::now();\r\n        let metadata_list: Vec\u003cCreateUserChatMetadataDTO\u003e = (1..=10)\r\n            .map(|user_id| CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: if user_id == 1 {\r\n                    Some(UserRole::Owner)\r\n                } else if user_id \u003c= 3 {\r\n                    Some(UserRole::Admin)\r\n                } else {\r\n                    Some(UserRole::Member)\r\n                },\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            })\r\n            .collect();\r\n        \r\n        // Crea tutti i metadata\r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        assert_eq!(result.len(), 10);\r\n        \r\n        // Verifica nel database\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 10);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica ordine di restituzione dei metadata creati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_preserves_order(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Order Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica che l'ordine sia preservato\r\n        assert_eq!(result[0].user_id, 3);\r\n        assert_eq!(result[1].user_id, 1);\r\n        assert_eq!(result[2].user_id, 2);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: creazione con diversi ruoli\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_different_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Roles Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Admin),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        let result = repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica i ruoli\r\n        assert_eq!(result[0].user_role, Some(UserRole::Owner));\r\n        assert_eq!(result[1].user_role, Some(UserRole::Admin));\r\n        assert_eq!(result[2].user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica che i ruoli siano stati salvati correttamente\r\n        let owner = repo.read(\u0026(1, new_chat_id)).await?.unwrap();\r\n        let admin = repo.read(\u0026(2, new_chat_id)).await?.unwrap();\r\n        let member = repo.read(\u0026(3, new_chat_id)).await?.unwrap();\r\n        \r\n        assert_eq!(owner.user_role, Some(UserRole::Owner));\r\n        assert_eq!(admin.user_role, Some(UserRole::Admin));\r\n        assert_eq!(member.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: creazione multipla e poi eliminazione di più utenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_many_cascade_delete_multiple_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea nuovi utenti\r\n        let user4_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user4\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user5_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user5\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Aggiungi i nuovi utenti alla chat\r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: user4_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Owner),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: user5_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Verifica creazione\r\n        let members_before = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_before.len(), 2);\r\n        \r\n        // Elimina entrambi gli utenti\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id IN (?, ?)\", user4_id, user5_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che i metadata siano stati eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------*/\r\n    /* Unit tests: update_user_role */\r\n    /*------------------------------*/\r\n\r\n    /// Test: aggiornamento ruolo da MEMBER a ADMIN\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_member_to_admin(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) è MEMBER nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Member));\r\n        \r\n        // Promuovi Bob ad ADMIN\r\n        let result = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        assert_eq!(result.user_id, 2);\r\n        assert_eq!(result.chat_id, 1);\r\n        assert_eq!(result.user_role, Some(UserRole::Admin));\r\n        \r\n        // Verifica nel database\r\n        let after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo da ADMIN a OWNER\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_admin_to_owner(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Charlie (user_id=3) è ADMIN nel Dev Team (chat_id=3)\r\n        let before = repo.read(\u0026(3, 3)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Admin));\r\n        \r\n        // Promuovi Charlie a OWNER\r\n        let result = repo.update_user_role(\u00263, \u00263, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo da OWNER a MEMBER (demozione)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_owner_to_member(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice (user_id=1) è OWNER nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Owner));\r\n        \r\n        // Degrada Alice a MEMBER\r\n        let result = repo.update_user_role(\u00261, \u00261, \u0026UserRole::Member).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica persistenza\r\n        let after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando user_id non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_user_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tentativo di aggiornare utente inesistente\r\n        let result = repo.update_user_role(\u0026999, \u00261, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando chat_id non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_chat_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tentativo di aggiornare in una chat inesistente\r\n        let result = repo.update_user_role(\u00261, \u0026999, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: errore quando la combinazione (user_id, chat_id) non esiste\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_metadata_not_found(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) non è nel Dev Team (chat_id=3)\r\n        let result = repo.update_user_role(\u00262, \u00263, \u0026UserRole::Admin).await;\r\n        \r\n        assert!(result.is_err());\r\n        assert!(matches!(result.unwrap_err(), sqlx::Error::RowNotFound));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che solo user_role cambi, altri campi rimangono invariati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_preserves_other_fields(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Salva i valori originali\r\n        let before = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let original_member_since = before.member_since;\r\n        let original_visible_from = before.messages_visible_from;\r\n        let original_received_until = before.messages_received_until;\r\n        \r\n        // Aggiorna solo il ruolo\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica che gli altri campi siano invariati\r\n        let after = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after.member_since, original_member_since);\r\n        assert_eq!(after.messages_visible_from, original_visible_from);\r\n        assert_eq!(after.messages_received_until, original_received_until);\r\n        assert_eq!(after.user_role, Some(UserRole::Admin)); // Solo questo cambia\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo allo stesso valore (idempotenza)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_same_value(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Alice è già OWNER\r\n        let before = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Owner));\r\n        \r\n        // \"Aggiorna\" a OWNER (stesso valore)\r\n        let result = repo.update_user_role(\u00261, \u00261, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        // Verifica che funzioni senza problemi\r\n        let after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(after.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamenti multipli sequenziali\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_multiple_sequential(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Sequenza: MEMBER -\u003e ADMIN -\u003e OWNER -\u003e MEMBER\r\n        let metadata = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(metadata.user_role, Some(UserRole::Member));\r\n        \r\n        // MEMBER -\u003e ADMIN\r\n        let result1 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        assert_eq!(result1.user_role, Some(UserRole::Admin));\r\n        \r\n        // ADMIN -\u003e OWNER\r\n        let result2 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Owner).await?;\r\n        assert_eq!(result2.user_role, Some(UserRole::Owner));\r\n        \r\n        // OWNER -\u003e MEMBER\r\n        let result3 = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Member).await?;\r\n        assert_eq!(result3.user_role, Some(UserRole::Member));\r\n        \r\n        // Verifica finale\r\n        let final_state = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(final_state.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento in chat privata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_private_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Private Alice-Bob (chat_id=2): Bob è MEMBER\r\n        let before = repo.read(\u0026(2, 2)).await?.unwrap();\r\n        assert_eq!(before.user_role, Some(UserRole::Member));\r\n        \r\n        // Promuovi Bob a OWNER nella chat privata\r\n        let result = repo.update_user_role(\u00262, \u00262, \u0026UserRole::Owner).await?;\r\n        \r\n        assert_eq!(result.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento ruolo e poi eliminazione utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Promuovi Bob ad ADMIN\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica l'aggiornamento\r\n        let after_update = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after_update.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina Bob - CASCADE dovrebbe eliminare tutti i suoi metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Il metadata non dovrebbe più esistere\r\n        let after_delete = repo.read(\u0026(2, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento ruolo e poi eliminazione chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Promuovi Bob ad ADMIN nella General Chat\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica l'aggiornamento\r\n        let after_update = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(after_update.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessun metadata dovrebbe esistere per questa chat\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamenti concorrenti su utenti diversi nella stessa chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_multiple_users_same_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // General Chat (chat_id=1): aggiorna ruoli di più utenti\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica che entrambi siano stati aggiornati\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        \r\n        assert_eq!(bob.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        // Alice dovrebbe essere ancora OWNER (non modificata)\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: aggiornamento ruolo dopo transfer_ownership\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_after_transfer_ownership(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Trasferisci ownership da Alice a Bob\r\n        repo.transfer_ownership(\u00261, \u00262, \u00261).await?;\r\n        \r\n        // Alice dovrebbe essere ADMIN ora\r\n        let alice = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice.user_role, Some(UserRole::Admin));\r\n        \r\n        // Degrada Alice a MEMBER\r\n        repo.update_user_role(\u00261, \u00261, \u0026UserRole::Member).await?;\r\n        \r\n        let alice_after = repo.read(\u0026(1, 1)).await?.unwrap();\r\n        assert_eq!(alice_after.user_role, Some(UserRole::Member));\r\n        \r\n        // Bob dovrebbe essere ancora OWNER\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Owner));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che update_user_role funzioni con tutti e tre i ruoli\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_all_roles(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat con 3 membri\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let metadata_list = vec![\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 1,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 2,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n            CreateUserChatMetadataDTO {\r\n                user_id: 3,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            },\r\n        ];\r\n        \r\n        repo.create_many(\u0026metadata_list).await?;\r\n        \r\n        // Aggiorna a ruoli diversi\r\n        repo.update_user_role(\u00261, \u0026new_chat_id, \u0026UserRole::Owner).await?;\r\n        repo.update_user_role(\u00262, \u0026new_chat_id, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u0026new_chat_id, \u0026UserRole::Member).await?; // Rimane MEMBER\r\n        \r\n        // Verifica\r\n        let user1 = repo.read(\u0026(1, new_chat_id)).await?.unwrap();\r\n        let user2 = repo.read(\u0026(2, new_chat_id)).await?.unwrap();\r\n        let user3 = repo.read(\u0026(3, new_chat_id)).await?.unwrap();\r\n        \r\n        assert_eq!(user1.user_role, Some(UserRole::Owner));\r\n        assert_eq!(user2.user_role, Some(UserRole::Admin));\r\n        assert_eq!(user3.user_role, Some(UserRole::Member));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test CASCADE: aggiornamento di più utenti e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_cascade_multiple_updates_then_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Aggiorna più ruoli nella General Chat\r\n        repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await?;\r\n        repo.update_user_role(\u00263, \u00261, \u0026UserRole::Admin).await?;\r\n        \r\n        // Verifica gli aggiornamenti\r\n        let members_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members_before.len(), 3);\r\n        \r\n        // Conta gli admin\r\n        let admin_count = members_before.iter().filter(|m| m.user_role == Some(UserRole::Admin)).count();\r\n        assert_eq!(admin_count, 2);\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutti i metadata dovrebbero essere eliminati\r\n        let members_after = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members_after.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test: verifica che rows_affected sia corretto\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_user_role_rows_affected(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Aggiornamento valido\r\n        let result = repo.update_user_role(\u00262, \u00261, \u0026UserRole::Admin).await;\r\n        assert!(result.is_ok(), \"L'aggiornamento dovrebbe avere successo\");\r\n        \r\n        // Aggiornamento invalido (metadata inesistente)\r\n        let result_invalid = repo.update_user_role(\u0026999, \u0026999, \u0026UserRole::Admin).await;\r\n        assert!(result_invalid.is_err(), \"Dovrebbe fallire con RowNotFound\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: create (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: errore con user_id inesistente (violazione foreign key)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_user_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 999, // Utente inesistente\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation su user_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con chat_id inesistente (violazione foreign key)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_chat_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: 999, // Chat inesistente\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation su chat_id\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_both_not_exist(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 888,\r\n            chat_id: 999,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con foreign key violation\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore con chiave primaria duplicata (user_id, chat_id)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_duplicate_key(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1, // Alice è già nella General Chat (fixtures)\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire con duplicate primary key error\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore tentando di creare dopo che l'utente esiste ma viene eliminato durante l'operazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_user_deleted_before_insert(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"tempuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Elimina immediatamente l'utente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Prova a creare il metadata per l'utente appena eliminato\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire perché l'utente è stato eliminato\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: errore tentando di creare dopo che la chat viene eliminata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_chat_deleted_before_insert(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Elimina immediatamente la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Prova a creare il metadata per la chat appena eliminata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let result = repo.create(\u0026dto).await;\r\n        \r\n        assert!(result.is_err(), \"Dovrebbe fallire perché la chat è stata eliminata\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_user_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata per il nuovo utente\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che il metadata esista\r\n        let exists = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(exists.is_some(), \"Il metadata dovrebbe esistere dopo la creazione\");\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato automaticamente (CASCADE DELETE su user_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_chat_removes_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Temporary Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che il metadata esista\r\n        let exists = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(exists.is_some(), \"Il metadata dovrebbe esistere dopo la creazione\");\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato automaticamente (CASCADE DELETE su chat_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione di più metadata per utenti diversi nella stessa chat, poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_chat_removes_all_members_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Group\",\r\n            Some(\"Group to be deleted\"),\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea metadata per 3 utenti\r\n        for user_id in [1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(if user_id == 1 { UserRole::Owner } else { UserRole::Member }),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che tutti i metadata esistano\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 3, \"Dovrebbero esserci 3 membri\");\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che TUTTI i metadata siano stati eliminati (CASCADE)\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE DELETE)\");\r\n        \r\n        // Verifica anche singolarmente\r\n        for user_id in [1, 2, 3] {\r\n            let metadata = repo.read(\u0026(user_id, new_chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata per user_id {} dovrebbe essere eliminato\", user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: creazione di metadata per lo stesso utente in più chat, poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_delete_user_removes_all_chats_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea 2 nuove chat\r\n        let chat_ids: Vec\u003ci32\u003e = vec![\r\n            sqlx::query!(\r\n                \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n                \"Test Chat 1\",\r\n                None::\u003cString\u003e,\r\n                \"GROUP\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?\r\n            .last_insert_id() as i32,\r\n            sqlx::query!(\r\n                \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n                \"Test Chat 2\",\r\n                None::\u003cString\u003e,\r\n                \"GROUP\"\r\n            )\r\n            .execute(\u0026pool)\r\n            .await?\r\n            .last_insert_id() as i32,\r\n        ];\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Aggiungi l'utente a entrambe le chat\r\n        for \u0026chat_id in \u0026chat_ids {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che l'utente sia in 2 chat\r\n        let user_chats = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats.len(), 2, \"L'utente dovrebbe essere in 2 chat\");\r\n        \r\n        // Elimina l'utente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che TUTTI i metadata siano stati eliminati (CASCADE)\r\n        let user_chats_after = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati (CASCADE DELETE)\");\r\n        \r\n        // Verifica anche singolarmente\r\n        for \u0026chat_id in \u0026chat_ids {\r\n            let metadata = repo.read(\u0026(new_user_id, chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata per chat_id {} dovrebbe essere eliminato\", chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con creazioni multiple e CASCADE su entrambe le FK\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 nuovi utenti\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea 2 nuove chat\r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea una matrice di metadata: ogni utente in ogni chat\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica: 4 metadata creati (2 utenti x 2 chat)\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user1_id).await?.len(), 2);\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user2_id).await?.len(), 2);\r\n        \r\n        // Elimina user1 - dovrebbe rimuovere 2 metadata (user1 in chat1 e chat2)\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 1, \"Chat1 dovrebbe avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 1, \"Chat2 dovrebbe avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user1_id).await?.len(), 0, \"User1 non dovrebbe avere metadata\");\r\n        \r\n        // Elimina chat1 - dovrebbe rimuovere 1 metadata (user2 in chat1)\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat1_id).await?.len(), 0, \"Chat1 non dovrebbe avere membri\");\r\n        assert_eq!(repo.find_many_by_chat_id(\u0026chat2_id).await?.len(), 1, \"Chat2 dovrebbe ancora avere 1 membro\");\r\n        assert_eq!(repo.find_many_by_user_id(\u0026user2_id).await?.len(), 1, \"User2 dovrebbe essere in 1 chat\");\r\n        \r\n        // Verifica che rimanga solo il metadata di user2 in chat2\r\n        let remaining = repo.read(\u0026(user2_id, chat2_id)).await?;\r\n        assert!(remaining.is_some(), \"Dovrebbe rimanere solo user2 in chat2\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di creare dopo che un altro metadata nella stessa chat causa un errore\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_create_error_isolation_between_creates(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Prima creazione: successo\r\n        let dto1 = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result1 = repo.create(\u0026dto1).await;\r\n        assert!(result1.is_ok(), \"La prima creazione dovrebbe avere successo\");\r\n        \r\n        // Seconda creazione con user_id invalido: fallimento\r\n        let dto2 = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result2 = repo.create(\u0026dto2).await;\r\n        assert!(result2.is_err(), \"La seconda creazione dovrebbe fallire\");\r\n        \r\n        // Terza creazione valida: dovrebbe avere successo nonostante il fallimento precedente\r\n        let dto3 = CreateUserChatMetadataDTO {\r\n            user_id: 2,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        let result3 = repo.create(\u0026dto3).await;\r\n        assert!(result3.is_ok(), \"La terza creazione dovrebbe avere successo (isolamento degli errori)\");\r\n        \r\n        // Verifica: dovrebbero esserci solo 2 metadata (quello fallito non è stato inserito)\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 2, \"Dovrebbero esserci solo 2 membri (quello fallito non è stato inserito)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*----------------------------------*/\r\n    /* Unit tests: read (casi negativi) */\r\n    /*----------------------------------*/\r\n\r\n    /// Test NEGATIVO: read di metadata inesistente (user_id valido ma non in quella chat)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_not_exists_valid_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team chat (chat_id=3)\r\n        let result = repo.read(\u0026(2, 3)).await?;\r\n        \r\n        assert!(result.is_none(), \"Il metadata non dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read di metadata inesistente (chat_id valido ma utente non membro)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_not_exists_valid_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Charlie (user_id=3) non è nella chat privata Alice-Bob (chat_id=2)\r\n        let result = repo.read(\u0026(3, 2)).await?;\r\n        \r\n        assert!(result.is_none(), \"Il metadata non dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con user_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(999, 1)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per user_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con chat_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(1, 999)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per chat_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(888, 999)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(-1, -1)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.read(\u0026(0, 0)).await?;\r\n        \r\n        assert!(result.is_none(), \"Nessun metadata dovrebbe esistere per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo delete dell'utente (CASCADE DELETE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) è nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some(), \"Bob dovrebbe essere nella General Chat\");\r\n        \r\n        // Elimina Bob - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(2, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE su user_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo delete della chat (CASCADE DELETE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice (user_id=1) è nella General Chat (chat_id=1)\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some(), \"Alice dovrebbe essere nella General Chat\");\r\n        \r\n        // Elimina la General Chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(1, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE su chat_id)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read multipli dopo delete dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_after_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat (fixtures)\r\n        let chats_before = repo.find_many_by_user_id(\u00261).await?;\r\n        let alice_chat_ids: Vec\u003ci32\u003e = chats_before.iter().map(|m| m.chat_id).collect();\r\n        \r\n        // Verifica che Alice sia in tutte quelle chat\r\n        for \u0026chat_id in \u0026alice_chat_ids {\r\n            let metadata = repo.read(\u0026(1, chat_id)).await?;\r\n            assert!(metadata.is_some(), \"Alice dovrebbe essere nella chat {}\", chat_id);\r\n        }\r\n        \r\n        // Elimina Alice\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutte le read dovrebbero restituire None\r\n        for \u0026chat_id in \u0026alice_chat_ids {\r\n            let metadata = repo.read(\u0026(1, chat_id)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata di Alice nella chat {} dovrebbe essere eliminato\", chat_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read multipli dopo delete della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_after_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat ha 3 membri\r\n        let members_before = repo.find_many_by_chat_id(\u00261).await?;\r\n        let user_ids: Vec\u003ci32\u003e = members_before.iter().map(|m| m.user_id).collect();\r\n        \r\n        assert_eq!(user_ids.len(), 3, \"La General Chat dovrebbe avere 3 membri\");\r\n        \r\n        // Verifica che tutti i membri siano nella chat\r\n        for \u0026user_id in \u0026user_ids {\r\n            let metadata = repo.read(\u0026(user_id, 1)).await?;\r\n            assert!(metadata.is_some(), \"L'utente {} dovrebbe essere nella General Chat\", user_id);\r\n        }\r\n        \r\n        // Elimina la General Chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutte le read dovrebbero restituire None\r\n        for \u0026user_id in \u0026user_ids {\r\n            let metadata = repo.read(\u0026(user_id, 1)).await?;\r\n            assert!(metadata.is_none(), \"Il metadata dell'utente {} dovrebbe essere eliminato\", user_id);\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read dopo delete manuale (non CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_manual_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(before.is_some(), \"Il metadata dovrebbe esistere\");\r\n        \r\n        // Delete manuale\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after.is_none(), \"Il metadata non dovrebbe più esistere dopo delete\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: read dopo creazione e immediata eliminazione CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_create_and_immediate_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"tempuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        let before = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(before.is_some(), \"Il metadata dovrebbe esistere\");\r\n        \r\n        // Elimina l'utente immediatamente\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Read dovrebbe restituire None\r\n        let after = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after.is_none(), \"Il metadata dovrebbe essere eliminato immediatamente (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // User valido, chat invalida\r\n        let result1 = repo.read(\u0026(1, 999)).await?;\r\n        assert!(result1.is_none());\r\n        \r\n        // User invalido, chat valida\r\n        let result2 = repo.read(\u0026(999, 1)).await?;\r\n        assert!(result2.is_none());\r\n        \r\n        // User negativo, chat valida\r\n        let result3 = repo.read(\u0026(-5, 1)).await?;\r\n        assert!(result3.is_none());\r\n        \r\n        // User valido, chat negativa\r\n        let result4 = repo.read(\u0026(1, -5)).await?;\r\n        assert!(result4.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso - read dopo eliminazioni multiple\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una matrice di test: 2 utenti, 2 chat\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata (user1 in chat1, user1 in chat2, user2 in chat1, user2 in chat2)\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica che tutti esistano\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina user1 - dovrebbe eliminare 2 metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none(), \"user1-chat1 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none(), \"user1-chat2 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some(), \"user2-chat1 dovrebbe esistere\");\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some(), \"user2-chat2 dovrebbe esistere\");\r\n        \r\n        // Elimina chat1 - dovrebbe eliminare 1 metadata rimanente\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none(), \"user2-chat1 dovrebbe essere eliminato\");\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some(), \"user2-chat2 dovrebbe ancora esistere\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read dopo update fallito non dovrebbe influenzare il risultato\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_after_failed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta di creare con FK invalida (dovrebbe fallire)\r\n        let now = chrono::Utc::now();\r\n        let invalid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let create_result = repo.create(\u0026invalid_dto).await;\r\n        assert!(create_result.is_err(), \"La creazione dovrebbe fallire\");\r\n        \r\n        // Read dovrebbe confermare che non esiste\r\n        let after_failed_create = repo.read(\u0026(999, 1)).await?;\r\n        assert!(after_failed_create.is_none(), \"Non dovrebbe esistere dopo creazione fallita\");\r\n        \r\n        // Tenta di leggere un metadata esistente per confermare che il database è ancora consistente\r\n        let existing = repo.read(\u0026(1, 1)).await?;\r\n        assert!(existing.is_some(), \"I metadata esistenti dovrebbero essere ancora accessibili\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: read ripetuti dopo CASCADE DELETE confermano persistenza dell'eliminazione\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_read_multiple_times_after_cascade(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_some());\r\n        \r\n        // Elimina Bob\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Leggi multiple volte - dovrebbe sempre restituire None\r\n        for _ in 0..5 {\r\n            let result = repo.read(\u0026(2, 1)).await?;\r\n            assert!(result.is_none(), \"Dovrebbe sempre restituire None dopo CASCADE DELETE\");\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: update (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: update di metadata inesistente (user_id e chat_id non associati)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team (chat_id=3)\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(2, 3), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per metadata inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con user_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Member),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(999, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per user_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con chat_id completamente inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Owner),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per chat_id inesistente\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(888, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per entrambi gli ID inesistenti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Member),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(-1, -1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Owner),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(0, 0), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update e poi eliminazione dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_then_cascade_delete_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente e metadata\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: new_user_id,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Update del metadata\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let updated = repo.update(\u0026(new_user_id, 1), \u0026update_dto).await?;\r\n        assert_eq!(updated.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(new_user_id, 1)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update e poi eliminazione della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_then_cascade_delete_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        // Crea metadata\r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Update del metadata\r\n        let future = chrono::Utc::now() + chrono::Duration::days(30);\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: None,\r\n            messages_visible_from: None,\r\n            messages_received_until: Some(future),\r\n        };\r\n        \r\n        let updated = repo.update(\u0026(1, new_chat_id), \u0026update_dto).await?;\r\n        // Verifica che l'update sia avvenuto (il timestamp dovrebbe essere vicino a 'future')\r\n        assert!(updated.messages_received_until \u003e now, \"Il timestamp dovrebbe essere stato aggiornato\");\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare il metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che il metadata sia stato eliminato\r\n        let after_delete = repo.read(\u0026(1, new_chat_id)).await?;\r\n        assert!(after_delete.is_none(), \"Il metadata dovrebbe essere eliminato (CASCADE DELETE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: update multipli e poi eliminazione CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_multiple_then_cascade_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Update più utenti nella General Chat\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        repo.update(\u0026(2, 1), \u0026update_dto).await?;\r\n        repo.update(\u0026(3, 1), \u0026update_dto).await?;\r\n        \r\n        // Verifica gli update\r\n        let bob = repo.read(\u0026(2, 1)).await?.unwrap();\r\n        let charlie = repo.read(\u0026(3, 1)).await?.unwrap();\r\n        assert_eq!(bob.user_role, Some(UserRole::Admin));\r\n        assert_eq!(charlie.user_role, Some(UserRole::Admin));\r\n        \r\n        // Elimina la chat\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tutti i metadata dovrebbero essere eliminati\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(3, 1)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di update dopo delete dell'utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_user_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina Bob - CASCADE elimina il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(2, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: tentativo di update dopo delete della chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_chat_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è nella General Chat\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la General Chat - CASCADE elimina tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, 1), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato (CASCADE)\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update dopo delete manuale del metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_after_manual_delete(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Delete manuale\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        \r\n        // Tentativo di update dovrebbe fallire\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(1, new_chat_id), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire perché il metadata è stato eliminato\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con DTO vuoto (nessun campo da aggiornare) su metadata inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_empty_dto_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // DTO vuoto\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: None,\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // Anche se il DTO è vuoto, dovrebbe fallire perché il metadata non esiste\r\n        let result = repo.update(\u0026(999, 999), \u0026update_dto).await;\r\n        \r\n        assert!(result.is_err(), \"L'update dovrebbe fallire per metadata inesistente, anche con DTO vuoto\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con update e eliminazioni multiple\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 utenti e 2 chat\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Update tutti a Admin\r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                repo.update(\u0026(user_id, chat_id), \u0026update_dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica che tutti siano Admin\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let metadata = repo.read(\u0026(user_id, chat_id)).await?.unwrap();\r\n                assert_eq!(metadata.user_role, Some(UserRole::Admin));\r\n            }\r\n        }\r\n        \r\n        // Elimina user1\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // user1 non dovrebbe più avere metadata\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none());\r\n        \r\n        // user2 dovrebbe ancora avere i suoi metadata\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina chat1\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Nessuno dovrebbe avere metadata per chat1\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none());\r\n        \r\n        // user2 in chat2 dovrebbe ancora esistere\r\n        let remaining = repo.read(\u0026(user2_id, chat2_id)).await?;\r\n        assert!(remaining.is_some());\r\n        assert_eq!(remaining.unwrap().user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // User valido, chat invalida\r\n        let result1 = repo.update(\u0026(1, 999), \u0026update_dto).await;\r\n        assert!(result1.is_err());\r\n        \r\n        // User invalido, chat valida\r\n        let result2 = repo.update(\u0026(999, 1), \u0026update_dto).await;\r\n        assert!(result2.is_err());\r\n        \r\n        // User negativo, chat valida\r\n        let result3 = repo.update(\u0026(-5, 1), \u0026update_dto).await;\r\n        assert!(result3.is_err());\r\n        \r\n        // User valido, chat negativa\r\n        let result4 = repo.update(\u0026(1, -5), \u0026update_dto).await;\r\n        assert!(result4.is_err());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update ripetuti dopo CASCADE DELETE falliscono\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_multiple_times_after_cascade(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_some());\r\n        \r\n        // Elimina Bob\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        let update_dto = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        // Tenta update multiple volte - dovrebbero tutti fallire\r\n        for _ in 0..3 {\r\n            let result = repo.update(\u0026(2, 1), \u0026update_dto).await;\r\n            assert!(result.is_err(), \"L'update dovrebbe sempre fallire dopo CASCADE DELETE\");\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: update dopo operazione fallita non influenza metadata esistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_update_isolation_after_failed_update(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta update su metadata inesistente\r\n        let invalid_update = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result = repo.update(\u0026(999, 1), \u0026invalid_update).await;\r\n        assert!(result.is_err(), \"L'update dovrebbe fallire\");\r\n        \r\n        // Verifica che i metadata esistenti siano ancora accessibili e aggiornabili\r\n        let valid_update = UpdateUserChatMetadataDTO {\r\n            user_role: Some(UserRole::Admin),\r\n            messages_visible_from: None,\r\n            messages_received_until: None,\r\n        };\r\n        \r\n        let result2 = repo.update(\u0026(1, 1), \u0026valid_update).await;\r\n        assert!(result2.is_ok(), \"L'update valido dovrebbe avere successo\");\r\n        \r\n        let updated = result2.unwrap();\r\n        assert_eq!(updated.user_role, Some(UserRole::Admin));\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /*------------------------------------*/\r\n    /* Unit tests: delete (casi negativi) */\r\n    /*------------------------------------*/\r\n\r\n    /// Test NEGATIVO: delete di metadata inesistente (non genera errore ma non elimina nulla)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_not_exists(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob (user_id=2) non è nella Dev Team (chat_id=3)\r\n        let result = repo.delete(\u0026(2, 3)).await;\r\n        \r\n        // Delete non genera errore anche se il record non esiste\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se il record non esiste\");\r\n        \r\n        // Verifica che i metadata esistenti non siano stati toccati\r\n        let existing = repo.read(\u0026(2, 1)).await?;\r\n        assert!(existing.is_some(), \"I metadata esistenti non dovrebbero essere toccati\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con user_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_invalid_user_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let result = repo.delete(\u0026(999, 1)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per user_id inesistente\");\r\n        \r\n        // Verifica che i metadata della chat siano intatti\r\n        let members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(members.len(), 3, \"I membri della General Chat dovrebbero essere intatti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con chat_id inesistente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_invalid_chat_id(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        let result = repo.delete(\u0026(1, 999)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per chat_id inesistente\");\r\n        \r\n        // Verifica che i metadata di Alice siano intatti\r\n        let alice_chats = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(alice_chats.len(), 3, \"Le chat di Alice dovrebbero essere intatte\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con entrambi user_id e chat_id inesistenti\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_both_invalid(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(888, 999)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore anche per entrambi gli ID inesistenti\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con ID negativi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_negative_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(-1, -1)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per ID negativi\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con ID zero\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_zero_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        let result = repo.delete(\u0026(0, 0)).await;\r\n        \r\n        assert!(result.is_ok(), \"Delete non genera errore per ID zero\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo che l'utente è già stato eliminato (CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_user_cascade_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Bob è nella General Chat\r\n        let before = repo.read(\u0026(2, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina Bob - CASCADE elimina automaticamente il metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", 2)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        \r\n        // Tentativo di delete non genera errore (record già inesistente)\r\n        let result = repo.delete(\u0026(2, 1)).await;\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se già eliminato da CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo che la chat è già stata eliminata (CASCADE)\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_chat_cascade_deleted(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è nella General Chat\r\n        let before = repo.read(\u0026(1, 1)).await?;\r\n        assert!(before.is_some());\r\n        \r\n        // Elimina la General Chat - CASCADE elimina tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", 1)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        \r\n        // Tentativo di delete non genera errore\r\n        let result = repo.delete(\u0026(1, 1)).await;\r\n        assert!(result.is_ok(), \"Delete dovrebbe avere successo anche se già eliminato da CASCADE\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete doppio dello stesso metadata\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_twice_same_metadata(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Verifica che esista\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_some());\r\n        \r\n        // Prima delete\r\n        let result1 = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(result1.is_ok());\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        // Seconda delete sullo stesso metadata (già inesistente)\r\n        let result2 = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(result2.is_ok(), \"Delete dovrebbe avere successo anche la seconda volta\");\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: verifica che dopo delete dell'utente, i metadata siano eliminati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_verify_cascade_on_user(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un nuovo utente con metadata in più chat\r\n        let new_user_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"testuser\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Aggiungi l'utente a 2 chat\r\n        for \u0026chat_id in \u0026[1, 2] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id: new_user_id,\r\n                chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che l'utente sia in 2 chat\r\n        let user_chats = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats.len(), 2);\r\n        \r\n        // Elimina l'utente - CASCADE dovrebbe eliminare automaticamente tutti i metadata\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", new_user_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutti i metadata siano stati eliminati da CASCADE\r\n        let user_chats_after = repo.find_many_by_user_id(\u0026new_user_id).await?;\r\n        assert_eq!(user_chats_after.len(), 0, \"Tutti i metadata dovrebbero essere eliminati da CASCADE\");\r\n        \r\n        // Tentativo di delete manuale non genera errori\r\n        let result1 = repo.delete(\u0026(new_user_id, 1)).await;\r\n        let result2 = repo.delete(\u0026(new_user_id, 2)).await;\r\n        assert!(result1.is_ok());\r\n        assert!(result2.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: verifica che dopo delete della chat, tutti i membri siano eliminati\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_verify_cascade_on_chat(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea una nuova chat con 3 membri\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Group\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Verifica che ci siano 3 membri\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 3);\r\n        \r\n        // Elimina la chat - CASCADE dovrebbe eliminare tutti i metadata\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", new_chat_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        // Verifica che tutti i metadata siano stati eliminati da CASCADE\r\n        let members_after = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members_after.len(), 0, \"Tutti i membri dovrebbero essere eliminati da CASCADE\");\r\n        \r\n        // Tentativo di delete manuale non genera errori\r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let result = repo.delete(\u0026(user_id, new_chat_id)).await;\r\n            assert!(result.is_ok());\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete in ordine diverso non causa problemi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_various_orders(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 3 nuovi metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        for \u0026user_id in \u0026[1, 2, 3] {\r\n            let dto = CreateUserChatMetadataDTO {\r\n                user_id,\r\n                chat_id: new_chat_id,\r\n                user_role: Some(UserRole::Member),\r\n                member_since: now,\r\n                messages_visible_from: now,\r\n                messages_received_until: now,\r\n            };\r\n            repo.create(\u0026dto).await?;\r\n        }\r\n        \r\n        // Delete in ordine sparso\r\n        repo.delete(\u0026(2, new_chat_id)).await?;\r\n        repo.delete(\u0026(1, new_chat_id)).await?;\r\n        repo.delete(\u0026(3, new_chat_id)).await?;\r\n        \r\n        // Verifica che tutti siano stati eliminati\r\n        let members = repo.find_many_by_chat_id(\u0026new_chat_id).await?;\r\n        assert_eq!(members.len(), 0);\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete non influenza altre chat dello stesso utente\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_does_not_affect_other_chats(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Alice è in 3 chat\r\n        let initial_count = repo.find_many_by_user_id(\u00261).await?.len();\r\n        assert_eq!(initial_count, 3);\r\n        \r\n        // Delete Alice dalla General Chat\r\n        repo.delete(\u0026(1, 1)).await?;\r\n        \r\n        // Alice dovrebbe essere ancora in 2 chat\r\n        let after_delete = repo.find_many_by_user_id(\u00261).await?;\r\n        assert_eq!(after_delete.len(), 2);\r\n        \r\n        // Verifica che sia stata eliminata solo dalla General Chat\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(1, 2)).await?.is_some());\r\n        assert!(repo.read(\u0026(1, 3)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete non influenza altri utenti nella stessa chat\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_does_not_affect_other_users(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // General Chat ha 3 membri\r\n        let initial_members = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(initial_members.len(), 3);\r\n        \r\n        // Delete Bob dalla General Chat\r\n        repo.delete(\u0026(2, 1)).await?;\r\n        \r\n        // Dovrebbero rimanere 2 membri\r\n        let after_delete = repo.find_many_by_chat_id(\u00261).await?;\r\n        assert_eq!(after_delete.len(), 2);\r\n        \r\n        // Verifica che solo Bob sia stato eliminato\r\n        assert!(repo.read(\u0026(1, 1)).await?.is_some());\r\n        assert!(repo.read(\u0026(2, 1)).await?.is_none());\r\n        assert!(repo.read(\u0026(3, 1)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO CASCADE: scenario complesso con delete manuali e CASCADE\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_cascade_complex_scenario(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea 2 utenti e 2 chat con matrice completa\r\n        let user1_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user1\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let user2_id = sqlx::query!(\r\n            \"INSERT INTO users (username, password) VALUES (?, ?)\",\r\n            \"user2\",\r\n            \"password\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat1_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 1\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let chat2_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Chat 2\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        \r\n        // Crea 4 metadata\r\n        for \u0026user_id in \u0026[user1_id, user2_id] {\r\n            for \u0026chat_id in \u0026[chat1_id, chat2_id] {\r\n                let dto = CreateUserChatMetadataDTO {\r\n                    user_id,\r\n                    chat_id,\r\n                    user_role: Some(UserRole::Member),\r\n                    member_since: now,\r\n                    messages_visible_from: now,\r\n                    messages_received_until: now,\r\n                };\r\n                repo.create(\u0026dto).await?;\r\n            }\r\n        }\r\n        \r\n        // Verifica: 4 metadata esistono\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Delete manuale di user1 da chat1\r\n        repo.delete(\u0026(user1_id, chat1_id)).await?;\r\n        assert!(repo.read(\u0026(user1_id, chat1_id)).await?.is_none());\r\n        \r\n        // Elimina user1 - CASCADE elimina user1-chat2\r\n        sqlx::query!(\"DELETE FROM users WHERE user_id = ?\", user1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user1_id, chat2_id)).await?.is_none());\r\n        \r\n        // user2 dovrebbe avere ancora entrambi i metadata\r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_some());\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        // Elimina chat1 - CASCADE elimina user2-chat1\r\n        sqlx::query!(\"DELETE FROM chats WHERE chat_id = ?\", chat1_id)\r\n            .execute(\u0026pool)\r\n            .await?;\r\n        \r\n        assert!(repo.read(\u0026(user2_id, chat1_id)).await?.is_none());\r\n        \r\n        // Solo user2-chat2 dovrebbe rimanere\r\n        assert!(repo.read(\u0026(user2_id, chat2_id)).await?.is_some());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete con combinazioni di ID validi e invalidi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_mixed_valid_invalid_ids(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool);\r\n        \r\n        // Tutte queste delete non dovrebbero generare errori\r\n        assert!(repo.delete(\u0026(1, 999)).await.is_ok());\r\n        assert!(repo.delete(\u0026(999, 1)).await.is_ok());\r\n        assert!(repo.delete(\u0026(-5, 1)).await.is_ok());\r\n        assert!(repo.delete(\u0026(1, -5)).await.is_ok());\r\n        assert!(repo.delete(\u0026(0, 0)).await.is_ok());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete ripetute non causano errori\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_multiple_times_no_error(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Crea un metadata\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test Chat\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let now = chrono::Utc::now();\r\n        let dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026dto).await?;\r\n        \r\n        // Delete multiple volte\r\n        for _ in 0..5 {\r\n            let result = repo.delete(\u0026(1, new_chat_id)).await;\r\n            assert!(result.is_ok(), \"Delete dovrebbe sempre avere successo\");\r\n        }\r\n        \r\n        // Verifica che sia stato eliminato\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    /// Test NEGATIVO: delete dopo operazioni fallite non causa problemi\r\n    #[sqlx::test(fixtures(path = \"../../fixtures\", scripts(\"users\", \"chats\")))]\r\n    async fn test_delete_after_failed_operations(pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        let repo = UserChatMetadataRepository::new(pool.clone());\r\n        \r\n        // Tenta create con FK invalida (fallisce)\r\n        let now = chrono::Utc::now();\r\n        let invalid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 999,\r\n            chat_id: 1,\r\n            user_role: Some(UserRole::Member),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        let create_result = repo.create(\u0026invalid_dto).await;\r\n        assert!(create_result.is_err());\r\n        \r\n        // Delete non dovrebbe generare errori\r\n        let delete_result = repo.delete(\u0026(999, 1)).await;\r\n        assert!(delete_result.is_ok());\r\n        \r\n        // Verifica che i metadata esistenti siano ancora validi\r\n        let existing = repo.read(\u0026(1, 1)).await?;\r\n        assert!(existing.is_some());\r\n        \r\n        // Delete valido dovrebbe funzionare\r\n        let new_chat_id = sqlx::query!(\r\n            \"INSERT INTO chats (title, description, chat_type) VALUES (?, ?, ?)\",\r\n            \"Test\",\r\n            None::\u003cString\u003e,\r\n            \"GROUP\"\r\n        )\r\n        .execute(\u0026pool)\r\n        .await?\r\n        .last_insert_id() as i32;\r\n        \r\n        let valid_dto = CreateUserChatMetadataDTO {\r\n            user_id: 1,\r\n            chat_id: new_chat_id,\r\n            user_role: Some(UserRole::Owner),\r\n            member_since: now,\r\n            messages_visible_from: now,\r\n            messages_received_until: now,\r\n        };\r\n        \r\n        repo.create(\u0026valid_dto).await?;\r\n        \r\n        let delete_valid = repo.delete(\u0026(1, new_chat_id)).await;\r\n        assert!(delete_valid.is_ok());\r\n        assert!(repo.read(\u0026(1, new_chat_id)).await?.is_none());\r\n        \r\n        Ok(())\r\n    }\r\n\r\n}\r\n\r\n\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":20,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":24,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":25,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":37,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":39,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":40,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":42,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":46,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":53,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":56,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":58,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":59,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":61,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":62,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":65,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":67,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":68,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":70,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":71,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":74,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":76,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":80,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":84,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":85,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":97,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":99,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":100,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":102,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":107,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":111,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":115,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":117,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":119,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":120,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":125,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":126,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":127,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":128,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":129,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":130,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":132,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":133,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":135,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":136,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":137,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":138,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":139,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":140,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":141,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":145,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":147,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":150,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":157,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":158,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":159,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":170,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":171,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":172,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":174,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":175,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":178,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":179,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":183,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":184,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":185,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":191,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":235,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":236,"address":[],"length":0,"stats":{"Line":12393906174523604992}},{"line":237,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":250,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":251,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":253,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":254,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":256,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":263,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":269,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":270,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":271,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":272,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":275,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":276,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":277,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":285,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":286,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":287,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":288,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":290,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":295,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":296,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":299,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":300,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":302,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":303,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":305,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":308,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":313,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":314,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":316,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":317,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":319,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":320,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":322,"address":[],"length":0,"stats":{"Line":2522015791327477760}}],"covered":108,"coverable":111},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","auth.rs"],"content":"//! Auth services - Gestione autenticazione e registrazione utenti\r\n\r\nuse crate::core::{AppError, AppState, encode_jwt};\r\nuse crate::dtos::{CreateUserDTO, UserDTO};\r\nuse crate::entities::User;\r\nuse crate::repositories::Create;\r\nuse axum::{\r\n    extract::{Json, State},\r\n    http::{HeaderMap, HeaderValue, StatusCode},\r\n    response::IntoResponse,\r\n};\r\nuse std::sync::Arc;\r\nuse validator::Validate;\r\nuse tracing::{debug, error, info, instrument, warn};\r\n\r\n/// DTO per il login (solo username e password)\r\n#[derive(serde::Deserialize)]\r\npub struct LoginDTO {\r\n    pub username: String,\r\n    pub password: String,\r\n}\r\n\r\n#[instrument(skip(state, body), fields(username = %body.username))]\r\npub async fn login_user(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Json(body): Json\u003cLoginDTO\u003e, // JSON body\r\n) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\r\n    debug!(\"Login attempt for user\");\r\n    // 1. Estrarre lo username dal body della richiesta, ritornare errore BAD_REQUEST se mancante\r\n    // 2. Verificare che la password sia stata fornita nel body, altrimenti ritornare errore UNAUTHORIZED (fail-fast prima della query DB)\r\n    // 3. Bloccare il caso in cui si sta cercando di fare login con \"Deleted User\" (controllo string prima della query DB)\r\n    // 4. Cercare l'utente nel database tramite username\r\n    // 5. Se l'utente non esiste, ritornare errore UNAUTHORIZED\r\n    // 6. Verificare che la password fornita, dopo essere hashata, corrisponda all'hash memorizzato\r\n    // 7. Se la password non corrisponde, ritornare errore UNAUTHORIZED con messaggio specifico\r\n    // 8. Generare un token JWT con il metodo encode che prende in input userid, username e il segreto\r\n    // 9. Costruire un cookie HttpOnly, Secure, SameSite=Lax con il token e durata 24 ore\r\n    // 10. Creare gli headers HTTP con Set-Cookie e Authorization (Bearer token)\r\n    // 11. Ritornare StatusCode::OK con gli headers\r\n\r\n    if body.username == \"Deleted User\" {\r\n        warn!(\"Login attempt with 'Deleted User' username\");\r\n        return Err(AppError::unauthorized(\"Invalid username or password\"));\r\n    }\r\n\r\n    let user = match state.user.find_by_username(\u0026body.username).await? {\r\n        Some(user) =\u003e {\r\n            debug!(\"User found in database\");\r\n            user\r\n        }\r\n        None =\u003e {\r\n            warn!(\"User not found in database\");\r\n            return Err(AppError::unauthorized(\"Invalid username or password\"));\r\n        }\r\n    };\r\n\r\n    if !user.verify_password(\u0026body.password) {\r\n        warn!(\"Invalid password for user\");\r\n        return Err(AppError::unauthorized(\r\n            \"Username or password are not correct.\",\r\n        ));\r\n    }\r\n\r\n    let token = encode_jwt(user.username.clone(), user.user_id, \u0026state.jwt_secret)?;\r\n\r\n    let cookie_value = format!(\r\n        \"token={}; HttpOnly; Secure; SameSite=Lax; Max-Age={}\",\r\n        token,\r\n        24 * 60 * 60\r\n    );\r\n\r\n    let mut headers = HeaderMap::new();\r\n    headers.insert(\"Set-Cookie\", HeaderValue::from_str(\u0026cookie_value).unwrap());\r\n    headers.insert(\r\n        \"Authorization\",\r\n        HeaderValue::from_str(\u0026format!(\"Bearer {}\", token)).unwrap(),\r\n    );\r\n\r\n    info!(\"User logged in successfully: {}\", user.username);\r\n    Ok((StatusCode::OK, headers))\r\n}\r\n\r\n#[instrument(skip(state, body), fields(username = %body.username))]\r\npub async fn register_user(\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Json(body): Json\u003cCreateUserDTO\u003e, // JSON body\r\n) -\u003e Result\u003cJson\u003cUserDTO\u003e, AppError\u003e {\r\n    debug!(\"User registration attempt\");\r\n    // 1. Validare il DTO con validator (username/password format, lunghezza, \"Deleted User\")\r\n    // 2. Controllare se esiste già un utente con lo stesso username nel database\r\n    // 3. Se l'utente esiste già, ritornare errore CONFLICT con messaggio \"Username already exists\"\r\n    // 4. Generare l'hash della password fornita\r\n    // 5. Se la generazione dell'hash fallisce, ritornare errore INTERNAL_SERVER_ERROR\r\n    // 6. Creare un nuovo oggetto CreateUserDTO con username e password hashata\r\n    // 7. Salvare il nuovo utente nel database tramite il metodo create\r\n    // 8. Convertire l'utente creato in UserDTO\r\n    // 9. Ritornare il DTO dell'utente creato come risposta JSON\r\n\r\n    // Validazione con validator (include controllo \"Deleted User\")\r\n    body.validate()?;\r\n\r\n    // Controllare se esiste già un utente con lo stesso username\r\n    if let Some(_) = state.user.find_by_username(\u0026body.username).await? {\r\n        warn!(\"Username already exists\");\r\n        return Err(AppError::conflict(\"Username already exists\"));\r\n    }\r\n\r\n    let password_hash = User::hash_password(\u0026body.password)\r\n        .map_err(|e| {\r\n            error!(\"Failed to hash password: {:?}\", e);\r\n            AppError::internal_server_error(\"Failed to hash password\")\r\n        })?;\r\n\r\n    let new_user = CreateUserDTO {\r\n        username: body.username.clone(),\r\n        password: password_hash,\r\n    };\r\n\r\n    let created_user = state.user.create(\u0026new_user).await?;\r\n\r\n    info!(\"User registered successfully: {}\", created_user.username);\r\n    Ok(Json(UserDTO::from(created_user)))\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","chat.rs"],"content":"//! Chat services - Gestione operazioni sulle chat\n\nuse crate::core::{AppError, AppState};\nuse crate::dtos::{ChatDTO, CreateChatDTO, CreateUserChatMetadataDTO, MessageDTO, MessagesQuery};\nuse crate::entities::{Chat, ChatType, User, UserChatMetadata, UserRole};\nuse crate::repositories::{Create, Read};\nuse axum::{\n    Extension,\n    extract::{Json, Path, Query, State},\n};\nuse chrono::Utc;\nuse futures_util::future::try_join_all;\nuse std::sync::Arc;\nuse validator::Validate;\nuse tracing::{debug, info, instrument, warn};\n\n/// DTO per creare una chat (estende CreateChatDTO con user_list per chat private)\n#[derive(serde::Deserialize)]\npub struct CreateChatRequestDTO {\n    pub title: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub chat_type: ChatType,\n    pub user_list: Option\u003cVec\u003ci32\u003e\u003e, // Solo per chat private\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id))]\npub async fn list_chats(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cChatDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing chats for user\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti i metadata dell'utente dal database tramite user_id (singola query)\n    // 3. Estrarre tutti i chat_id dai metadata trovati\n    // 4. Recuperare tutte le chat con query parallele (primary key lookup, velocissimo)\n    // 5. Convertire ogni Chat in ChatDTO (trasformazione in memoria, nessun I/O)\n    // 6. Ritornare la lista di ChatDTO come risposta JSON\n    let chat_ids: Vec\u003ci32\u003e = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?\n        .into_iter()\n        .map(|s| s.chat_id)\n        .collect();\n\n    debug!(\"User is member of {} chats\", chat_ids.len());\n\n    let chats: Vec\u003cChat\u003e = try_join_all(chat_ids.into_iter().map(|cid| {\n        let state = state.clone();\n        async move { state.chat.read(\u0026cid).await }\n    }))\n    .await?\n    .into_iter()\n    .flatten()\n    .collect();\n\n    let chats_dto: Vec\u003cChatDTO\u003e = chats.into_iter().map(ChatDTO::from).collect();\n\n    info!(\"Successfully retrieved {} chats\", chats_dto.len());\n    Ok(Json(chats_dto))\n}\n\n#[instrument(skip(state, current_user, body), fields(user_id = %current_user.user_id, chat_type = ?body.chat_type))]\npub async fn create_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione tramite token jwt\n    Json(body): Json\u003cCreateChatRequestDTO\u003e,\n) -\u003e Result\u003cJson\u003cChatDTO\u003e, AppError\u003e {\n    debug!(\"Creating new chat\");\n    // CASO ChatType::Private:\n    // 1. Verificare che user_list sia presente nel body, altrimenti errore BAD_REQUEST\n    // 2. Verificare che user_list contenga esattamente 2 utenti, altrimenti errore BAD_REQUEST\n    // 3. Verificare che current_user sia uno dei due utenti, altrimenti errore BAD_REQUEST\n    // 4. Identificare l'user_id del secondo utente (diverso da current_user)\n    // 5. Cercare se esiste già una chat privata tra i due utenti (query DB solo dopo validazioni)\n    // 6. Se esiste già, ritornare errore CONFLICT\n    // 7. Creare ChatCreateDTO con title=None, description=None, chat_type=Private\n    // 8. Salvare la chat nel database (la chiave primaria è autoincrementale)\n    // 9. Creare metadata per entrambi gli utenti con ruolo Member e timestamp correnti (preparazione in memoria)\n    // 10. Salvare entrambi i metadata nel database in batch/transazione\n    //\n    // CASO ChatType::Group:\n    // 1. Creare ChatCreateDTO con title e description dal body, chat_type=Group\n    // 2. Salvare la chat nel database (la chiave primaria è autoincrementale)\n    // 3. Creare metadata per current_user con ruolo Owner e timestamp correnti\n    // 4. Salvare il metadata nel database\n    //\n    // FINALE:\n    // 1. Convertire la chat creata in ChatDTO (trasformazione in memoria)\n    // 2. Ritornare il ChatDTO come risposta JSON\n\n    let chat;\n    match body.chat_type {\n        ChatType::Private =\u003e {\n            debug!(\"Creating private chat\");\n            let user_list = body\n                .user_list\n                .as_ref()\n                .ok_or_else(|| {\n                    warn!(\"Private chat creation attempted without user list\");\n                    AppError::bad_request(\"Private chat should specify user list.\")\n                })?;\n\n            if user_list.len() != 2 {\n                warn!(\"Private chat creation attempted with {} users instead of 2\", user_list.len());\n                return Err(AppError::bad_request(\n                    \"Private chat should specify exactly two users.\",\n                ));\n            }\n\n            let second_user_id = user_list\n                .iter()\n                .find(|\u0026\u0026id| id != current_user.user_id)\n                .ok_or_else(|| {\n                    warn!(\"Current user not in user list for private chat\");\n                    AppError::bad_request(\"Current user must be one of the two users.\")\n                })?;\n\n            let existing_chat = state\n                .chat\n                .get_private_chat_between_users(\u0026current_user.user_id, second_user_id)\n                .await?;\n            if existing_chat.is_some() {\n                warn!(\"Private chat already exists between users {} and {}\", current_user.user_id, second_user_id);\n                return Err(AppError::conflict(\n                    \"A private chat between these users already exists.\",\n                ));\n            }\n            let new_chat = CreateChatDTO {\n                title: None,\n                description: None,\n                chat_type: ChatType::Private,\n            };\n            chat = state.chat.create(\u0026new_chat).await?;\n\n            debug!(\"Private chat created with id {}\", chat.chat_id);\n\n            let now = Utc::now();\n            let metadata_current_user = CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            let metadata_second_user = CreateUserChatMetadataDTO {\n                user_id: *second_user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            // Create both metadata in a single transaction for atomicity\n            state\n                .meta\n                .create_many(\u0026[metadata_current_user, metadata_second_user])\n                .await?;\n            \n            info!(\"Private chat created successfully between users {} and {}\", current_user.user_id, second_user_id);\n        }\n\n        ChatType::Group =\u003e {\n            debug!(\"Creating group chat\");\n            let new_chat = CreateChatDTO {\n                title: body.title.clone(),\n                description: body.description.clone(),\n                chat_type: ChatType::Group,\n            };\n\n            // Validazione con validator\n            new_chat.validate()?;\n\n            chat = state.chat.create(\u0026new_chat).await?;\n\n            debug!(\"Group chat created with id {}\", chat.chat_id);\n\n            let now = Utc::now();\n            let metadata_owner = CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id: chat.chat_id,\n                user_role: Some(UserRole::Owner),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            };\n\n            state.meta.create(\u0026metadata_owner).await?;\n            \n            info!(\"Group chat '{}' created successfully by user {}\", chat.title.as_ref().unwrap_or(\u0026String::from(\"Unnamed\")), current_user.user_id);\n        }\n    }\n\n    let chat_dto = ChatDTO::from(chat);\n    Ok(Json(chat_dto))\n}\n\n#[instrument(skip(state, metadata), fields(chat_id = %chat_id, user_id = %metadata.user_id))]\npub async fn get_chat_messages(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Query(params): Query\u003cMessagesQuery\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003cJson\u003cVec\u003cMessageDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Fetching chat messages\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Estrarre query parameters (before_date opzionale)\n    // 3. Ottenere metadata dell'utente dall'Extension (inserito dal chat_membership_middleware)\n    // 4. Se before_date presente: recuperare 50 messaggi prima di quella data\n    //    Altrimenti: recuperare ultimi 50 messaggi disponibili\n    // 5. Convertire ogni messaggio in MessageDTO (trasformazione in memoria, nessun I/O)\n    // 6. Ritornare la lista di MessageDTO come risposta JSON\n\n    let (before_date, limit) = if let Some(date) = params.before_date {\n        (Some(date), 50)\n    } else {\n        (None, 50)\n    };\n\n    let messages = state\n        .msg\n        .find_many_paginated(\n            \u0026chat_id,\n            \u0026metadata.messages_visible_from,\n            before_date.as_ref(),\n            limit,\n        )\n        .await?;\n\n    info!(\"Retrieved {} messages for chat\", messages.len());\n\n    let messages_dto: Vec\u003cMessageDTO\u003e = messages.into_iter().map(MessageDTO::from).collect();\n\n    Ok(Json(messages_dto))\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","membership.rs"],"content":"//! Membership services - Gestione membri e ruoli nelle chat\n\nuse crate::core::{AppError, AppState, require_role};\nuse crate::dtos::{\n    CreateInvitationDTO, CreateMessageDTO, CreateUserChatMetadataDTO, InvitationDTO, MessageDTO,\n    UpdateInvitationDTO, UserInChatDTO,\n};\nuse crate::entities::{ChatType, InvitationStatus, MessageType, User, UserChatMetadata, UserRole};\nuse crate::repositories::{Create, Delete, Read, Update};\nuse crate::ws::usermap::InternalSignal;\nuse axum::{\n    Extension,\n    extract::{Json, Path, State},\n};\nuse axum_macros::debug_handler;\nuse chrono::Utc;\nuse std::sync::Arc;\nuse validator::Validate;\nuse tracing::{debug, info, instrument, warn};\n\n#[instrument(skip(state, _metadata), fields(chat_id = %chat_id))]\npub async fn list_chat_members(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Extension(_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware (verifica già la membership)\n) -\u003e Result\u003cJson\u003cVec\u003cUserInChatDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing members for chat\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Ottenere metadata dell'utente dall'Extension (membership già verificata dal middleware)\n    // 3. Recuperare tutti i metadata associati alla chat tramite chat_id (singola query)\n    // 4. Estrarre tutti gli user_id dai metadata\n    // 5. Recuperare tutti gli utenti con query parallele per ogni user_id\n    // 6. Combinare le informazioni degli utenti con i metadata (join in memoria)\n    // 7. Convertire ogni combinazione in UserInChatDTO (trasformazione in memoria)\n    // 8. Ritornare la lista di UserInChatDTO come risposta JSON\n\n    let meta = state.meta.find_many_by_chat_id(\u0026chat_id).await?;\n\n    debug!(\"Found {} members in chat\", meta.len());\n\n    let user_ids: Vec\u003ci32\u003e = meta.iter().map(|m| m.user_id).collect();\n\n    let var: Vec\u003c_\u003e = user_ids.iter().map(|id| state.user.read(id)).collect();\n    let results: Vec\u003cOption\u003cUser\u003e\u003e = futures::future::try_join_all(var).await?;\n    let users: Vec\u003cUser\u003e = results.into_iter().filter_map(|u| u).collect();\n\n    let mut result: Vec\u003cUserInChatDTO\u003e = Vec::new();\n    for user in users {\n        if let Some(m) = meta.iter().find(|m| m.user_id == user.user_id) {\n            result.push(UserInChatDTO {\n                user_id: Some(user.user_id),\n                chat_id: Some(m.chat_id),\n                username: Some(user.username),\n                user_role: m.user_role.clone(),\n                member_since: Some(m.member_since),\n            });\n        }\n    }\n\n    info!(\"Successfully retrieved {} members\", result.len());\n    Ok(Json(result))\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id))]\npub async fn list_pending_invitations(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cInvitationDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Listing pending invitations for user\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti gli inviti pending per l'utente corrente\n    // 3. Convertire ogni invito in InvitationDTO\n    // 4. Ritornare la lista di InvitationDTO come risposta JSON\n\n    let invitations = state\n        .invitation\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?;\n\n    info!(\"Found {} pending invitations\", invitations.len());\n\n    let invitations_dto: Vec\u003cInvitationDTO\u003e =\n        invitations.into_iter().map(InvitationDTO::from).collect();\n\n    Ok(Json(invitations_dto))\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, inviting_user = %current_user.user_id, target_user = %user_id))]\npub async fn invite_to_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, user_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Inviting user to chat\");\n    // 1. Estrarre chat_id e user_id dal path, ottenere utente corrente e metadata dall'Extension\n    // 2. Verificare che current_user sia Admin o Owner tramite metadata\n    // 3. Verificare che la chat esista e sia di tipo Group (non si può invitare in chat private)\n    // 4. Verificare che l'utente target esista nel database (fail-fast su controllo basilare)\n    // 5. Verificare che l'utente target non sia già membro\n    // 6. Controllare se esiste già un invito pending\n    // 7. Creare l'invitation nel database\n    // 8. Inviare l'invitation via WebSocket all'utente invitato (se online)\n    // 9. Ritornare OK\n\n    require_role(\u0026metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    // Verificare che la chat esista e sia di tipo Group\n    let chat = state\n        .chat\n        .read(\u0026chat_id)\n        .await?\n        .ok_or_else(|| {\n            warn!(\"Chat not found: {}\", chat_id);\n            AppError::not_found(\"Chat not found\")\n        })?;\n\n    if chat.chat_type != ChatType::Group {\n        warn!(\"Attempted to invite user to private chat\");\n        return Err(AppError::bad_request(\"Cannot invite users to private chats\"));\n    }\n\n    // Verificare che l'utente target esista nel database\n    if state.user.read(\u0026user_id).await?.is_none() {\n        warn!(\"Target user not found: {}\", user_id);\n        return Err(AppError::not_found(\"User not found\"));\n    }\n\n    // Verificare che l'utente target non sia già membro\n    if state.meta.read(\u0026(user_id, chat_id)).await?.is_some() {\n        warn!(\"User {} is already a member of chat {}\", user_id, chat_id);\n        return Err(AppError::conflict(\"User is already a member of this chat\"));\n    }\n\n    // Controllare se esiste già un invito pending\n    if state\n        .invitation\n        .has_pending_invitation(\u0026user_id, \u0026chat_id)\n        .await?\n    {\n        warn!(\"Pending invitation already exists for user {} to chat {}\", user_id, chat_id);\n        return Err(AppError::conflict(\n            \"There is already a pending invitation for this user to this chat\",\n        ));\n    }\n\n    // Creare l'invitation nel database\n    let invitation = state\n        .invitation\n        .create(\u0026CreateInvitationDTO {\n            target_chat_id: chat_id,\n            invited_id: user_id,\n            invitee_id: current_user.user_id,\n        })\n        .await?;\n\n    debug!(\"Invitation created with id {}\", invitation.invite_id);\n\n    // Inviare l'invitation via WebSocket all'utente invitato (se online)\n    let invitation_dto = InvitationDTO::from(invitation);\n    state\n        .users_online\n        .send_server_message_if_online(\u0026user_id, InternalSignal::Invitation(invitation_dto));\n\n    info!(\"User successfully invited to chat\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user), fields(invite_id = %invite_id, action = %action, user_id = %current_user.user_id))]\npub async fn respond_to_invitation(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((invite_id, action)): Path\u003c(i32, String)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Responding to invitation\");\n    // 1. Estrarre invite_id e action (accept/reject) dal path\n    // 2. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 3. Validare che action sia \"accept\" o \"reject\"\n    // 4. Recuperare l'invito dal database\n    // 5. Verificare che l'invito sia pending e che current_user sia l'invitato\n    // 6. Se accept: creare metadata per aggiungere l'utente alla chat con ruolo Member\n    // 7. Se accept e utente online: inviare segnale AddChat per sottoscriversi ai messaggi\n    // 8. Aggiornare lo stato dell'invito (Accepted/Rejected)\n    // 9. Creare messaggio di sistema nella chat target con notifica appropriata\n    // 10. Salvare il messaggio dopo validazione\n    // 11. Inviare il messaggio tramite WebSocket a tutti i membri online\n    // 12. Ritornare OK\n\n    // Validare action\n    let new_status = match action.as_str() {\n        \"accept\" =\u003e InvitationStatus::Accepted,\n        \"reject\" =\u003e InvitationStatus::Rejected,\n        _ =\u003e {\n            warn!(\"Invalid invitation action: {}\", action);\n            return Err(AppError::bad_request(\"Action must be 'accept' or 'reject'\"));\n        }\n    };\n\n    // Recuperare l'invito\n    let invitation = state\n        .invitation\n        .read(\u0026invite_id)\n        .await?\n        .ok_or_else(|| {\n            warn!(\"Invitation not found: {}\", invite_id);\n            AppError::not_found(\"Invitation not found\")\n        })?;\n\n    // Verificare che sia pending\n    if invitation.state != InvitationStatus::Pending {\n        warn!(\"Invitation {} is already processed: {:?}\", invite_id, invitation.state);\n        return Err(AppError::conflict(\"Invitation is already processed\").with_details(format!(\n            \"Invitation is already {:?}\",\n            invitation.state\n        )));\n    }\n\n    // Verificare che current_user sia l'invitato\n    if invitation.invited_id != current_user.user_id {\n        warn!(\"User {} attempted to respond to invitation for user {}\", current_user.user_id, invitation.invited_id);\n        return Err(AppError::forbidden(\"You are not the recipient of this invitation\"));\n    }\n\n    let chat_id = invitation.target_chat_id;\n\n    // Se accetta, aggiungere l'utente alla chat\n    if matches!(new_status, InvitationStatus::Accepted) {\n        debug!(\"User accepted invitation, adding to chat {}\", chat_id);\n        let now = Utc::now();\n        state\n            .meta\n            .create(\u0026CreateUserChatMetadataDTO {\n                user_id: current_user.user_id,\n                chat_id,\n                user_role: Some(UserRole::Member),\n                member_since: now,\n                messages_visible_from: now,\n                messages_received_until: now,\n            })\n            .await?;\n\n        // Se l'utente è online, inviare segnale AddChat per sottoscriversi ai messaggi della chat\n        state\n            .users_online\n            .send_server_message_if_online(\u0026current_user.user_id, InternalSignal::AddChat(chat_id));\n    } else {\n        debug!(\"User rejected invitation\");\n    }\n\n    // Aggiornare lo stato dell'invito\n    state\n        .invitation\n        .update(\n            \u0026invite_id,\n            \u0026UpdateInvitationDTO {\n                state: Some(new_status.clone()),\n            },\n        )\n        .await?;\n\n    // Creare messaggio di sistema appropriato\n    let content = if matches!(new_status, InvitationStatus::Accepted) {\n        format!(\"User {} has joined the chat\", current_user.username)\n    } else {\n        format!(\"User {} has declined the invitation\", current_user.username)\n    };\n\n    let create_dto = CreateMessageDTO {\n        chat_id,\n        sender_id: current_user.user_id,\n        content,\n        message_type: MessageType::SystemMessage,\n        created_at: Utc::now(),\n    };\n\n    create_dto\n        .validate()\n        .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state\n        .chats_online\n        .send(\u0026chat_id, Arc::new(MessageDTO::from(saved_message)));\n    \n    info!(\"Invitation response processed successfully\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, user_id = %current_user.user_id))]\npub async fn leave_chat(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(chat_id): Path\u003ci32\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"User leaving chat\");\n    // 1. Estrarre chat_id dal path della URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare il ruolo: se è Owner, ritornare errore CONFLICT con messaggio specifico (fail-fast, controllo in memoria)\n    // 4. Cancellare i metadata di current_user per questa chat dal database\n    // 5. Se utente online: inviare segnale RemoveChat per disiscriversi dai messaggi della chat\n    // 6. Creare un messaggio di sistema che notifica l'uscita (i messaggi dell'utente rimangono nel DB)\n    // 7. Salvare il messaggio nel database\n    // 8. Inviare il messaggio tramite WebSocket a tutti i membri online (operazione non bloccante)\n    // 9. Ritornare StatusCode::OK\n\n    // L'Owner non può lasciare la chat\n    if matches!(metadata.user_role, Some(UserRole::Owner)) {\n        warn!(\"Owner attempted to leave chat\");\n        return Err(AppError::conflict(\n            \"The owner cannot leave the chat. Transfer ownership or delete the chat.\",\n        ));\n    }\n\n    state.meta.delete(\u0026(current_user.user_id, chat_id)).await?;\n\n    // Se l'utente è online, inviare segnale RemoveChat per disiscriversi dai messaggi della chat\n    state\n        .users_online\n        .send_server_message_if_online(\u0026current_user.user_id, InternalSignal::RemoveChat(chat_id));\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\"User {} has left the chat\", current_user.username)),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n    .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n    .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"User successfully left chat\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, current_metadata), fields(chat_id = %chat_id, removing_user = %current_user.user_id, target_user = %user_id))]\npub async fn remove_member(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, user_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(current_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Removing member from chat\");\n    // 1. Estrarre chat_id e user_id dal path dalla URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Admin o Owner, altrimenti ritornare errore FORBIDDEN (fail-fast)\n    // 4. Recuperare metadata dell'utente target per verificare membership (singola query)\n    // 5. Verificare che non si stia cercando di rimuovere l'Owner, altrimenti ritornare errore FORBIDDEN (controllo in memoria)\n    // 6. Cancellare i metadata dell'utente target per questa chat dal database\n    // 7. Creare un messaggio di sistema che notifica la rimozione del membro (i messaggi dell'utente rimangono nel DB)\n    // 8. Salvare il messaggio nel database dopo validazione\n    // 9. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 10. Ritornare StatusCode::OK\n\n    require_role(\u0026current_metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    let target_meta = state.meta.read(\u0026(user_id, chat_id)).await?.ok_or_else(|| {\n        warn!(\"Target user {} is not a member of chat {}\", user_id, chat_id);\n        AppError::not_found(\"The user to be removed is not a member of this chat\")\n    })?;\n\n    // Non si può rimuovere l'Owner\n    if matches!(target_meta.user_role, Some(UserRole::Owner)) {\n        warn!(\"Attempted to remove owner from chat\");\n        return Err(AppError::forbidden(\"You cannot remove the owner of the chat\"));\n    }\n\n    state.meta.delete(\u0026(user_id, chat_id)).await?;\n\n    let target_user_opt = state.user.read(\u0026user_id).await?;\n\n    let target_username = target_user_opt\n        .as_ref()\n        .map(|u| u.username.clone())\n        .unwrap_or_else(|| \"Unknown User\".to_string());\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has removed {} from the chat\",\n            current_user.username, target_username\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n        .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n        .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Member successfully removed from chat\");\n    Ok(())\n}\n\n#[debug_handler]\n#[instrument(skip(state, current_user, current_metadata, body), fields(chat_id = %chat_id, updating_user = %current_user.user_id, target_user = %user_id, new_role = ?body))]\npub async fn update_member_role(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((user_id, chat_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(current_metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n    Json(body): Json\u003cUserRole\u003e,\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Updating member role in chat\");\n    // 1. Estrarre user_id e chat_id dal path della URL, nuovo ruolo dal body JSON\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Admin o Owner, altrimenti ritornare errore FORBIDDEN (fail-fast)\n    // 4. Recuperare metadata dell'utente target per verificare membership (singola query)\n    // 5. Verificare le regole di promozione: Owner può modificare tutti, Admin può modificare solo Member (controllo in memoria)\n    // 6. Admin non può assegnare ruolo Owner (controllo in memoria)\n    // 7. Aggiornare il campo user_role nei metadata dell'utente target\n    // 8. Creare un messaggio di sistema che notifica il cambio di ruolo\n    // 9. Salvare il messaggio nel database dopo validazione\n    // 10. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 11. Ritornare StatusCode::OK\n\n    require_role(\u0026current_metadata, \u0026[UserRole::Admin, UserRole::Owner])?;\n\n    let target_meta = state.meta.read(\u0026(user_id, chat_id)).await?.ok_or_else(|| {\n        warn!(\"Target user {} is not a member of chat {}\", user_id, chat_id);\n        AppError::not_found(\n            \"The user whose role is to be changed is not a member of this chat\",\n        )\n    })?;\n\n    match current_metadata.user_role {\n        Some(UserRole::Admin) =\u003e {\n            // Admin può modificare solo Member\n            match target_meta.user_role {\n                Some(UserRole::Member) =\u003e { /* ok */ }\n                _ =\u003e {\n                    warn!(\"Admin attempted to modify non-member role\");\n                    return Err(AppError::forbidden(\"Admin can modify only members\"));\n                }\n            }\n\n            // Admin non può assegnare Owner\n            match body {\n                UserRole::Owner =\u003e {\n                    warn!(\"Admin attempted to assign owner role\");\n                    return Err(AppError::forbidden(\"Only Owner can assign ownership\"));\n                }\n                _ =\u003e { /* ok */ }\n            }\n        }\n        _ =\u003e { /* current user non-admin: altre regole già gestite sopra */ }\n    }\n\n    state\n        .meta\n        .update_user_role(\u0026user_id, \u0026chat_id, \u0026body)\n        .await?;\n\n    let target_user_opt = state.user.read(\u0026user_id).await?;\n\n    let target_username = target_user_opt\n        .as_ref()\n        .map(|u| u.username.clone())\n        .unwrap_or_else(|| \"Unknown User\".to_string());\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has changed {}'s role to {:?}\",\n            current_user.username, target_username, body\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n    .map_err(|_| AppError::bad_request(\"Failed to build message dto\"))?;\n\n    create_dto\n        .validate()\n    .map_err(|_| AppError::bad_request(\"Validation error\"))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Member role updated successfully\");\n    Ok(())\n}\n\n#[instrument(skip(state, current_user, metadata), fields(chat_id = %chat_id, current_owner = %current_user.user_id, new_owner = %new_owner_id))]\npub async fn transfer_ownership(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path((chat_id, new_owner_id)): Path\u003c(i32, i32)\u003e,\n    Extension(current_user): Extension\u003cUser\u003e,\n    Extension(metadata): Extension\u003cUserChatMetadata\u003e, // ottenuto dal chat_membership_middleware\n) -\u003e Result\u003c(), AppError\u003e {\n    debug!(\"Transferring chat ownership\");\n    // 1. Estrarre chat_id e new_owner_id dal path della URL\n    // 2. Ottenere l'utente corrente e metadata dall'Extension\n    // 3. Verificare che current_user sia Owner tramite metadata\n    // 4. Verificare che current_user non stia trasferendo a se stesso (controllo in memoria)\n    // 5. Verificare che la chat esista e sia di tipo Group (le chat private non hanno owner)\n    // 6. Verificare che il nuovo owner esista come utente nel sistema\n    // 7. Trasferire ownership con metodo atomico: current_user diventa Admin, new_owner diventa Owner\n    // 8. Creare un messaggio di sistema che notifica il trasferimento di ownership\n    // 9. Salvare il messaggio nel database dopo validazione\n    // 10. Inviare il messaggio tramite WebSocket a tutti i membri online della chat (operazione non bloccante)\n    // 11. Ritornare StatusCode::OK\n\n    require_role(\u0026metadata, \u0026[UserRole::Owner])?;\n\n    if current_user.user_id == new_owner_id {\n        warn!(\"Attempted to transfer ownership to self\");\n        return Err(AppError::bad_request(\n            \"Cannot transfer ownership to yourself\",\n        ));\n    }\n\n    let chat = state.chat.read(\u0026chat_id).await?;\n\n    if let Some(chat_data) = chat {\n        if chat_data.chat_type != ChatType::Group {\n            warn!(\"Attempted to transfer ownership of private chat\");\n            return Err(AppError::bad_request(\n                \"Cannot transfer ownership of private chats\",\n            ));\n        }\n    } else {\n        warn!(\"Chat not found: {}\", chat_id);\n        return Err(AppError::not_found(\"Chat not found\"));\n    }\n\n    let new_owner_user = state.user.read(\u0026new_owner_id).await?;\n\n    let new_owner_username = match new_owner_user {\n        Some(user) =\u003e user.username,\n        None =\u003e {\n            warn!(\"New owner user not found: {}\", new_owner_id);\n            return Err(AppError::not_found(\"New owner user not found\"));\n        }\n    };\n\n    debug!(\"Performing ownership transfer\");\n    // Trasferisce la proprietà dal current_user al nuovo owner\n    state\n        .meta\n        .transfer_ownership(\u0026current_user.user_id, \u0026new_owner_id, \u0026chat_id)\n        .await?;\n\n    let message_dto = MessageDTO {\n        message_id: None,\n        chat_id: Some(chat_id),\n        sender_id: Some(current_user.user_id),\n        content: Some(format!(\n            \"User {} has transferred ownership to {}\",\n            current_user.username, new_owner_username\n        )),\n        message_type: Some(MessageType::SystemMessage),\n        created_at: Some(Utc::now()),\n    };\n\n    let create_dto = CreateMessageDTO::try_from(message_dto.clone())\n        .map_err(|e| AppError::bad_request(\"Failed to build message dto\").with_details(e.to_string()))?;\n\n    create_dto\n        .validate()\n        .map_err(|e| AppError::bad_request(\"Validation error\").with_details(e.to_string()))?;\n\n    let _saved_message = state.msg.create(\u0026create_dto).await?;\n\n    let _ = state.chats_online.send(\u0026chat_id, Arc::new(message_dto));\n    info!(\"Ownership transferred successfully\");\n    Ok(())\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","mod.rs"],"content":"//! Services module - Coordinatore per tutti i service handler HTTP\r\n//!\r\n//! Questo modulo organizza i service handlers in sotto-moduli separati per una migliore manutenibilità.\r\n//! Ogni modulo gestisce gli endpoint HTTP per una specifica funzionalità.\r\n\r\npub mod auth;\r\npub mod chat;\r\npub mod membership;\r\npub mod user;\r\n\r\n// Re-exports per facilitare l'import\r\npub use auth::{login_user, register_user};\r\npub use chat::{create_chat, get_chat_messages, list_chats};\r\npub use membership::{\r\n    invite_to_chat, leave_chat, list_chat_members, list_pending_invitations, remove_member,\r\n    respond_to_invitation, transfer_ownership, update_member_role,\r\n};\r\npub use user::{delete_my_account, get_user_by_id, search_user_with_username};\r\n\r\nuse crate::AppState;\r\nuse axum::{extract::State, http::StatusCode, response::IntoResponse};\r\nuse std::sync::Arc;\r\n\r\n/// Root endpoint - health check\r\npub async fn root(State(_state): State\u003cArc\u003cAppState\u003e\u003e) -\u003e impl IntoResponse {\r\n    (StatusCode::OK, \"Server is running!\")\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","services","user.rs"],"content":"//! User services - Gestione utenti\n\nuse crate::core::{AppError, AppState};\nuse crate::dtos::{UserDTO, UserSearchQuery};\nuse crate::entities::{User, UserRole};\nuse crate::repositories::{Delete, Read};\nuse axum::{\n    Extension,\n    extract::{Json, Path, Query, State},\n    http::{HeaderMap, HeaderValue, StatusCode},\n    response::IntoResponse,\n};\nuse futures::future;\nuse std::sync::Arc;\nuse tracing::{debug, info, instrument, warn};\n\n#[instrument(skip(state), fields(search = %params.search))]\npub async fn search_user_with_username(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Query(params): Query\u003cUserSearchQuery\u003e, // query params /users/find?search=username\n) -\u003e Result\u003cJson\u003cVec\u003cUserDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Searching users with partial username\");\n    // 1. Estrarre il parametro search dalla query string\n    // 2. Cercare nel database tutti gli utenti con username che contiene parzialmente la query, cercando solo all'inizio dello username\n    // 3. Convertire ogni utente trovato in UserDTO\n    // 4. Ritornare la lista di UserDTO come risposta JSON\n    let users = state\n        .user\n        .search_by_username_partial(\u0026(params.search))\n        .await?;\n    info!(\"Found {} users matching search criteria\", users.len());\n    let users_dto = users.into_iter().map(UserDTO::from).collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(Json::from(users_dto))\n}\n\n#[instrument(skip(state), fields(user_id = %user_id))]\npub async fn get_user_by_id(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Path(user_id): Path\u003ci32\u003e, // parametro dalla URL /users/:user_id\n) -\u003e Result\u003cJson\u003cOption\u003cUserDTO\u003e\u003e, AppError\u003e {\n    debug!(\"Fetching user by ID\");\n    // 1. Estrarre user_id dal path della URL\n    // 2. Cercare l'utente nel database tramite user_id\n    // 3. Se l'utente esiste, convertirlo in UserDTO\n    // 4. Ritornare Option\u003cUserDTO\u003e come risposta JSON (Some se trovato, None se non trovato)\n    let user_option = state.user.read(\u0026user_id).await?;\n    if user_option.is_some() {\n        info!(\"User found\");\n    } else {\n        warn!(\"User not found\");\n    }\n    Ok(Json(user_option.map(UserDTO::from)))\n}\n\n#[instrument(skip(state, current_user), fields(user_id = %current_user.user_id, username = %current_user.username))]\npub async fn delete_my_account(\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione tramite token jwt\n) -\u003e Result\u003cimpl IntoResponse, AppError\u003e {\n    info!(\"User account deletion initiated\");\n    // 1. Ottenere l'utente corrente dall'Extension (autenticato tramite JWT)\n    // 2. Recuperare tutti i metadata dell'utente per identificare chat ownership (singola query)\n    let user_metadata = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?;\n\n    debug!(\"Found {} chat memberships for user\", user_metadata.len());\n\n    // 3. Gestire il caso degli ownership: se l'utente è owner di gruppi\n    for metadata in \u0026user_metadata {\n        if matches!(metadata.user_role, Some(UserRole::Owner)) {\n            debug!(\"Handling ownership transfer for chat {}\", metadata.chat_id);\n            // Recuperare tutti i membri della chat\n            let chat_members = state.meta.find_many_by_chat_id(\u0026metadata.chat_id).await?;\n\n            if chat_members.len() == 1 {\n                // Se l'owner è l'unico membro, cancellare la chat completamente\n                // ON DELETE CASCADE cancellerà automaticamente i metadata e i messaggi\n                info!(\"Deleting chat {} (user is the only member)\", metadata.chat_id);\n                state.chat.delete(\u0026metadata.chat_id).await?;\n            } else {\n                // Cercare un admin a cui trasferire l'ownership\n                let new_owner = chat_members\n                    .iter()\n                    .find(|m| {\n                        m.user_id != current_user.user_id\n                            \u0026\u0026 matches!(m.user_role, Some(UserRole::Admin))\n                    })\n                    .or_else(|| {\n                        // Se non c'è un admin, prendi qualsiasi altro membro\n                        chat_members\n                            .iter()\n                            .find(|m| m.user_id != current_user.user_id)\n                    });\n\n                if let Some(new_owner) = new_owner {\n                    // Trasferire l'ownership\n                    info!(\"Transferring ownership of chat {} to user {}\", metadata.chat_id, new_owner.user_id);\n                    state\n                        .meta\n                        .transfer_ownership(\n                            \u0026current_user.user_id,\n                            \u0026new_owner.user_id,\n                            \u0026metadata.chat_id,\n                        )\n                        .await?;\n                }\n            }\n        }\n    }\n\n    // 4. Cancellare tutti i metadata (UserChatMetadata) associati all'utente\n    // (solo per le chat non eliminate al punto 3 - quelle erano già cancellate da CASCADE)\n    // Raccogliere le chiavi per la cancellazione\n\n    let meta_ids: Vec\u003c(i32, i32)\u003e = state\n        .meta\n        .find_many_by_user_id(\u0026current_user.user_id)\n        .await?\n        .into_iter()\n        .map(|m| (m.user_id, m.chat_id))\n        .collect();\n\n    debug!(\"Deleting {} metadata entries\", meta_ids.len());\n    // Cancellazione effettiva\n    future::join_all(meta_ids.iter().map(|k| state.meta.delete(\u0026k))).await;\n\n    // 5-6. Rinominare lo username dell'utente con \"Deleted User\" e sostituire la password con stringa vuota\n    info!(\"Soft deleting user account\");\n    state.user.delete(\u0026current_user.user_id).await?;\n\n    // 7-8. Creare un cookie con Max-Age=0 per forzare il logout lato client\n    let cookie = \"token=; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=0\";\n    let mut headers = HeaderMap::new();\n    headers.insert(\"Set-Cookie\", HeaderValue::from_str(cookie).unwrap());\n\n    // 9. Ritornare StatusCode::OK con gli headers e messaggio\n    info!(\"Account deleted successfully\");\n    Ok((StatusCode::OK, headers, \"Account deleted successfully\"))\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","chatmap.rs"],"content":"use crate::dtos::MessageDTO;\r\nuse crate::ws::BROADCAST_CHANNEL_CAPACITY;\r\nuse dashmap::DashMap;\r\nuse std::sync::Arc;\r\nuse tokio::sync::broadcast;\r\nuse tokio::sync::broadcast::error::SendError;\r\nuse tokio::sync::broadcast::{Receiver, Sender};\r\nuse tracing::{info, instrument, warn};\r\n\r\npub struct ChatMap {\r\n    /// Attribute to retrieve the tx head og a broadcast channel by chat_id field\r\n    channels: DashMap\u003ci32, Sender\u003cArc\u003cMessageDTO\u003e\u003e\u003e,\r\n}\r\n\r\nimpl ChatMap {\r\n    pub fn new() -\u003e Self {\r\n        ChatMap {\r\n            channels: DashMap::new(),\r\n        }\r\n    }\r\n\r\n    #[instrument(skip(self), fields(chat_id))]\r\n    pub fn subscribe(\u0026self, chat_id: \u0026i32) -\u003e Receiver\u003cArc\u003cMessageDTO\u003e\u003e {\r\n        match self.channels.get(chat_id) {\r\n            // required subscription on non existing chat channel\r\n            None =\u003e {\r\n                info!(\"Creating new broadcast channel for chat\");\r\n                // Arc\u003cMessage\u003e to share the ref, not the message. Avoid unuseful copies of message on each rx.\r\n                let (tx, rx) = broadcast::channel::\u003cArc\u003cMessageDTO\u003e\u003e(BROADCAST_CHANNEL_CAPACITY);\r\n                self.channels.insert(*chat_id, tx);\r\n                rx\r\n            }\r\n            // subscribe to an existing channel == get a rx head == subscribe to a tx\r\n            Some(c) =\u003e {\r\n                info!(\"Subscribing to existing broadcast channel\");\r\n                c.value().subscribe()\r\n            }\r\n        }\r\n    }\r\n\r\n    #[instrument(skip(self, chat_ids))]\r\n    pub fn subscribe_multiple(\u0026self, chat_ids: Vec\u003ci32\u003e) -\u003e Vec\u003cReceiver\u003cArc\u003cMessageDTO\u003e\u003e\u003e {\r\n        info!(count = chat_ids.len(), \"Subscribing to multiple chats\");\r\n        chat_ids.into_iter().map(|id| self.subscribe(\u0026id)).collect()\r\n    }\r\n\r\n    #[instrument(skip(self, msg), fields(chat_id))]\r\n    pub fn send(\r\n        \u0026self,\r\n        chat_id: \u0026i32,\r\n        msg: Arc\u003cMessageDTO\u003e,\r\n    ) -\u003e Result\u003cusize, SendError\u003cArc\u003cMessageDTO\u003e\u003e\u003e {\r\n        if let Some(chat) = self.channels.get(chat_id) {\r\n            match chat.send(msg.clone()) {\r\n                Ok(n) =\u003e {\r\n                    info!(receivers = n, \"Message broadcast to receivers\");\r\n                    Ok(n)\r\n                }\r\n                Err(e) =\u003e {\r\n                    warn!(\"No active receivers, removing channel\");\r\n                    // Nessuno sta ascoltando, rimuovi il channel\r\n                    drop(chat); // Rilascia il lock\r\n                    self.channels.remove(chat_id);\r\n                    Err(e)\r\n                }\r\n            }\r\n        } else {\r\n            warn!(\"Attempted to send to non-existent chat channel\");\r\n            Err(SendError(msg))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","connection.rs"],"content":"//! WebSocket Connection Management - Gestione connessioni WebSocket\r\n\r\nuse crate::ws::{BATCH_INTERVAL, BATCH_MAX_SIZE, RATE_LIMITER_MILLIS, TIMEOUT_DURATION_SECONDS};\r\nuse crate::{\r\n    AppState,\r\n    dtos::MessageDTO,\r\n    ws::{event_handlers::process_message, usermap::InternalSignal},\r\n};\r\nuse axum::extract::ws::Utf8Bytes;\r\nuse axum::extract::ws::{Message, WebSocket};\r\nuse futures_util::stream::{SplitSink, SplitStream};\r\nuse futures_util::{SinkExt, StreamExt};\r\nuse std::{sync::Arc};\r\nuse tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender, unbounded_channel};\r\nuse tokio::time::Duration;\r\nuse tokio::time::{interval, timeout};\r\nuse tokio_stream::StreamMap;\r\nuse tokio_stream::wrappers::BroadcastStream;\r\nuse tracing::{error, info, instrument, warn};\r\n\r\n#[instrument(skip(ws, state), fields(user_id))]\r\npub async fn handle_socket(ws: WebSocket, state: Arc\u003cAppState\u003e, user_id: i32) {\r\n    info!(\"WebSocket connection established\");\r\n\r\n    // Dividiamo il WebSocket in due metà: sender e receiver\r\n    let (ws_tx, ws_rx) = ws.split();\r\n\r\n    // Creiamo un canale unbounded per comunicazione interna\r\n    // considerare passaggio a unbounded channel per non perdere eventuali segnali\r\n    let (int_tx, int_rx) = unbounded_channel::\u003cInternalSignal\u003e();\r\n\r\n    // Salviamo nello stato il trasmettitore di watch associato all'utente\r\n    // Il ricevitore sarà usato dal task dedicato alla scrittura\r\n    state.users_online.register_online(user_id, int_tx.clone());\r\n    info!(\"User registered as online\");\r\n\r\n    // dobbiamo iniziare un task che stia in ascolto del websocket\r\n    tokio::spawn(listen_ws(user_id, ws_rx, int_tx.clone(), state.clone()));\r\n\r\n    // creare un task che sta in ascolto sull'insieme dei canali broadcast\r\n    tokio::spawn(write_ws(user_id, ws_tx, int_rx, state));\r\n}\r\n\r\n#[instrument(skip(websocket_tx, internal_rx, state), fields(user_id))]\r\npub async fn write_ws(\r\n    user_id: i32,\r\n    mut websocket_tx: SplitSink\u003cWebSocket, Message\u003e,\r\n    mut internal_rx: UnboundedReceiver\u003cInternalSignal\u003e,\r\n    state: Arc\u003cAppState\u003e,\r\n) {\r\n    info!(\"Write task started\");\r\n\r\n    let chat_vec: Vec\u003ci32\u003e = match state.meta.find_many_by_user_id(\u0026user_id).await {\r\n        Ok(chats) =\u003e {\r\n            info!(chat_count = chats.len(), \"User chats loaded\");\r\n            chats.iter().map(|m| m.chat_id).collect()\r\n        }\r\n        Err(e) =\u003e {\r\n            error!(\"Failed to load user chats: {:?}\", e);\r\n            return; // Termina se DB fallisce\r\n        }\r\n    };\r\n\r\n    let mut stream_map = StreamMap::new();\r\n\r\n    state\r\n        .chats_online\r\n        .subscribe_multiple(chat_vec.clone())\r\n        .into_iter()\r\n        .zip(chat_vec.iter())\r\n        .for_each(|(rx, \u0026chat_id)| {\r\n            stream_map.insert(chat_id, BroadcastStream::new(rx));\r\n        });\r\n\r\n    let mut batch: Vec\u003cArc\u003cMessageDTO\u003e\u003e = Vec::new();\r\n    let mut interval = tokio::time::interval(Duration::from_millis(BATCH_INTERVAL));\r\n    interval.tick().await; // Consuma primo tick immediato\r\n\r\n    'external: loop {\r\n        tokio::select! {\r\n            Some((_, result)) = tokio_stream::StreamExt::next(\u0026mut stream_map) =\u003e {\r\n                if let Ok(msg) = result {\r\n                    batch.push(msg);\r\n                    if batch.len() \u003e= BATCH_MAX_SIZE {\r\n                        if send_batch(\u0026mut websocket_tx, \u0026batch).await.is_err() {\r\n                            warn!(\"Failed to send batch, closing connection\");\r\n                            break 'external;\r\n                        }\r\n                        info!(batch_size = batch.len(), \"Batch sent\");\r\n                        batch.clear();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // serve per fare in modo di inviare dei messaggi anche se il batch non è arrivato a 10\r\n            // altrimenti aspetterei troppo\r\n            _ = interval.tick() =\u003e {\r\n                if !batch.is_empty() {\r\n                    if send_batch(\u0026mut websocket_tx, \u0026batch).await.is_err() {\r\n                        warn!(\"Failed to send batch on interval, closing connection\");\r\n                        break 'external;\r\n                    }\r\n                    info!(batch_size = batch.len(), \"Batch sent on interval\");\r\n                    batch.clear();\r\n                }\r\n            }\r\n\r\n            signal = internal_rx.recv() =\u003e {\r\n                match signal {\r\n                    Some(InternalSignal::Shutdown) =\u003e {\r\n                        info!(\"Shutdown signal received\");\r\n                        break 'external;\r\n                    }\r\n                    Some(InternalSignal::AddChat(chat_id)) =\u003e {\r\n                        info!(chat_id, \"Adding chat subscription\");\r\n                        let rx = state.chats_online.subscribe(\u0026chat_id);\r\n                        stream_map.insert(chat_id, BroadcastStream::new(rx));\r\n                    }\r\n                    Some(InternalSignal::RemoveChat(chat_id)) =\u003e {\r\n                        info!(chat_id, \"Removing chat subscription\");\r\n                        stream_map.remove(\u0026chat_id);\r\n                    }\r\n                    Some(InternalSignal::Error(err_msg)) =\u003e {\r\n                        warn!(error_message = err_msg, \"Sending error message to client\");\r\n                        if let Err(e) = websocket_tx.send(Message::Text(Utf8Bytes::from(err_msg))).await {\r\n                            error!(\"Failed to send error message: {:?}\", e);\r\n                            break;\r\n                        }\r\n                    }\r\n                    Some(InternalSignal::Invitation(invitation)) =\u003e {\r\n                        info!(invite_id = invitation.invite_id, \"Sending invitation to client\");\r\n                        if let Ok(json) = serde_json::to_string(\u0026invitation) {\r\n                            if let Err(e) = websocket_tx.send(Message::Text(Utf8Bytes::from(json))).await {\r\n                                error!(\"Failed to send invitation: {:?}\", e);\r\n                                break 'external;\r\n                            }\r\n                        } else {\r\n                            error!(\"Failed to serialize invitation\");\r\n                        }\r\n                    }\r\n                    None =\u003e {\r\n                        info!(\"Internal channel closed\");\r\n                        break 'external; // canale chiuso, quindi listener ws chius, quindi stacca tutto\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Invia batch finale prima di terminare\r\n    if !batch.is_empty() {\r\n        info!(\r\n            batch_size = batch.len(),\r\n            \"Sending final batch before shutdown\"\r\n        );\r\n        let _ = send_batch(\u0026mut websocket_tx, \u0026batch).await;\r\n    }\r\n\r\n    info!(\"Write task terminated\");\r\n}\r\n\r\n#[instrument(skip(websocket_tx, batch))]\r\nasync fn send_batch(\r\n    websocket_tx: \u0026mut SplitSink\u003cWebSocket, Message\u003e,\r\n    batch: \u0026[Arc\u003cMessageDTO\u003e],\r\n) -\u003e Result\u003c(), axum::Error\u003e {\r\n    let json = serde_json::to_string(\u0026batch).map_err(|e| {\r\n        error!(\"Failed to serialize batch: {:?}\", e);\r\n        axum::Error::new(e)\r\n    })?;\r\n    websocket_tx\r\n        .send(Message::Text(Utf8Bytes::from(json)))\r\n        .await\r\n        .map_err(|e| {\r\n            error!(\"Failed to send batch through WebSocket: {:?}\", e);\r\n            e\r\n        })\r\n}\r\n\r\n#[instrument(skip(websocket_rx, internal_tx, state), fields(user_id))]\r\npub async fn listen_ws(\r\n    user_id: i32,\r\n    mut websocket_rx: SplitStream\u003cWebSocket\u003e,\r\n    internal_tx: UnboundedSender\u003cInternalSignal\u003e,\r\n    state: Arc\u003cAppState\u003e,\r\n) {\r\n    info!(\"Listen task started\");\r\n\r\n    let mut rate_limiter = interval(Duration::from_millis(RATE_LIMITER_MILLIS));\r\n    let timeout_duration = Duration::from_secs(TIMEOUT_DURATION_SECONDS);\r\n\r\n    loop {\r\n        match timeout(timeout_duration, StreamExt::next(\u0026mut websocket_rx)).await {\r\n            Ok(Some(msg_result)) =\u003e {\r\n                rate_limiter.tick().await;\r\n\r\n                let msg = match msg_result {\r\n                    Ok(m) =\u003e m,\r\n                    Err(e) =\u003e {\r\n                        warn!(\"WebSocket error: {:?}\", e);\r\n                        break;\r\n                    }\r\n                };\r\n\r\n                match msg {\r\n                    Message::Text(text) =\u003e {\r\n                        if let Ok(event) = serde_json::from_str::\u003cMessageDTO\u003e(\u0026text) {\r\n                            info!(\"Message received from client\");\r\n                            process_message(\u0026state, user_id, event).await;\r\n                        } else {\r\n                            warn!(\"Failed to deserialize message\");\r\n                        }\r\n                    }\r\n                    Message::Close(_) =\u003e {\r\n                        info!(\"Close message received\");\r\n                        break;\r\n                    }\r\n                    _ =\u003e {}\r\n                }\r\n            }\r\n            Ok(None) =\u003e {\r\n                info!(\"WebSocket stream ended\");\r\n                break;\r\n            }\r\n            Err(_) =\u003e {\r\n                warn!(\r\n                    timeout_secs = TIMEOUT_DURATION_SECONDS,\r\n                    \"Connection timeout\"\r\n                );\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cleanup\r\n    info!(\"Cleaning up connection\");\r\n    let _ = internal_tx.send(InternalSignal::Shutdown);\r\n    state.users_online.remove_from_online(\u0026user_id);\r\n    info!(\"Listen task terminated\");\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","event_handlers.rs"],"content":"//! WebSocket Event Handlers - Handler per eventi WebSocket\r\n\r\nuse tracing::{error, info, instrument, warn};\r\nuse validator::Validate;\r\n\r\nuse crate::AppState;\r\nuse crate::dtos::{CreateMessageDTO, MessageDTO};\r\nuse crate::entities::MessageType;\r\nuse crate::repositories::{Create, Read};\r\nuse crate::ws::usermap::InternalSignal;\r\nuse std::sync::Arc;\r\n\r\n#[instrument(skip(state, msg), fields(user_id, chat_id = msg.chat_id))]\r\npub async fn process_message(state: \u0026Arc\u003cAppState\u003e, user_id: i32, msg: MessageDTO) {\r\n    info!(\"Processing message from user\");\r\n\r\n    let input_message = match CreateMessageDTO::try_from(msg.clone()) {\r\n        Ok(msg) =\u003e msg,\r\n        Err(e) =\u003e {\r\n            warn!(\"Malformed message received: {:?}\", e);\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"Malformed message.\"),\r\n            );\r\n            return;\r\n        }\r\n    };\r\n\r\n    if let Err(e) = input_message.validate() {\r\n        warn!(\"Message validation failed: {:?}\", e);\r\n        state\r\n            .users_online\r\n            .send_server_message_if_online(\u0026user_id, InternalSignal::Error(\"Malformed message.\"));\r\n        return;\r\n    };\r\n\r\n    if input_message.message_type == MessageType::SystemMessage {\r\n        warn!(\"User attempted to send system message\");\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\"You cannot send system type messages.\"),\r\n        );\r\n        return;\r\n    }\r\n\r\n    // se la chat non esistesse, allora non esisterebbe neanche il metadata, quindi non controllo l'esistenza della chat.\r\n    match state.meta.read(\u0026(user_id, input_message.chat_id)).await {\r\n        Ok(Some(val)) =\u003e val,\r\n        Ok(None) =\u003e {\r\n            warn!(\r\n                chat_id = input_message.chat_id,\r\n                \"User does not belong to chat\"\r\n            );\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"You don't belong to that group.\"),\r\n            );\r\n            return;\r\n        }\r\n        Err(e) =\u003e {\r\n            error!(\"Failed to read user metadata: {:?}\", e);\r\n            state.users_online.send_server_message_if_online(\r\n                \u0026user_id,\r\n                InternalSignal::Error(\"Internal server error.\"),\r\n            );\r\n            return;\r\n        }\r\n    };\r\n\r\n    // bene, l'utente appartiene alla chat, quindi può inviare il messaggio\r\n    // invio prima ad utenti online\r\n    if let Err(e) = state\r\n        .chats_online\r\n        .send(\u0026input_message.chat_id, Arc::from(msg))\r\n    {\r\n        error!(\r\n            chat_id = input_message.chat_id,\r\n            \"Failed to broadcast message to online users: {:?}\", e\r\n        );\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\"Internal server error.\"),\r\n        );\r\n    }\r\n\r\n    // salvo in db per utenti offline\r\n    if let Err(e) = state.msg.create(\u0026input_message).await {\r\n        error!(\"Failed to persist message to database: {:?}\", e);\r\n        state.users_online.send_server_message_if_online(\r\n            \u0026user_id,\r\n            InternalSignal::Error(\r\n                \"Something went wrong and your message was not stored correctly!\",\r\n            ),\r\n        );\r\n    } else {\r\n        info!(\"Message processed and stored successfully\");\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","mod.rs"],"content":"//! WebSocket Module - Gestione WebSocket per comunicazione real-time\r\n//!\r\n//! Questo modulo gestisce le connessioni WebSocket per la comunicazione in tempo reale\r\n//! tra client e server. Include:\r\n//! - Gestione upgrade HTTP -\u003e WebSocket\r\n//! - Gestione connessioni (split sender/receiver)\r\n//! - Handler per eventi WebSocket (messaggi, inviti)\r\n//! - Utility per broadcasting e invio errori\r\n\r\npub mod chatmap;\r\npub mod connection;\r\npub mod event_handlers;\r\npub mod usermap;\r\n\r\n// Re-exports pubblici\r\npub use connection::handle_socket;\r\n\r\nuse crate::{AppState, entities::User};\r\nuse axum::{\r\n    Extension,\r\n    extract::{State, ws::WebSocketUpgrade},\r\n    response::Response,\r\n};\r\nuse std::sync::Arc;\r\nuse tracing::{info, instrument};\r\n\r\n// how many messages should the channel contain?\r\nconst BROADCAST_CHANNEL_CAPACITY: usize = 100;\r\n\r\n/// Intervallo massimo tra invii batch (ms)\r\nconst BATCH_INTERVAL: u64 = 1000;\r\n\r\n/// Numero massimo di messaggi per batch\r\nconst BATCH_MAX_SIZE: usize = 10;\r\n\r\n/// Delay minimo tra messaggi client (ms) - max 100 msg/sec\r\nconst RATE_LIMITER_MILLIS: u64 = 10;\r\n\r\n/// Timeout inattività prima di chiudere connessione (secondi)\r\nconst TIMEOUT_DURATION_SECONDS: u64 = 300;\r\n\r\n/// Entry point per gestire richieste di upgrade WebSocket\r\n/// Operazioni:\r\n/// 1. Estrarre user_id dall'autenticazione JWT\r\n/// 2. Eseguire upgrade HTTP -\u003e WebSocket\r\n/// 3. Passare la connessione ad handle_socket\r\n#[instrument(skip(ws, state, current_user), fields(user_id = current_user.user_id))]\r\npub async fn ws_handler(\r\n    ws: WebSocketUpgrade,\r\n    State(state): State\u003cArc\u003cAppState\u003e\u003e,\r\n    Extension(current_user): Extension\u003cUser\u003e, // ottenuto dall'autenticazione JWT\r\n) -\u003e Response {\r\n    let user_id = current_user.user_id;\r\n    info!(\"WebSocket upgrade requested\");\r\n\r\n    // Gestisce automaticamente l'upgrade a WebSocket.\r\n    // Se l'upgrade fallisce, ritorna un errore; altrimenti restituisce la nuova connessione al client.\r\n\r\n    ws\r\n        // Possibile limitazione dei buffer, default 128 KB\r\n        //.read_buffer_size(4*1024)\r\n        //.write_buffer_size(16*1024)\r\n        .on_upgrade(move |socket| handle_socket(socket, state, user_id))\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["C:","\\","Users","eriks","Desktop","G43","server","src","ws","usermap.rs"],"content":"use dashmap::DashMap;\nuse tokio::sync::mpsc::{UnboundedSender};\nuse tracing::{info, instrument, warn};\n\nuse crate::dtos::{InvitationDTO};\n\npub enum InternalSignal {\n    Shutdown,\n    AddChat(i32),\n    RemoveChat(i32),\n    Error(\u0026'static str),\n    Invitation(InvitationDTO),\n}\n\npub struct UserMap {\n    users_online: DashMap\u003ci32, UnboundedSender\u003cInternalSignal\u003e\u003e,\n}\n\nimpl UserMap {\n    pub fn new() -\u003e Self {\n        UserMap {\n            users_online: DashMap::new(),\n        }\n    }\n\n    #[instrument(skip(self, tx), fields(user_id))]\n    pub fn register_online(\u0026self, user_id: i32, tx: UnboundedSender\u003cInternalSignal\u003e) {\n        info!(\"Registering user as online\");\n        self.users_online.insert(user_id, tx);\n    }\n\n    #[instrument(skip(self), fields(user_id))]\n    pub fn remove_from_online(\u0026self, user_id: \u0026i32) {\n        info!(\"Removing user from online\");\n        self.users_online.remove(\u0026user_id);\n    }\n\n    #[instrument(skip(self, message), fields(user_id))]\n    pub fn send_server_message_if_online(\u0026self, user_id: \u0026i32, message: InternalSignal) {\n        if let Some(entry) = self.users_online.get(\u0026user_id) {\n            let tx = entry.value();\n            if let Err(e) = tx.send(message) {\n                warn!(\"Failed to send message to user: {:?}\", e);\n            } else {\n                info!(\"Message sent to online user\");\n            }\n        } else {\n            info!(\"User not online, message not sent\");\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_auth.rs"],"content":"//! Integration tests per gli endpoints di autenticazione\r\n//!\r\n//! Test per:\r\n//! - POST /auth/login\r\n//! - POST /auth/register\r\n//!\r\n//! Questi test usano `#[sqlx::test]` che:\r\n//! - Crea automaticamente un database di test isolato\r\n//! - Applica le migrations da `migrations/`\r\n//! - Applica i fixtures specificati da `fixtures/`\r\n//! - Pulisce il database al termine\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod auth_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures users.sql sono stati caricati (alice, bob, charlie disponibili)\r\n        // Implementa qui i tuoi test per gli endpoint di autenticazione\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_chats.rs"],"content":"//! Integration tests per gli endpoints delle chat\r\n//!\r\n//! Test per:\r\n//! - GET /chats\r\n//! - POST /chats\r\n//! - GET /chats/{chat_id}/messages\r\n//! - GET /chats/{chat_id}/members\r\n//! - POST /chats/{chat_id}/invite/{user_id}\r\n//! - PATCH /chats/{chat_id}/members/{user_id}/role\r\n//! - PATCH /chats/{chat_id}/transfer_ownership\r\n//! - DELETE /chats/{chat_id}/members/{user_id}\r\n//! - POST /chats/{chat_id}/leave\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod chat_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\", \"chats\", \"messages\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures sono stati caricati in ordine: users, chats, messages\r\n        // Implementa qui i tuoi test per gli endpoint delle chat\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","api_users.rs"],"content":"//! Integration tests per gli endpoints degli utenti\r\n//!\r\n//! Test per:\r\n//! - GET /users?search=username\r\n//! - GET /users/{user_id}\r\n//! - DELETE /users/me\r\n\r\nmod common;\r\n\r\n#[cfg(test)]\r\nmod user_tests {\r\n    use sqlx::MySqlPool;\r\n\r\n    /// Test generico - esempio di utilizzo di #[sqlx::test]\r\n    #[sqlx::test(fixtures(path = \"../fixtures\", scripts(\"users\")))]\r\n    async fn test_example(_pool: MySqlPool) -\u003e sqlx::Result\u003c()\u003e {\r\n        // Il database è stato creato automaticamente con migrations applicate\r\n        // I fixtures users.sql sono stati caricati (alice, bob, charlie disponibili)\r\n        // Implementa qui i tuoi test per gli endpoint degli utenti\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","eriks","Desktop","G43","server","tests","common","mod.rs"],"content":"//! Test helpers and utilities\r\n//!\r\n//! Questo modulo contiene funzioni helper condivise tra tutti i test.\r\n//!\r\n//! ## Setup Database\r\n//! I test usano il macro `#[sqlx::test]` che gestisce automaticamente:\r\n//! - Creazione di un database di test isolato per ogni test\r\n//! - Applicazione automatica delle migrations da `migrations/`\r\n//! - Applicazione opzionale di fixtures da `fixtures/`\r\n//! - Cleanup automatico del database al termine del test\r\n//!\r\n//! ## Environment Variables\r\n//! Richiede `DATABASE_URL` con credenziali superuser (root) per creare/distruggere database di test.\r\n//! Esempio: `DATABASE_URL=mysql://root:password@localhost:3306`\r\n\r\n/// Genera un JWT token per testing\r\n///\r\n/// # Arguments\r\n/// * `user_id` - ID dell'utente per cui generare il token\r\n/// * `jwt_secret` - Secret key per firmare il token\r\n///\r\n/// # Returns\r\n/// Token JWT valido per 24 ore\r\npub fn create_test_jwt(user_id: i32, jwt_secret: \u0026str) -\u003e String {\r\n    use chrono::{Duration, Utc};\r\n    use jsonwebtoken::{EncodingKey, Header, encode};\r\n    use serde::{Deserialize, Serialize};\r\n\r\n    #[derive(Debug, Serialize, Deserialize)]\r\n    struct Claims {\r\n        sub: String,\r\n        exp: i64,\r\n    }\r\n\r\n    let expiration = Utc::now()\r\n        .checked_add_signed(Duration::hours(24))\r\n        .expect(\"valid timestamp\")\r\n        .timestamp();\r\n\r\n    let claims = Claims {\r\n        sub: user_id.to_string(),\r\n        exp: expiration,\r\n    };\r\n\r\n    encode(\r\n        \u0026Header::default(),\r\n        \u0026claims,\r\n        \u0026EncodingKey::from_secret(jwt_secret.as_bytes()),\r\n    )\r\n    .expect(\"Failed to create JWT token\")\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
>>>>>>> dev
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>